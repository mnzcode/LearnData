const e=JSON.parse('{"key":"v-4d774ed5","path":"/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ.html","title":"RocketMQ","lang":"zh-CN","frontmatter":{"description":"RocketMQ 基本介绍 消息队列 应用场景 消息队列是一种先进先出的数据结构，常见的应用场景： 应用解耦：系统的耦合性越高，容错性就越低 实例：用户创建订单后，耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障都会造成下单异常，影响用户使用体验。使用消息队列解耦合，比如物流系统发生故障，需要几分钟恢复，将物流系统要处理的数据缓存到消息队列中，用户的下单操作正常完成。等待物流系统正常后处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障 流量削峰：应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮，使用消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以提高系统的稳定性和用户体验 数据分发：让数据在多个系统更加之间进行流通，数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据","head":[["meta",{"property":"og:url","content":"https://newzone.top/learn_data/%E4%B8%AD%E9%97%B4%E4%BB%B6/RocketMQ.html"}],["meta",{"property":"og:site_name","content":"挨踢牛马"}],["meta",{"property":"og:title","content":"RocketMQ"}],["meta",{"property":"og:description","content":"RocketMQ 基本介绍 消息队列 应用场景 消息队列是一种先进先出的数据结构，常见的应用场景： 应用解耦：系统的耦合性越高，容错性就越低 实例：用户创建订单后，耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障都会造成下单异常，影响用户使用体验。使用消息队列解耦合，比如物流系统发生故障，需要几分钟恢复，将物流系统要处理的数据缓存到消息队列中，用户的下单操作正常完成。等待物流系统正常后处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障 流量削峰：应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮，使用消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以提高系统的稳定性和用户体验 数据分发：让数据在多个系统更加之间进行流通，数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-16T07:46:55.000Z"}],["meta",{"property":"article:author","content":"挨踢牛马"}],["meta",{"property":"article:modified_time","content":"2023-08-16T07:46:55.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RocketMQ\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-16T07:46:55.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"挨踢牛马\\",\\"url\\":\\"https://newzone.top\\"}]}"]]},"headers":[{"level":2,"title":"基本介绍","slug":"基本介绍","link":"#基本介绍","children":[{"level":3,"title":"消息队列","slug":"消息队列","link":"#消息队列","children":[]},{"level":3,"title":"安装测试","slug":"安装测试","link":"#安装测试","children":[]},{"level":3,"title":"相关概念","slug":"相关概念","link":"#相关概念","children":[]}]},{"level":2,"title":"消息操作","slug":"消息操作","link":"#消息操作","children":[{"level":3,"title":"基本样例","slug":"基本样例","link":"#基本样例","children":[]},{"level":3,"title":"顺序消息","slug":"顺序消息","link":"#顺序消息","children":[]},{"level":3,"title":"延时消息","slug":"延时消息","link":"#延时消息","children":[]},{"level":3,"title":"批量消息","slug":"批量消息","link":"#批量消息","children":[]},{"level":3,"title":"过滤消息","slug":"过滤消息","link":"#过滤消息","children":[]},{"level":3,"title":"事务消息","slug":"事务消息","link":"#事务消息","children":[]}]},{"level":2,"title":"系统特性","slug":"系统特性","link":"#系统特性","children":[{"level":3,"title":"工作流程","slug":"工作流程-1","link":"#工作流程-1","children":[]},{"level":3,"title":"存储机制","slug":"存储机制","link":"#存储机制","children":[]},{"level":3,"title":"集群设计","slug":"集群设计","link":"#集群设计","children":[]},{"level":3,"title":"负载均衡","slug":"负载均衡","link":"#负载均衡","children":[]},{"level":3,"title":"消息查询","slug":"消息查询","link":"#消息查询","children":[]},{"level":3,"title":"消息重试","slug":"消息重试","link":"#消息重试","children":[]},{"level":3,"title":"死信队列","slug":"死信队列","link":"#死信队列","children":[]},{"level":3,"title":"高可靠性","slug":"高可靠性","link":"#高可靠性","children":[]},{"level":3,"title":"幂等消费","slug":"幂等消费","link":"#幂等消费","children":[]},{"level":3,"title":"流量控制","slug":"流量控制","link":"#流量控制","children":[]}]},{"level":2,"title":"原理解析","slug":"原理解析-4","link":"#原理解析-4","children":[{"level":3,"title":"Namesrv","slug":"namesrv","link":"#namesrv","children":[]},{"level":3,"title":"Broker","slug":"broker","link":"#broker","children":[]},{"level":3,"title":"Producer","slug":"producer","link":"#producer","children":[]},{"level":3,"title":"Consumer","slug":"consumer","link":"#consumer","children":[]},{"level":3,"title":"生产消费","slug":"生产消费-1","link":"#生产消费-1","children":[]}]}],"git":{"createdTime":1692172015000,"updatedTime":1692172015000,"contributors":[{"name":"mnz","email":"dhuhua@foxmail.com","commits":1}]},"readingTime":{"minutes":170.84,"words":51251},"filePathRelative":"中间件/RocketMQ.md","localizedDate":"2023年8月16日","excerpt":"<h1> RocketMQ</h1>\\n<h2> 基本介绍</h2>\\n<h3> 消息队列</h3>\\n<h4> 应用场景</h4>\\n<p>消息队列是一种先进先出的数据结构，常见的应用场景：</p>\\n<ul>\\n<li>\\n<p>应用解耦：系统的耦合性越高，容错性就越低</p>\\n<p>实例：用户创建订单后，耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障都会造成下单异常，影响用户使用体验。使用消息队列解耦合，比如物流系统发生故障，需要几分钟恢复，将物流系统要处理的数据缓存到消息队列中，用户的下单操作正常完成。等待物流系统正常后处理存在消息队列中的订单消息即可，终端系统感知不到物流系统发生过几分钟故障</p>\\n<figure><img src=\\"https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-解耦.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n</li>\\n<li>\\n<p>流量削峰：应用系统如果遇到系统请求流量的瞬间猛增，有可能会将系统压垮，使用消息队列可以将大量请求缓存起来，分散到很长一段时间处理，这样可以提高系统的稳定性和用户体验</p>\\n<figure><img src=\\"https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-流量削峰.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n</li>\\n<li>\\n<p>数据分发：让数据在多个系统更加之间进行流通，数据的产生方不需要关心谁来使用数据，只需要将数据发送到消息队列，数据使用方直接在消息队列中直接获取数据</p>\\n<figure><img src=\\"https://seazean.oss-cn-beijing.aliyuncs.com/img/Frame/RocketMQ-数据分发.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n</li>\\n</ul>","autoDesc":true}');export{e as data};
