<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xsl" href="https://newzone.top/rss.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://newzone.top/rss.xml" rel="self" type="application/rss+xml"/>
    <title>挨踢牛马</title>
    <link>https://newzone.top/</link>
    <description>来自互联网的笔记。</description>
    <language>zh-CN</language>
    <pubDate>Fri, 18 Aug 2023 06:33:44 GMT</pubDate>
    <lastBuildDate>Fri, 18 Aug 2023 06:33:44 GMT</lastBuildDate>
    <generator>vuepress-plugin-feed2</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <item>
      <title>JVM</title>
      <link>https://newzone.top/Java/JVM.html</link>
      <guid>https://newzone.top/Java/JVM.html</guid>
      <source url="https://newzone.top/rss.xml">JVM</source>
      <description>JVM JVM概述 基本介绍 JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作 特点： Java 虚拟机基于二进制字节码执行，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成 JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的跨平台性</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> JVM</h1>
<h2> JVM概述</h2>
<h3> 基本介绍</h3>
<p>JVM：全称 Java Virtual Machine，即 Java 虚拟机，一种规范，本身是一个虚拟计算机，直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作</p>
<p>特点：</p>
<ul>
<li>Java 虚拟机基于<strong>二进制字节码</strong>执行，由一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆、一个方法区等组成</li>
<li>JVM 屏蔽了与操作系统平台相关的信息，从而能够让 Java 程序只需要生成能够在 JVM 上运行的字节码文件，通过该机制实现的<strong>跨平台性</strong></li>
</ul>
<p>Java 代码执行流程：<code>Java 程序 --（编译）--&gt; 字节码文件 --（解释执行）--&gt; 操作系统（Win，Linux）</code></p>
<p>JVM 结构：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-概述图.png" style="zoom: 80%;">
<p>JVM、JRE、JDK 对比：</p>
<ul>
<li>JDK(Java SE Development Kit)：Java 标准开发包，提供了编译、运行 Java 程序所需的各种工具和资源</li>
<li>JRE( Java Runtime Environment)：Java 运行环境，用于解释执行 Java 的字节码文件</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-JRE关系.png" style="zoom: 80%;">
<p>参考书籍：<a href="https://book.douban.com/subject/34907497/" target="_blank" rel="noopener noreferrer">https://book.douban.com/subject/34907497/</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1yE411Z7AP" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1yE411Z7AP</a></p>
<hr>
<h3> 架构模型</h3>
<p>Java 编译器输入的指令流是一种基于栈的指令集架构。因为跨平台的设计，Java 的指令都是根据栈来设计的，不同平台 CPU 架构不同，所以不能设计为基于寄存器架构</p>
<ul>
<li>基于栈式架构的特点：
<ul>
<li>设计和实现简单，适用于资源受限的系统</li>
<li>使用零地址指令方式分配，执行过程依赖操作栈，指令集更小，编译器容易实现
<ul>
<li>零地址指令：机器指令的一种，是指令系统中的一种不设地址字段的指令，只有操作码而没有地址码。这种指令有两种情况：一是无需操作数，另一种是操作数为默认的（隐含的），默认为操作数在寄存器（ACC）中，指令可直接访问寄存器</li>
<li>一地址指令：一个操作码对应一个地址码，通过地址码寻找操作数</li>
</ul>
</li>
<li>不需要硬件的支持，可移植性更好，更好实现跨平台</li>
</ul>
</li>
<li>基于寄存器架构的特点：
<ul>
<li>需要硬件的支持，可移植性差</li>
<li>性能更好，执行更高效，寄存器比内存快</li>
<li>以一地址指令、二地址指令、三地址指令为主</li>
</ul>
</li>
</ul>
<hr>
<h3> 生命周期</h3>
<p>JVM 的生命周期分为三个阶段，分别为：启动、运行、死亡</p>
<ul>
<li>
<p><strong>启动</strong>：当启动一个 Java 程序时，通过引导类加载器（bootstrap class loader）创建一个初始类（initial class），对于拥有 main 函数的类就是 JVM 实例运行的起点</p>
</li>
<li>
<p><strong>运行</strong>：</p>
<ul>
<li>
<p>main() 方法是一个程序的初始起点，任何线程均可由在此处启动</p>
</li>
<li>
<p>在 JVM 内部有两种线程类型，分别为：用户线程和守护线程，<strong>JVM 使用的是守护线程，main() 和其他线程使用的是用户线程</strong>，守护线程会随着用户线程的结束而结束</p>
</li>
<li>
<p>执行一个 Java 程序时，真真正正在执行的是一个 <strong>Java 虚拟机的进程</strong></p>
</li>
<li>
<p>JVM 有两种运行模式 Server 与 Client，两种模式的区别在于：Client 模式启动速度较快，Server 模式启动较慢；但是启动进入稳定期长期运行之后 Server 模式的程序运行速度比 Client 要快很多</p>
<p>Server 模式启动的 JVM 采用的是重量级的虚拟机，对程序采用了更多的优化；Client 模式启动的 JVM 采用的是轻量级的虚拟机</p>
</li>
</ul>
</li>
<li>
<p><strong>死亡</strong>：</p>
<ul>
<li>当程序中的用户线程都中止，JVM 才会退出</li>
<li>程序正常执行结束、程序异常或错误而异常终止、操作系统错误导致终止</li>
<li>线程调用 Runtime 类 halt 方法或 System 类 exit 方法，并且 Java 安全管理器允许这次 exit 或 halt 操作</li>
</ul>
</li>
</ul>
<hr>
<h2> 内存结构</h2>
<h3> 内存概述</h3>
<p>内存结构是 JVM 中非常重要的一部分，是非常重要的系统资源，是硬盘和 CPU 的桥梁，承载着操作系统和应用程序的实时运行，又叫运行时数据区</p>
<p>JVM 内存结构规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行</p>
<ul>
<li>
<p>Java1.8 以前的内存结构图：<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java7内存结构图.png" alt="" loading="lazy"></p>
</li>
<li>
<p>Java1.8 之后的内存结果图：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java8内存结构图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<p>线程运行诊断：</p>
<ul>
<li>定位：jps 定位进程 ID</li>
<li>jstack 进程 ID：用于打印出给定的 Java 进程 ID 或 core file 或远程调试服务的 Java 堆栈信息</li>
</ul>
<p>常见 OOM 错误：</p>
<ul>
<li>java.lang.StackOverflowError</li>
<li>java.lang.OutOfMemoryError：java heap space</li>
<li>java.lang.OutOfMemoryError：GC overhead limit exceeded</li>
<li>java.lang.OutOfMemoryError：Direct buffer memory</li>
<li>java.lang.OutOfMemoryError：unable to create new native thread</li>
<li>java.lang.OutOfMemoryError：Metaspace</li>
</ul>
<hr>
<h3> JVM内存</h3>
<h4> 虚拟机栈</h4>
<h5> Java 栈</h5>
<p>Java 虚拟机栈：Java Virtual Machine Stacks，<strong>每个线程</strong>运行时所需要的内存</p>
<ul>
<li>
<p>每个方法被执行时，都会在虚拟机栈中创建一个栈帧 stack frame（<strong>一个方法一个栈帧</strong>）</p>
</li>
<li>
<p>Java 虚拟机规范允许 <strong>Java 栈的大小是动态的或者是固定不变的</strong></p>
</li>
<li>
<p>虚拟机栈是<strong>每个线程私有的</strong>，每个线程只能有一个活动栈帧，对应方法调用到执行完成的整个过程</p>
</li>
<li>
<p>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存，每个栈帧中存储着：</p>
<ul>
<li>局部变量表：存储方法里的 Java 基本数据类型以及对象的引用</li>
<li>动态链接：也叫指向运行时常量池的方法引用</li>
<li>方法返回地址：方法正常退出或者异常退出的定义</li>
<li>操作数栈或表达式栈和其他一些附加信息</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-虚拟机栈.png" style="zoom:50%;">
</li>
</ul>
<p>设置栈内存大小：<code>-Xss size</code>   <code>-Xss 1024k</code></p>
<ul>
<li>在 JDK 1.4 中默认为 256K，而在 JDK 1.5+ 默认为 1M</li>
</ul>
<p>虚拟机栈特点：</p>
<ul>
<li>
<p>栈内存<strong>不需要进行GC</strong>，方法开始执行的时候会进栈，方法调用后自动弹栈，相当于清空了数据</p>
</li>
<li>
<p>栈内存分配越大越大，可用的线程数越少（内存越大，每个线程拥有的内存越大）</p>
</li>
<li>
<p>方法内的局部变量是否<strong>线程安全</strong>：</p>
<ul>
<li>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的（逃逸分析）</li>
<li>如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p>异常：</p>
<ul>
<li>栈帧过多导致栈内存溢出 （超过了栈的容量），会抛出 OutOfMemoryError 异常</li>
<li>当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常</li>
</ul>
<hr>
<h5> 局部变量</h5>
<p>局部变量表也被称之为局部变量数组或本地变量表，本质上定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</p>
<ul>
<li>表是建立在线程的栈上，是线程私有的数据，因此不存在数据安全问题</li>
<li>表的容量大小是在编译期确定的，保存在方法的 Code 属性的 maximum local variables 数据项中</li>
<li>表中的变量只在当前方法调用中有效，方法结束栈帧销毁，局部变量表也会随之销毁</li>
<li>表中的变量也是重要的垃圾回收根节点，只要被表中数据直接或间接引用的对象都不会被回收</li>
</ul>
<p>局部变量表最基本的存储单元是 <strong>slot（变量槽）</strong>：</p>
<ul>
<li>参数值的存放总是在局部变量数组的 index0 开始，到数组长度 -1 的索引结束，JVM 为每一个 slot 都分配一个访问索引，通过索引即可访问到槽中的数据</li>
<li>存放编译期可知的各种基本数据类型（8种），引用类型（reference），returnAddress 类型的变量</li>
<li>32 位以内的类型只占一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占两个 slot</li>
<li>局部变量表中的槽位是可以<strong>重复利用</strong>的，如果一个局部变量过了其作用域，那么之后申明的新的局部变量就可能会复用过期局部变量的槽位，从而达到节省资源的目的</li>
</ul>
<hr>
<h5> 操作数栈</h5>
<p>栈：可以使用数组或者链表来实现</p>
<p>操作数栈：在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）或出栈（pop）</p>
<ul>
<li>
<p>保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间，是执行引擎的一个工作区</p>
</li>
<li>
<p>Java 虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是操作数栈</p>
</li>
<li>
<p>如果被调用的方法带有返回值的话，其<strong>返回值将会被压入当前栈帧的操作数栈中</strong></p>
</li>
</ul>
<p>栈顶缓存技术 ToS（Top-of-Stack Cashing）：将栈顶元素全部缓存在 CPU 的寄存器中，以此降低对内存的读/写次数，提升执行的效率</p>
<p>基于栈式架构的虚拟机使用的零地址指令更加紧凑，完成一项操作需要使用很多入栈和出栈指令，所以需要更多的指令分派（instruction dispatch）次数和内存读/写次数，由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度，所以需要栈顶缓存技术</p>
<hr>
<h5> 动态链接</h5>
<p>动态链接是指向运行时常量池的方法引用，涉及到栈操作已经是类加载完成，这个阶段的解析是<strong>动态绑定</strong></p>
<ul>
<li>
<p>为了支持当前方法的代码能够实现动态链接，每一个栈帧内部都包含一个指向运行时常量池或该栈帧所属方法的引用</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-动态链接符号引用.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>在 Java 源文件被编译成的字节码文件中，所有的变量和方法引用都作为符号引用保存在 class 的常量池中</p>
<p>常量池的作用：提供一些符号和常量，便于指令的识别</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-动态链接运行时常量池.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<hr>
<h5> 返回地址</h5>
<p>Return Address：存放调用该方法的 PC 寄存器的值</p>
<p>方法的结束有两种方式：正常执行完成、出现未处理的异常，在方法退出后都返回到该方法被调用的位置</p>
<ul>
<li>正常：调用者的 PC 计数器的值作为返回地址，即调用该方法的指令的<strong>下一条指令的地址</strong></li>
<li>异常：返回地址是要通过异常表来确定</li>
</ul>
<p>正常完成出口：执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者</p>
<p>异常完成出口：方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，本方法的异常表中没有搜素到匹配的异常处理器，导致方法退出</p>
<p>两者区别：通过异常完成出口退出的不会给上层调用者产生任何的返回值</p>
<h5> 附加信息</h5>
<p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息，例如对程序调试提供支持的信息</p>
<hr>
<h4> 本地方法栈</h4>
<p>本地方法栈是为虚拟机执行本地方法时提供服务的</p>
<p>JNI：Java Native Interface，通过使用 Java 本地接口程序，可以确保代码在不同的平台上方便移植</p>
<ul>
<li>
<p>不需要进行 GC，与虚拟机栈类似，也是线程私有的，有 StackOverFlowError 和 OutOfMemoryError 异常</p>
</li>
<li>
<p>虚拟机栈执行的是 Java 方法，在 HotSpot JVM 中，直接将本地方法栈和虚拟机栈合二为一</p>
</li>
<li>
<p>本地方法一般是由其他语言编写，并且被编译为基于本机硬件和操作系统的程序</p>
</li>
<li>
<p>当某个线程调用一个本地方法时，就进入了不再受虚拟机限制的世界，和虚拟机拥有同样的权限</p>
<ul>
<li>本地方法可以通过本地方法接口来<strong>访问虚拟机内部的运行时数据区</strong></li>
<li>直接从本地内存的堆中分配任意数量的内存</li>
<li>可以直接使用本地处理器中的寄存器</li>
</ul>
</li>
</ul>
<p>原理：将本地的 C 函数（如 foo）编译到一个共享库（<a href="http://foo.so" target="_blank" rel="noopener noreferrer">foo.so</a>）中，当正在运行的 Java 程序调用 foo 时，Java 解释器利用 dlopen 接口动态链接和加载 <a href="http://foo.so" target="_blank" rel="noopener noreferrer">foo.so</a> 后再调用该函数</p>
<ul>
<li>dlopen 函数：Linux 系统加载和链接共享库</li>
<li>dlclose 函数：卸载共享库</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-本地方法栈.png" style="zoom:67%;">
<p>图片来源：<a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md" target="_blank" rel="noopener noreferrer">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java 虚拟机.md</a></p>
<hr>
<h4> 程序计数器</h4>
<p>Program Counter Register 程序计数器（寄存器）</p>
<p>作用：内部保存字节码的行号，用于记录正在执行的字节码指令地址（如果正在执行的是本地方法则为空）</p>
<p>原理：</p>
<ul>
<li>JVM 对于多线程是通过线程轮流切换并且分配线程执行时间，一个处理器只会处理执行一个线程</li>
<li>切换线程需要从程序计数器中来回去到当前的线程上一次执行的行号</li>
</ul>
<p>特点：</p>
<ul>
<li>是线程私有的</li>
<li><strong>不会存在内存溢出</strong>，是 JVM 规范中唯一一个不出现 OOM 的区域，所以这个空间不会进行 GC</li>
</ul>
<p>Java 反编译指令：<code>javap -v Test.class</code></p>
<p>#20：代表去 Constant pool 查看该地址的指令</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 堆</h4>
<p>Heap 堆：是 JVM 内存中最大的一块，由所有线程共享，由垃圾回收器管理的主要区域，堆中对象大部分都需要考虑线程安全的问题</p>
<p>存放哪些资源：</p>
<ul>
<li>对象实例：类初始化生成的对象，<strong>基本数据类型的数组也是对象实例</strong>，new 创建对象都使用堆内存</li>
<li>字符串常量池：
<ul>
<li>字符串常量池原本存放于方法区，JDK7 开始放置于堆中</li>
<li>字符串常量池<strong>存储的是 String 对象的直接引用或者对象</strong>，是一张 string table</li>
</ul>
</li>
<li>静态变量：静态变量是有 static 修饰的变量，JDK8 时从方法区迁移至堆中</li>
<li>线程分配缓冲区 Thread Local Allocation Buffer：线程私有但不影响堆的共性，可以提升对象分配的效率</li>
</ul>
<p>设置堆内存指令：<code>-Xmx Size</code></p>
<p>内存溢出：new 出对象，循环添加字符数据，当堆中没有内存空间可分配给实例，也无法再扩展时，就会抛出 OutOfMemoryError 异常</p>
<p>堆内存诊断工具：（控制台命令）</p>
<ol>
<li>jps：查看当前系统中有哪些 Java 进程</li>
<li>jmap：查看堆内存占用情况 <code>jhsdb jmap --heap --pid 进程id</code></li>
<li>jconsole：图形界面的，多功能的监测工具，可以连续监测</li>
</ol>
<p>在 Java7 中堆内会存在<strong>年轻代、老年代和方法区（永久代）</strong>：</p>
<ul>
<li>Young 区被划分为三部分，Eden 区和两个大小严格相同的 Survivor 区。Survivor 区某一时刻只有其中一个是被使用的，另外一个留做垃圾回收时复制对象。在 Eden 区变满的时候，GC 就会将存活的对象移到空闲的 Survivor 区间中，根据 JVM 的策略，在经过几次垃圾回收后，仍然存活于 Survivor 的对象将被移动到 Tenured 区间</li>
<li>Tenured 区主要保存生命周期长的对象，一般是一些老的对象，当一些对象在 Young 复制转移一定的次数以后，对象就会被转移到 Tenured 区</li>
<li>Perm 代主要保存 Class、ClassLoader、静态变量、常量、编译后的代码，在 Java7 中堆内方法区会受到 GC 的管理</li>
</ul>
<p>分代原因：不同对象的生命周期不同，70%-99% 的对象都是临时对象，优化 GC 性能</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 方法区</h4>
<p>方法区：是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、即时编译器编译后的代码等数据，虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是也叫 Non-Heap（非堆）</p>
<p>方法区是一个 JVM 规范，<strong>永久代与元空间都是其一种实现方式</strong></p>
<p>方法区的大小不必是固定的，可以动态扩展，加载的类太多，可能导致永久代内存溢出 (OutOfMemoryError)</p>
<p>方法区的 GC：针对常量池的回收及对类型的卸载，比较难实现</p>
<p>为了<strong>避免方法区出现 OOM</strong>，在 JDK8 中将堆内的方法区（永久代）移动到了本地内存上，重新开辟了一块空间，叫做元空间，元空间存储类的元信息，<strong>静态变量和字符串常量池等放入堆中</strong></p>
<p>类元信息：在类编译期间放入方法区，存放了类的基本信息，包括类的方法、参数、接口以及常量池表</p>
<p>常量池表（Constant Pool Table）是 Class 文件的一部分，存储了<strong>类在编译期间生成的字面量、符号引用</strong>，JVM 为每个已加载的类维护一个常量池</p>
<ul>
<li>字面量：基本数据类型、字符串类型常量、声明为 final 的常量值等</li>
<li>符号引用：类、字段、方法、接口等的符号引用</li>
</ul>
<p>运行时常量池是方法区的一部分</p>
<ul>
<li>常量池（编译器生成的字面量和符号引用）中的数据会在类加载的加载阶段放入运行时常量池</li>
<li>类在解析阶段将这些符号引用替换成直接引用</li>
<li>除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()</li>
</ul>
<hr>
<h3> 本地内存</h3>
<h4> 基本介绍</h4>
<p>虚拟机内存：Java 虚拟机在执行的时候会把管理的内存分配成不同的区域，受虚拟机内存大小的参数控制，当大小超过参数设置的大小时就会报 OOM</p>
<p>本地内存：又叫做<strong>堆外内存</strong>，线程共享的区域，本地内存这块区域是不会受到 JVM 的控制的，不会发生 GC；因此对于整个 Java 的执行效率是提升非常大，但是如果内存的占用超出物理内存的大小，同样也会报 OOM</p>
<p>本地内存概述图：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-内存图对比.png" style="zoom: 67%;">
<hr>
<h4> 元空间</h4>
<p>PermGen 被元空间代替，永久代的<strong>类信息、方法、常量池</strong>等都移动到元空间区</p>
<p>元空间与永久代区别：元空间不在虚拟机中，使用的本地内存，默认情况下，元空间的大小仅受本地内存限制</p>
<p>方法区内存溢出：</p>
<ul>
<li>
<p>JDK1.8 以前会导致永久代内存溢出：java.lang.OutOfMemoryError: PerGen space</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>JDK1.8 以后会导致元空间内存溢出：java.lang.OutOfMemoryError: Metaspace</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<p>元空间内存溢出演示：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 直接内存</h4>
<p>直接内存是 Java 堆外、直接向系统申请的内存区间，不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域</p>
<p>直接内存详解参考：NET → NIO → 直接内存</p>
<hr>
<h3> 变量位置</h3>
<p>变量的位置不取决于它是基本数据类型还是引用数据类型，取决于它的<strong>声明位置</strong></p>
<p>静态内部类和其他内部类：</p>
<ul>
<li>
<p><strong>一个 class 文件只能对应一个 public 类型的类</strong>，这个类可以有内部类，但不会生成新的 class 文件</p>
</li>
<li>
<p>静态内部类属于类本身，加载到方法区，其他内部类属于内部类的属性，加载到堆（待考证）</p>
</li>
</ul>
<p>类变量：</p>
<ul>
<li>类变量是用 static 修饰符修饰，定义在方法外的变量，随着 Java 进程产生和销毁</li>
<li>在 Java8 之前把静态变量存放于方法区，在 Java8 时存放在堆中的静态变量区</li>
</ul>
<p>实例变量：</p>
<ul>
<li>实例（成员）变量是定义在类中，没有 static 修饰的变量，随着类的实例产生和销毁，是类实例的一部分</li>
<li>在类初始化的时候，从运行时常量池取出直接引用或者值，<strong>与初始化的对象一起放入堆中</strong></li>
</ul>
<p>局部变量：</p>
<ul>
<li>局部变量是定义在类的方法中的变量</li>
<li>在所在方法被调用时<strong>放入虚拟机栈的栈帧</strong>中，方法执行结束后从虚拟机栈中弹出，</li>
</ul>
<p>类常量池、运行时常量池、字符串常量池有什么关系？有什么区别？</p>
<ul>
<li>类常量池与运行时常量池都存储在方法区，而字符串常量池在 Jdk7 时就已经从方法区迁移到了 Java 堆中</li>
<li>在类编译过程中，会把类元信息放到方法区，类元信息的其中一部分便是类常量池，主要存放字面量和符号引用，而字面量的一部分便是文本字符</li>
<li><strong>在类加载时将字面量和符号引用解析为直接引用存储在运行时常量池</strong></li>
<li>对于文本字符，会在解析时查找字符串常量池，查出这个文本字符对应的字符串对象的直接引用，将直接引用存储在运行时常量池</li>
</ul>
<p>什么是字面量？什么是符号引用？</p>
<ul>
<li>
<p>字面量：java 代码在编译过程中是无法构建引用的，字面量就是在编译时对于数据的一种表示</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>符号引用：在编译过程中并不知道每个类的地址，因为可能这个类还没有加载，如果在一个类中引用了另一个类，无法知道它的内存地址，只能用它的类名作为符号引用，在类加载完后用这个符号引用去获取内存地址</p>
</li>
</ul>
<hr>
<h2> 内存管理</h2>
<h3> 内存分配</h3>
<h4> 两种方式</h4>
<p>不分配内存的对象无法进行其他操作，JVM 为对象分配内存的过程：首先计算对象占用空间大小，接着在堆中划分一块内存给新对象</p>
<ul>
<li>如果内存规整，使用指针碰撞（Bump The Pointer）。所有用过的内存在一边，空闲的内存在另外一边，中间有一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离</li>
<li>如果内存不规整，虚拟机需要维护一个空闲列表（Free List）分配。已使用的内存和未使用的内存相互交错，虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容</li>
</ul>
<hr>
<h4> TLAB</h4>
<p>TLAB：Thread Local Allocation Buffer，为每个线程在堆内单独分配了一个缓冲区，多线程分配内存时，使用 TLAB 可以避免线程安全问题，同时还能够提升内存分配的吞吐量，这种内存分配方式叫做<strong>快速分配策略</strong></p>
<ul>
<li>栈上分配使用的是栈来进行对象内存的分配</li>
<li>TLAB 分配使用的是 Eden 区域进行内存分配，属于堆内存</li>
</ul>
<p>堆区是线程共享区域，任何线程都可以访问到堆区中的共享数据，由于对象实例的创建在 JVM 中非常频繁，因此在并发环境下为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度</p>
<p>问题：堆空间都是共享的么？ 不一定，因为还有 TLAB，在堆中划分出一块区域，为每个线程所独占</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-TLAB内存分配策略.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>JVM 是将 TLAB 作为内存分配的首选，但不是所有的对象实例都能够在 TLAB 中成功分配内存，一旦对象在 TLAB 空间分配内存失败时，JVM 就会通过<strong>使用加锁机制确保数据操作的原子性</strong>，从而直接在堆中分配内存</p>
<p>栈上分配优先于 TLAB 分配进行，逃逸分析中若可进行栈上分配优化，会优先进行对象栈上直接分配内存</p>
<p>参数设置：</p>
<ul>
<li>
<p><code>-XX:UseTLAB</code>：设置是否开启 TLAB 空间</p>
</li>
<li>
<p><code>-XX:TLABWasteTargetPercent</code>：设置 TLAB 空间所占用 Eden 空间的百分比大小，默认情况下 TLAB 空间的内存非常小，仅占有整个 Eden 空间的1%</p>
</li>
<li>
<p><code>-XX:TLABRefillWasteFraction</code>：指当 TLAB 空间不足，请求分配的对象内存大小超过此阈值时不会进行 TLAB 分配，直接进行堆内存分配，否则还是会优先进行 TLAB 分配</p>
</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-TLAB内存分配过程.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 逃逸分析</h4>
<p>即时编译（Just-in-time Compilation，JIT）是一种通过在运行时将字节码翻译为机器码，从而改善性能的技术，在 HotSpot 实现中有多种选择：C1、C2 和 C1+C2，分别对应 Client、Server 和分层编译</p>
<ul>
<li>C1 编译速度快，优化方式比较保守；C2 编译速度慢，优化方式比较激进</li>
<li>C1+C2 在开始阶段采用 C1 编译，当代码运行到一定热度之后采用 C2 重新编译</li>
</ul>
<p>逃逸分析并不是直接的优化手段，而是一个代码分析方式，通过动态分析对象的作用域，为优化手段如栈上分配、标量替换和同步消除等提供依据，发生逃逸行为的情况有两种：方法逃逸和线程逃逸</p>
<ul>
<li>方法逃逸：当一个对象在方法中定义之后，被外部方法引用
<ul>
<li>全局逃逸：一个对象的作用范围逃出了当前方法或者当前线程，比如对象是一个静态变量、全局变量赋值、已经发生逃逸的对象、作为当前方法的返回值</li>
<li>参数逃逸：一个对象被作为方法参数传递或者被参数引用</li>
</ul>
</li>
<li>线程逃逸：如类变量或实例变量，可能被其它线程访问到</li>
</ul>
<p>如果不存在逃逸行为，则可以对该对象进行如下优化：同步消除、标量替换和栈上分配</p>
<ul>
<li>
<p>同步消除</p>
<p>线程同步本身比较耗时，如果确定一个对象不会逃逸出线程，不被其它线程访问到，那对象的读写就不会存在竞争，则可以消除对该对象的<strong>同步锁</strong>，通过 <code>-XX:+EliminateLocks</code> 可以开启同步消除 ( - 号关闭)</p>
</li>
<li>
<p>标量替换</p>
<ul>
<li>
<p>标量替换：如果把一个对象拆散，将其成员变量恢复到基本类型来访问</p>
</li>
<li>
<p>标量 (scalar) ：不可分割的量，如基本数据类型和 reference 类型</p>
<p>聚合量 (Aggregate)：一个数据可以继续分解，对象一般是聚合量</p>
</li>
<li>
<p>如果逃逸分析发现一个对象不会被外部访问，并且该对象可以被拆散，那么经过优化之后，并不直接生成该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替</p>
</li>
<li>
<p>参数设置：</p>
<ul>
<li><code>-XX:+EliminateAllocations</code>：开启标量替换</li>
<li><code>-XX:+PrintEliminateAllocations</code>：查看标量替换情况</li>
</ul>
</li>
</ul>
</li>
<li>
<p>栈上分配</p>
<p>JIT 编译器在编译期间根据逃逸分析的结果，如果一个对象没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收，这样就无需 GC</p>
<p>User 对象的作用域局限在方法 fn 中，可以使用标量替换的优化手段在栈上分配对象的成员变量，这样就不会生成 User 对象，大大减轻 GC 的压力</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 分代思想</h4>
<h5> 分代介绍</h5>
<p>Java8 时，堆被分为了两份：新生代和老年代（1:2），在 Java7 时，还存在一个永久代</p>
<ul>
<li>新生代使用：复制算法</li>
<li>老年代使用：标记 - 清除 或者 标记 - 整理 算法</li>
</ul>
<p><strong>Minor GC 和 Full GC</strong>：</p>
<ul>
<li>Minor GC：回收新生代，新生代对象存活时间很短，所以 Minor GC 会频繁执行，执行的速度比较快</li>
<li>Full GC：回收老年代和新生代，老年代对象其存活时间长，所以 Full GC 很少执行，执行速度会比 Minor GC 慢很多</li>
</ul>
<p>Eden 和 Survivor 大小比例默认为 8:1:1</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-分代收集算法.png" style="zoom: 67%;">
<hr>
<h5> 分代分配</h5>
<p>工作机制：</p>
<ul>
<li><strong>对象优先在 Eden 分配</strong>：当创建一个对象的时候，对象会被分配在新生代的 Eden 区，当 Eden 区要满了时候，触发 YoungGC</li>
<li>当进行 YoungGC 后，此时在 Eden 区存活的对象被移动到 to 区，并且当前对象的年龄会加 1，清空 Eden 区</li>
<li>当再一次触发 YoungGC 的时候，会把 Eden 区中存活下来的对象和 to 中的对象，移动到 from 区中，这些对象的年龄会加 1，清空 Eden 区和 to 区</li>
<li>To 区永远是空 Survivor 区，From 区是有数据的，每次 MinorGC 后两个区域互换</li>
<li>From 区和 To 区 也可以叫做 S0 区和 S1 区</li>
</ul>
<p>晋升到老年代：</p>
<ul>
<li>
<p><strong>长期存活的对象进入老年代</strong>：为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中</p>
<p><code>-XX:MaxTenuringThreshold</code>：定义年龄的阈值，对象头中用 4 个 bit 存储，所以最大值是 15，默认也是 15</p>
</li>
<li>
<p><strong>大对象直接进入老年代</strong>：需要连续内存空间的对象，最典型的大对象是很长的字符串以及数组；避免在 Eden 和 Survivor 之间的大量复制；经常出现大对象会提前触发 GC 以获取足够的连续空间分配给大对象</p>
<p><code>-XX:PretenureSizeThreshold</code>：大于此值的对象直接在老年代分配</p>
</li>
<li>
<p><strong>动态对象年龄判定</strong>：如果在 Survivor 区中相同年龄的对象的所有大小之和超过 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代</p>
</li>
</ul>
<p>空间分配担保：</p>
<ul>
<li>在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的</li>
<li>如果不成立，虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于将尝试着进行一次 Minor GC；如果小于或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC</li>
</ul>
<hr>
<h3> 回收策略</h3>
<h4> 触发条件</h4>
<p>内存垃圾回收机制主要集中的区域就是线程共享区域：<strong>堆和方法区</strong></p>
<p>Minor GC 触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC</p>
<p>FullGC 同时回收新生代、老年代和方法区，只会存在一个 FullGC 的线程进行执行，其他的线程全部会被<strong>挂起</strong>，有以下触发条件：</p>
<ul>
<li>
<p>调用 System.gc()：</p>
<ul>
<li>在默认情况下，通过 System.gc() 或 Runtime.getRuntime().gc() 的调用，会显式触发 FullGC，同时对老年代和新生代进行回收，但是虚拟机不一定真正去执行，无法保证对垃圾收集器的调用</li>
<li>不建议使用这种方式，应该让虚拟机管理内存。一般情况下，垃圾回收应该是自动进行的，无须手动触发；在一些特殊情况下，如正在编写一个性能基准，可以在运行之间调用 System.gc()</li>
</ul>
</li>
<li>
<p>老年代空间不足：</p>
<ul>
<li>为了避免引起的 Full GC，应当尽量不要创建过大的对象以及数组</li>
<li>通过 -Xmn 参数调整新生代的大小，让对象尽量在新生代被回收掉不进入老年代，可以通过 <code>-XX:MaxTenuringThreshold</code> 调大对象进入老年代的年龄，让对象在新生代多存活一段时间</li>
</ul>
</li>
<li>
<p>空间分配担保失败</p>
</li>
<li>
<p>JDK 1.7 及以前的永久代（方法区）空间不足</p>
</li>
<li>
<p>Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC</p>
</li>
</ul>
<p>手动 GC 测试，VM参数：<code>-XX:+PrintGcDetails</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 安全区域</h4>
<p>安全点 (Safepoint)：程序执行时并非在所有地方都能停顿下来开始 GC，只有在安全点才能停下</p>
<ul>
<li>Safe Point 的选择很重要，如果太少可能导致 GC 等待的时间太长，如果太多可能导致运行时的性能问题</li>
<li>大部分指令的执行时间都非常短，通常会根据是否具有让程序长时间执行的特征为标准，选择些执行时间较长的指令作为 Safe Point， 如方法调用、循环跳转和异常跳转等</li>
</ul>
<p>在 GC 发生时，让所有线程都在最近的安全点停顿下来的方法：</p>
<ul>
<li>抢先式中断：没有虚拟机采用，首先中断所有线程，如果有线程不在安全点，就恢复线程让线程运行到安全点</li>
<li>主动式中断：设置一个中断标志，各个线程运行到各个 Safe Point 时就轮询这个标志，如果中断标志为真，则将自己进行中断挂起</li>
</ul>
<p>问题：Safepoint 保证程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint，但是当线程处于 Waiting 状态或 Blocked 状态，线程无法响应 JVM 的中断请求，运行到安全点去中断挂起，JVM 也不可能等待线程被唤醒，对于这种情况，需要安全区域来解决</p>
<p>安全区域 (Safe Region)：指在一段代码片段中，<strong>对象的引用关系不会发生变化</strong>，在这个区域中的任何位置开始 GC 都是安全的</p>
<p>运行流程：</p>
<ul>
<li>
<p>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Region，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程</p>
</li>
<li>
<p>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了则继续运行，否则线程必须等待 GC 完成，收到可以安全离开 SafeRegion 的信号</p>
</li>
</ul>
<hr>
<h3> 垃圾判断</h3>
<h4> 垃圾介绍</h4>
<p>垃圾：<strong>如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾</strong></p>
<p>作用：释放没用的对象，清除内存里的记录碎片，碎片整理将所占用的堆内存移到堆的一端，以便 JVM 将整理出的内存分配给新的对象</p>
<p>垃圾收集主要是针对堆和方法区进行，程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收</p>
<p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先需要区分出内存中哪些是存活对象，哪些是已经死亡的对象。只有被标记为己经死亡的对象，GC 才会在执行垃圾回收时，释放掉其所占用的内存空间，因此这个过程可以称为垃圾标记阶段，判断对象存活一般有两种方式：<strong>引用计数算法</strong>和<strong>可达性分析算法</strong></p>
<hr>
<h4> 引用计数法</h4>
<p>引用计数算法（Reference Counting）：对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1；当对象 A 的引用计数器的值为 0，即表示对象A不可能再被使用，可进行回收（Java 没有采用）</p>
<p>优点：</p>
<ul>
<li>回收没有延迟性，无需等到内存不够的时候才开始回收，运行时根据对象计数器是否为 0，可以直接回收</li>
<li>在垃圾回收过程中，应用无需挂起；如果申请内存时，内存不足，则立刻报 OOM 错误</li>
<li>区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象</li>
</ul>
<p>缺点：</p>
<ul>
<li>
<p>每次对象被引用时，都需要去更新计数器，有一点时间开销</p>
</li>
<li>
<p>浪费 CPU 资源，即使内存够用，仍然在运行时进行计数器的统计。</p>
</li>
<li>
<p><strong>无法解决循环引用问题，会引发内存泄露</strong>（最大的缺点）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-循环引用.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 可达性分析</h4>
<h5> GC Roots</h5>
<p>可达性分析算法：也可以称为根搜索算法、追踪性垃圾收集</p>
<p>GC Roots 对象：</p>
<ul>
<li>虚拟机栈中局部变量表中引用的对象：各个线程被调用的方法中使用到的参数、局部变量等</li>
<li>本地方法栈中引用的对象</li>
<li>堆中类静态属性引用的对象</li>
<li>方法区中的常量引用的对象</li>
<li>字符串常量池（string Table）里的引用</li>
<li>同步锁 synchronized 持有的对象</li>
</ul>
<p><strong>GC Roots 是一组活跃的引用，不是对象</strong>，放在 GC Roots Set 集合</p>
<hr>
<h5> 工作原理</h5>
<p>可达性分析算法以根对象集合（GCRoots）为起始点，从上至下的方式搜索被根对象集合所连接的目标对象</p>
<p>分析工作必须在一个保障<strong>一致性的快照</strong>中进行，否则结果的准确性无法保证，这也是导致 GC 进行时必须 Stop The World 的一个原因</p>
<p>基本原理：</p>
<ul>
<li>
<p>可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索走过的路径称为引用链</p>
</li>
<li>
<p>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象</p>
</li>
<li>
<p>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-可达性分析算法.png" style="zoom: 50%;">
</li>
</ul>
<hr>
<h5> 三色标记</h5>
<h6> 标记算法</h6>
<p>三色标记法把遍历对象图过程中遇到的对象，标记成以下三种颜色：</p>
<ul>
<li>白色：尚未访问过</li>
<li>灰色：本对象已访问过，但是本对象引用到的其他对象尚未全部访问</li>
<li>黑色：本对象已访问过，而且本对象引用到的其他对象也全部访问完成</li>
</ul>
<p>当 Stop The World (STW) 时，对象间的引用是不会发生变化的，可以轻松完成标记，遍历访问过程为：</p>
<ol>
<li>初始时，所有对象都在白色集合</li>
<li>将 GC Roots 直接引用到的对象挪到灰色集合</li>
<li>从灰色集合中获取对象：
<ul>
<li>将本对象引用到的其他对象全部挪到灰色集合中</li>
<li>将本对象挪到黑色集合里面</li>
</ul>
</li>
<li>重复步骤 3，直至灰色集合为空时结束</li>
<li>结束后，仍在白色集合的对象即为 GC Roots 不可达，可以进行回收</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法过程.gif" style="zoom: 67%;">
<p>参考文章：<a href="https://www.jianshu.com/p/12544c0ad5c1" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/12544c0ad5c1</a></p>
<hr>
<h6> 并发标记</h6>
<p>并发标记时，对象间的引用可能发生变化，多标和漏标的情况就有可能发生</p>
<p><strong>多标情况：<strong>当 E 变为灰色或黑色时，其他线程断开的 D 对 E 的引用，导致这部分对象仍会被标记为存活，本轮 GC 不会回收这部分内存，这部分本应该回收但是没有回收到的内存，被称之为</strong>浮动垃圾</strong></p>
<ul>
<li>针对并发标记开始后的<strong>新对象</strong>，通常的做法是直接全部当成黑色，也算浮动垃圾</li>
<li>浮动垃圾并不会影响应用程序的正确性，只是需要等到下一轮垃圾回收中才被清除</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法多标情况.png" style="zoom: 50%;">
<p><strong>漏标情况：</strong></p>
<ul>
<li>条件一：灰色对象断开了对一个白色对象的引用（直接或间接），即灰色对象原成员变量的引用发生了变化</li>
<li>条件二：其他线程中修改了黑色对象，插入了一条或多条对该白色对象的新引用</li>
<li>结果：导致该白色对象当作垃圾被 GC，影响到了程序的正确性</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-三色标记法漏标情况.png" style="zoom:50%;">
<p>代码角度解释漏标：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了解决问题，可以操作上面三步，<strong>将对象 G 记录起来，然后作为灰色对象再进行遍历</strong>，比如放到一个特定的集合，等初始的 GC Roots 遍历完（并发标记），再遍历该集合（重新标记）</p>
<blockquote>
<p>所以<strong>重新标记需要 STW</strong>，应用程序一直在运行，该集合可能会一直增加新的对象，导致永远都运行不完</p>
</blockquote>
<p>解决方法：添加读写屏障，读屏障拦截第一步，写屏障拦截第二三步，在读写前后进行一些后置处理：</p>
<ul>
<li>
<p><strong>写屏障 + 增量更新</strong>：黑色对象新增引用，会将黑色对象变成灰色对象，最后对该节点重新扫描</p>
<p>增量更新 (Incremental Update) 破坏了条件二，从而保证了不会漏标</p>
<p>缺点：对黑色变灰的对象重新扫描所有引用，比较耗费时间</p>
</li>
<li>
<p><strong>写屏障 (Store Barrier) + SATB</strong>：当原来成员变量的引用发生变化之前，记录下原来的引用对象</p>
<p>保留 GC 开始时的对象图，即原始快照 SATB，当 GC Roots 确定后，对象图就已经确定，那后续的标记也应该是按照这个时刻的对象图走，如果期间对白色对象有了新的引用会记录下来，并且将白色对象变灰（说明可达了，并且原始快照中本来就应该是灰色对象），最后重新扫描该对象的引用关系</p>
<p>SATB (Snapshot At The Beginning) 破坏了条件一，从而保证了不会漏标</p>
</li>
<li>
<p><strong>读屏障 (Load Barrier)</strong>：破坏条件二，黑色对象引用白色对象的前提是获取到该对象，此时读屏障发挥作用</p>
</li>
</ul>
<p>以 Java HotSpot VM 为例，其并发标记时对漏标的处理方案如下：</p>
<ul>
<li>CMS：写屏障 + 增量更新</li>
<li>G1：写屏障 + SATB</li>
<li>ZGC：读屏障</li>
</ul>
<hr>
<h4> finalization</h4>
<p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供对象被销毁之前的自定义处理逻辑</p>
<p>垃圾回收此对象之前，会先调用这个对象的 finalize() 方法，finalize() 方法允许在子类中被重写，用于在对象被回收时进行后置处理，通常在这个方法中进行一些资源释放和清理，比如关闭文件、套接字和数据库连接等</p>
<p>生存 OR 死亡：如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用，此对象需要被回收。但事实上这时候它们暂时处于缓刑阶段。<strong>一个无法触及的对象有可能在某个条件下复活自己</strong>，所以虚拟机中的对象可能的三种状态：</p>
<ul>
<li>可触及的：从根节点开始，可以到达这个对象</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 中复活</li>
<li>不可触及的：对象的 finalize() 被调用并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因为 <strong>finalize() 只会被调用一次</strong>，等到这个对象再被标记为可回收时就必须回收</li>
</ul>
<p>永远不要主动调用某个对象的 finalize() 方法，应该交给垃圾回收机制调用，原因：</p>
<ul>
<li>finalize() 时可能会导致对象复活</li>
<li>finalize() 方法的执行时间是没有保障的，完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize() 方法将没有执行机会，因为优先级比较低，即使主动调用该方法，也不会因此就直接进行回收</li>
<li>一个糟糕的 finalize() 会严重影响 GC 的性能</li>
</ul>
<hr>
<h4> 引用分析</h4>
<p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否可达，判定对象是否可被回收都与引用有关，Java 提供了四种强度不同的引用类型</p>
<ol>
<li>
<p>强引用：被强引用关联的对象不会被回收，只有所有 GCRoots 都不通过强引用引用该对象，才能被垃圾回收</p>
<ul>
<li>强引用可以直接访问目标对象</li>
<li>虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象</li>
<li>强引用可能导致<strong>内存泄漏</strong></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>软引用（SoftReference）：被软引用关联的对象只有在内存不够的情况下才会被回收</p>
<ul>
<li>**仅（可能有强引用，一个对象可以被多个引用）**有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象</li>
<li>配合<strong>引用队列来释放软引用自身</strong>，在构造软引用时，可以指定一个引用队列，当软引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况</li>
<li>软引用通常用来实现内存敏感的缓存，比如高速缓存就有用到软引用；如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时不会耗尽内存</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>弱引用（WeakReference）：被弱引用关联的对象一定会被回收，只能存活到下一次垃圾回收发生之前</p>
<ul>
<li>仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象</li>
<li>配合引用队列来释放弱引用自身</li>
<li>WeakHashMap 用来存储图片信息，可以在内存不足的时候及时回收，避免了 OOM</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>虚引用（PhantomReference）：也称为幽灵引用或者幻影引用，是所有引用类型中最弱的一个</p>
<ul>
<li>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象</li>
<li>为对象设置虚引用的唯一目的是在于跟踪垃圾回收过程，能在这个对象被回收时收到一个系统通知</li>
<li>必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>终结器引用（finalization）</p>
</li>
</ol>
<hr>
<h4> 无用属性</h4>
<h5> 无用类</h5>
<p>方法区主要回收的是无用的类</p>
<p>判定一个类是否是无用的类，需要同时满足下面 3 个条件：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的<strong>仅仅是可以</strong>，而并不是和对象一样不使用了就会必然被回收</p>
<hr>
<h5> 废弃常量</h5>
<p>在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该常量，说明常量 "abc" 是废弃常量，如果这时发生内存回收的话<strong>而且有必要的话</strong>（内存不够用），"abc" 就会被系统清理出常量池</p>
<hr>
<h5> 静态变量</h5>
<p>类加载时（第一次访问），这个类中所有静态成员就会被加载到静态变量区，该区域的成员一旦创建，直到程序退出才会被回收</p>
<p>如果是静态引用类型的变量，静态变量区只存储一份对象的引用地址，真正的对象在堆内，如果要回收该对象可以设置引用为 null</p>
<p>参考文章：<a href="https://blog.csdn.net/zhengzhb/article/details/7331354" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/zhengzhb/article/details/7331354</a></p>
<hr>
<h3> 回收算法</h3>
<h4> 复制算法</h4>
<p>复制算法的核心就是，<strong>将原有的内存空间一分为二，每次只用其中的一块</strong>，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清理，交换两个内存的角色，完成垃圾的回收</p>
<p>应用场景：如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之则不适合</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-复制算法.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>算法优点：</p>
<ul>
<li>没有标记和清除过程，实现简单，运行速度快</li>
<li>复制过去以后保证空间的连续性，不会出现碎片问题</li>
</ul>
<p>算法缺点：</p>
<ul>
<li>主要不足是<strong>只使用了内存的一半</strong></li>
<li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销都不小</li>
</ul>
<p>现在的商业虚拟机都采用这种收集算法<strong>回收新生代</strong>，因为新生代 GC 频繁并且对象的存活率不高，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间</p>
<hr>
<h4> 标记清除</h4>
<p>标记清除算法，是将垃圾回收分为两个阶段，分别是<strong>标记和清除</strong></p>
<ul>
<li>
<p><strong>标记</strong>：Collector 从引用根节点开始遍历，标记所有被引用的对象，一般是在对象的 Header 中记录为可达对象，<strong>标记的是引用的对象，不是垃圾</strong></p>
</li>
<li>
<p><strong>清除</strong>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收，把分块连接到<strong>空闲列表</strong>的单向链表，判断回收后的分块与前一个空闲分块是否连续，若连续会合并这两个分块，之后进行分配时只需要遍历这个空闲列表，就可以找到分块</p>
</li>
<li>
<p><strong>分配阶段</strong>：程序会搜索空闲链表寻找空间大于等于新对象大小 size 的块 block，如果找到的块等于 size，会直接返回这个分块；如果找到的块大于 size，会将块分割成大小为 size 与 block - size 的两部分，返回大小为 size 的分块，并把大小为 block - size 的块返回给空闲列表</p>
</li>
</ul>
<p>算法缺点：</p>
<ul>
<li>标记和清除过程效率都不高</li>
<li>会产生大量不连续的内存碎片，导致无法给大对象分配内存，需要维护一个空闲链表</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-标记清除算法.png" style="zoom: 67%;">
<hr>
<h4> 标记整理</h4>
<p>标记整理（压缩）算法是在标记清除算法的基础之上，做了优化改进的算法</p>
<p>标记阶段和标记清除算法一样，也是从根节点开始，对对象的引用进行标记，在清理阶段，并不是简单的直接清理可回收对象，而是<strong>将存活对象都向内存另一端移动</strong>，然后清理边界以外的垃圾，从而<strong>解决了碎片化</strong>的问题</p>
<p>优点：不会产生内存碎片</p>
<p>缺点：需要移动大量对象，处理效率比较低</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-标记整理算法.png" style="zoom:67%;">
<table>
<thead>
<tr>
<th></th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
<th>Copying</th>
</tr>
</thead>
<tbody>
<tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的 2 倍大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<hr>
<h3> 垃圾回收器</h3>
<h4> 概述</h4>
<p>垃圾收集器分类：</p>
<ul>
<li>按线程数分（垃圾回收线程数），可以分为串行垃圾回收器和并行垃圾回收器
<ul>
<li>除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行</li>
</ul>
</li>
<li>按照工作模式分，可以分为并发式垃圾回收器和独占式垃圾回收器
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间</li>
<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束</li>
</ul>
</li>
<li>按碎片处理方式分，可分为压缩式垃圾回收器和非压缩式垃圾回收器
<ul>
<li>压缩式垃圾回收器在回收完成后进行压缩整理，消除回收后的碎片，再分配对象空间使用指针碰撞</li>
<li>非压缩式的垃圾回收器不进行这步操作，再分配对象空间使用空闲列表</li>
</ul>
</li>
<li>按工作的内存区间分，又可分为年轻代垃圾回收器和老年代垃圾回收器</li>
</ul>
<p>GC 性能指标：</p>
<ul>
<li><strong>吞吐量</strong>：程序的运行时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li>
<li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率</li>
<li>内存占用：Java 堆区所占的内存大小</li>
<li>快速：一个对象从诞生到被回收所经历的时间</li>
</ul>
<p><strong>垃圾收集器的组合关系</strong>：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-垃圾回收器关系图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>新生代收集器：Serial、ParNew、Parallel Scavenge</p>
<p>老年代收集器：Serial old、Parallel old、CMS</p>
<p>整堆收集器：G1</p>
<ul>
<li>红色虚线在 JDK9 移除、绿色虚线在 JDK14 弃用该组合、青色虚线在 JDK14 删除 CMS 垃圾回收器</li>
</ul>
<p>查看默认的垃圾收回收器：</p>
<ul>
<li>
<p><code>-XX:+PrintcommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p>
</li>
<li>
<p>使用命令行指令：jinfo -flag 相关垃圾回收器参数  进程 ID</p>
</li>
</ul>
<hr>
<h4> Serial</h4>
<p>Serial：串行垃圾收集器，作用于新生代，是指使用单线程进行垃圾回收，采用<strong>复制算法</strong>，新生代基本都是复制算法</p>
<p><strong>STW（Stop-The-World）</strong>：垃圾回收时，只有一个线程在工作，并且 Java 应用中的所有线程都要暂停，等待垃圾回收的完成</p>
<p><strong>Serial old</strong>：执行老年代垃圾回收的串行收集器，内存回收算法使用的是<strong>标记-整理算法</strong>，同样也采用了串行回收和 STW 机制</p>
<ul>
<li>Serial old 是 Client 模式下默认的老年代的垃圾回收器</li>
<li>Serial old 在 Server 模式下主要有两个用途：
<ul>
<li>在 JDK 1.5 以及之前版本（Parallel Old 诞生以前）中与 Parallel Scavenge 收集器搭配使用</li>
<li>作为老年代 CMS 收集器的<strong>后备垃圾回收方案</strong>，在并发收集发生 Concurrent Mode Failure 时使用</li>
</ul>
</li>
</ul>
<p>开启参数：<code>-XX:+UseSerialGC</code> 等价于新生代用 Serial GC 且老年代用 Serial old GC</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Serial收集器.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>优点：简单而高效（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，可以获得最高的单线程收集效率</p>
<p>缺点：对于交互性较强的应用而言，这种垃圾收集器是不能够接受的，比如 JavaWeb 应用</p>
<hr>
<h4> ParNew</h4>
<p>Par 是 Parallel 并行的缩写，New 是只能处理的是新生代</p>
<p>并行垃圾收集器在串行垃圾收集器的基础之上做了改进，<strong>采用复制算法</strong>，将单线程改为了多线程进行垃圾回收，可以缩短垃圾回收的时间</p>
<p>对于其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同 Serial 收集器一样，应用在年轻代，除 Serial 外，只有<strong>ParNew GC 能与 CMS 收集器配合工作</strong></p>
<p>相关参数：</p>
<ul>
<li>
<p><code>-XX：+UseParNewGC</code>：表示年轻代使用并行收集器，不影响老年代</p>
</li>
<li>
<p><code>-XX:ParallelGCThreads</code>：默认开启和 CPU 数量相同的线程数</p>
</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-ParNew收集器.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器</p>
<ul>
<li>对于新生代，回收次数频繁，使用并行方式高效</li>
<li>对于老年代，回收次数少，使用串行方式节省资源（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<hr>
<h4> Parallel</h4>
<p>Parallel Scavenge 收集器是应用于新生代的并行垃圾回收器，<strong>采用复制算法</strong>、并行回收和 Stop the World 机制</p>
<p>Parallel Old 收集器：是一个应用于老年代的并行垃圾回收器，<strong>采用标记-整理算法</strong></p>
<p>对比其他回收器：</p>
<ul>
<li>其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间</li>
<li>Parallel 目标是达到一个可控制的吞吐量，被称为<strong>吞吐量优先</strong>收集器</li>
<li>Parallel Scavenge 对比 ParNew 拥有<strong>自适应调节策略</strong>，可以通过一个开关参数打开 GC Ergonomics</li>
</ul>
<p>应用场景：</p>
<ul>
<li>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验</li>
<li>高吞吐量可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互</li>
</ul>
<p>停顿时间和吞吐量的关系：新生代空间变小 → 缩短停顿时间 → 垃圾回收变得频繁 → 导致吞吐量下降</p>
<p>在注重吞吐量及 CPU 资源敏感的场合，都可以优先考虑 Parallel Scavenge + Parallel Old 收集器，在 Server 模式下的内存回收性能很好，<strong>Java8 默认是此垃圾收集器组合</strong></p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-ParallelScavenge收集器.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>参数配置：</p>
<ul>
<li><code>-XX：+UseParallelGC</code>：手动指定年轻代使用 Paralle 并行收集器执行内存回收任务</li>
<li><code>-XX：+UseParalleloldcc</code>：手动指定老年代使用并行回收收集器执行内存回收任务
<ul>
<li>上面两个参数，默认开启一个，另一个也会被开启（互相激活），默认 JDK8 是开启的</li>
</ul>
</li>
<li><code>-XX:+UseAdaptivesizepplicy</code>：设置 Parallel Scavenge 收集器具有<strong>自适应调节策略</strong>，在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</li>
<li><code>-XX:ParallelGcrhreads</code>：设置年轻代并行收集器的线程数，一般与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能
<ul>
<li>在默认情况下，当 CPU 数量小于 8 个，ParallelGcThreads 的值等于 CPU 数量</li>
<li>当 CPU 数量大于 8 个，ParallelGCThreads 的值等于 3+[5*CPU Count]/8]</li>
</ul>
</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置垃圾收集器最大停顿时间（即 STW 的时间），单位是毫秒
<ul>
<li>对于用户来讲，停顿时间越短体验越好；在服务器端，注重高并发，整体的吞吐量</li>
<li>为了把停顿时间控制在 MaxGCPauseMillis 以内，收集器在工作时会调整 Java 堆大小或其他一些参数</li>
</ul>
</li>
<li><code>-XX:GCTimeRatio</code>：垃圾收集时间占总时间的比例 =1/(N+1)，用于衡量吞吐量的大小
<ul>
<li>取值范围（0，100）。默认值 99，也就是垃圾回收时间不超过 1</li>
<li>与 <code>-xx:MaxGCPauseMillis</code> 参数有一定矛盾性，暂停时间越长，Radio 参数就容易超过设定的比例</li>
</ul>
</li>
</ul>
<hr>
<h4> CMS</h4>
<p>CMS 全称 Concurrent Mark Sweep，是一款<strong>并发的、使用标记-清除</strong>算法、针对老年代的垃圾回收器，其最大特点是<strong>让垃圾收集线程与用户线程同时工作</strong></p>
<p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，停顿时间越短（<strong>低延迟</strong>）越适合与用户交互的程序，良好的响应速度能提升用户体验</p>
<p>分为以下四个流程：</p>
<ul>
<li>初始标记：使用 STW 出现短暂停顿，仅标记一下 GC Roots 能直接关联到的对象，速度很快</li>
<li>并发标记：进行 GC Roots 开始遍历整个对象图，在整个回收过程中耗时最长，不需要 STW，可以与用户线程并发运行</li>
<li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象，比初始标记时间长但远比并发标记时间短，需要 STW（不停顿就会一直变化，采用写屏障 + 增量更新来避免漏标情况）</li>
<li>并发清除：清除标记为可以回收对象，<strong>不需要移动存活对象</strong>，所以这个阶段可以与用户线程同时并发的</li>
</ul>
<p>Mark Sweep 会造成内存碎片，不把算法换成 Mark Compact 的原因：Mark Compact 算法会整理内存，导致用户线程使用的<strong>对象的地址改变</strong>，影响用户线程继续执行</p>
<p>在整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，不需要进行停顿</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-CMS收集器.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>优点：并发收集、低延迟</p>
<p>缺点：</p>
<ul>
<li>
<p>吞吐量降低：在并发阶段虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，CPU 利用率不够高</p>
</li>
<li>
<p>CMS 收集器<strong>无法处理浮动垃圾</strong>，可能出现 Concurrent Mode Failure 导致另一次 Full GC 的产生</p>
<p>浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾（产生了新对象），这部分垃圾只能到下一次 GC 时才能进行回收。由于浮动垃圾的存在，CMS 收集需要预留出一部分内存，不能等待老年代快满的时候再回收。如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS，导致很长的停顿时间</p>
</li>
<li>
<p>标记 - 清除算法导致的空间碎片，往往出现老年代空间无法找到足够大连续空间来分配当前对象，不得不提前触发一次 Full GC；为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配</p>
</li>
</ul>
<p>参数设置：</p>
<ul>
<li>
<p><code>-XX：+UseConcMarkSweepGC</code>：手动指定使用 CMS 收集器执行内存回收任务</p>
<p>开启该参数后会自动将 <code>-XX:+UseParNewGC</code> 打开，即：ParNew + CMS + Serial old的组合</p>
</li>
<li>
<p><code>-XX:CMSInitiatingoccupanyFraction</code>：设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收</p>
<ul>
<li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68% 时，会执行一次CMS回收</li>
<li>JDK6 及以上版本默认值为 92%</li>
</ul>
</li>
<li>
<p><code>-XX:+UseCMSCompactAtFullCollection</code>：用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生，由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长</p>
</li>
<li>
<p><code>-XX:CMSFullGCsBeforecompaction</code>：<strong>设置在执行多少次 Full GC 后对内存空间进行压缩整理</strong></p>
</li>
<li>
<p><code>-XX:ParallelCMSThreads</code>：设置 CMS 的线程数量</p>
<ul>
<li>CMS 默认启动的线程数是 (ParallelGCThreads+3)/4，ParallelGCThreads 是年轻代并行收集器的线程数</li>
<li>收集线程占用的 CPU 资源多于25%，对用户程序影响可能较大；当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕</li>
</ul>
</li>
</ul>
<hr>
<h4> G1</h4>
<h5> G1 特点</h5>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>应用于新生代和老年代</strong>、采用标记-整理算法、软实时、低延迟、可设定目标（最大 STW 停顿时间）的垃圾回收器，用于代替 CMS，适用于较大的堆（&gt;4 ~ 6G），在 JDK9 之后默认使用 G1</p>
<p>G1 对比其他处理器的优点：</p>
<ul>
<li>
<p>并发与并行：</p>
<ul>
<li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力，此时用户线程 STW</li>
<li>并发性：G1 拥有与应用程序交替执行的能力，部分工作可以和应用程序同时执行，因此不会在整个回收阶段发生完全阻塞应用程序的情况</li>
<li>其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，JVM 的 GC 线程处理速度慢时，系统会<strong>调用应用程序线程加速垃圾回收</strong>过程</li>
</ul>
</li>
<li>
<p><strong>分区算法</strong>：</p>
<ul>
<li>
<p>从分代上看，G1  属于分代型垃圾回收器，区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。从堆结构上看，<strong>新生代和老年代不再物理隔离</strong>，不用担心每个代内存是否足够，这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC</p>
</li>
<li>
<p>将整个堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32 MB之间且为 2 的 N 次幂，所有 Region 大小相同，在 JVM 生命周期内不会被改变。G1 把堆划分成多个大小相等的独立区域，使得每个小空间可以单独进行垃圾回收</p>
</li>
<li>
<p><strong>新的区域 Humongous</strong>：本身属于老年代区，当出现了一个巨型对象超出了分区容量的一半，该对象就会进入到该区域。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储，为了能找到连续的 H 区，有时候不得不启动 Full GC</p>
</li>
<li>
<p>G1 不会对巨型对象进行拷贝，回收时被优先考虑，G1 会跟踪老年代所有 incoming 引用，这样老年代 incoming 引用为 0 的巨型对象就可以在新生代垃圾回收时处理掉</p>
</li>
<li>
<p>Region 结构图：</p>
</li>
</ul>
</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1-Region区域.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>空间整合：</p>
<ul>
<li>CMS：标记-清除算法、内存碎片、若干次 GC 后进行一次碎片整理</li>
<li>G1：整体来看是<strong>基于标记 - 整理算法实现</strong>的收集器，从局部（Region 之间）上来看是基于复制算法实现的，两种算法都可以避免内存碎片</li>
</ul>
</li>
<li>
<p><strong>可预测的停顿时间模型（软实时 soft real-time）</strong>：可以指定在 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒</p>
<ul>
<li>由于分块的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，对于全局停顿情况也能得到较好的控制</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间，通过过去回收的经验获得），在后台维护一个<strong>优先列表</strong>，每次根据允许的收集时间优先回收价值最大的 Region，保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率</li>
</ul>
<ul>
<li>相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多</li>
</ul>
</li>
</ul>
<p>G1 垃圾收集器的缺点：</p>
<ul>
<li>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比 CMS 要高</li>
<li>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势，平衡点在 6-8GB 之间</li>
</ul>
<p>应用场景：</p>
<ul>
<li>面向服务端应用，针对具有大内存、多处理器的机器</li>
<li>需要低 GC 延迟，并具有大堆的应用程序提供解决方案</li>
</ul>
<hr>
<h5> 记忆集</h5>
<p>记忆集 Remembered Set 在新生代中，每个 Region 都有一个 Remembered Set，用来被哪些其他 Region 里的对象引用（谁引用了我就记录谁）</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JUC-G1记忆集.png" style="zoom:67%;">
<ul>
<li>程序对 Reference 类型数据写操作时，产生一个 Write Barrier 暂时中断操作，检查该对象和 Reference 类型数据是否在不同的 Region（跨代引用），不同就将相关引用信息记录到 Reference 类型所属的 Region 的 Remembered Set 之中</li>
<li>进行内存回收时，在 GC 根节点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏</li>
</ul>
<p>垃圾收集器在新生代中建立了记忆集这样的数据结构，可以理解为它是一个抽象类，具体实现记忆集的三种方式：</p>
<ul>
<li>字长精度</li>
<li>对象精度</li>
<li>卡精度(卡表)</li>
</ul>
<p>卡表（Card Table）在老年代中，是一种对记忆集的具体实现，主要定义了记忆集的记录精度、与堆内存的映射关系等，卡表中的每一个元素都对应着一块特定大小的内存块，这个内存块称之为卡页（card page），当存在跨代引用时，会将卡页标记为 dirty，JVM 对于卡页的维护也是通过写屏障的方式</p>
<p>收集集合 CSet 代表每次 GC 暂停时回收的一系列目标分区，在任意一次收集暂停中，CSet 所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。年轻代收集 CSet 只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到 CSet 中</p>
<ul>
<li>CSet of Young Collection</li>
<li>CSet of Mix Collection</li>
</ul>
<hr>
<h5> 工作原理</h5>
<p>G1 中提供了三种垃圾回收模式：YoungGC、Mixed GC 和 Full GC，在不同的条件下被触发</p>
<ul>
<li>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程</li>
<li>标记完成马上开始混合回收过程</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1回收过程.png" style="zoom: 50%;">
<p>顺时针：Young GC → Young GC + Concurrent Mark → Mixed GC 顺序，进行垃圾回收</p>
<ul>
<li>
<p><strong>Young GC</strong>：发生在年轻代的 GC 算法，一般对象（除了巨型对象）都是在 eden region 中分配内存，当所有 eden region 被耗尽无法申请内存时，就会触发一次 Young GC，G1 停止应用程序的执行 STW，把活跃对象放入老年代，垃圾对象回收</p>
<p><strong>回收过程</strong>：</p>
<ol>
<li>扫描根：根引用连同 RSet 记录的外部引用作为扫描存活对象的入口</li>
<li>更新 RSet：处理 dirty card queue 更新 RS，此后 RSet 准确的反映对象的引用关系
<ul>
<li>dirty card queue：类似缓存，产生了引用先记录在这里，然后更新到 RSet</li>
<li>作用：产生引用直接更新 RSet 需要线程同步开销很大，使用队列性能好</li>
</ul>
</li>
<li>处理 RSet：识别被老年代对象指向的 Eden 中的对象，这些被指向的对象被认为是存活的对象，把需要回收的分区放入 Young CSet 中进行回收</li>
<li>复制对象：Eden 区内存段中存活的对象会被复制到 survivor 区，survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加1，达到阀值会被会被复制到 old 区中空的内存分段，如果 survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间</li>
<li>处理引用：处理 Soft，Weak，Phantom，JNI Weak  等引用，最终 Eden 空间的数据为空，GC 停止工作</li>
</ol>
</li>
<li>
<p>**Concurrent Mark **：</p>
<ul>
<li>初始标记：标记从根节点直接可达的对象，这个阶段是 STW 的，并且会触发一次年轻代 GC</li>
<li>并发标记 (Concurrent Marking)：在整个堆中进行并发标记（应用程序并发执行），可能被 YoungGC 中断。会计算每个区域的对象活性，即区域中存活对象的比例，若区域中的所有对象都是垃圾，则这个区域会被立即回收（<strong>实时回收</strong>），给浮动垃圾准备出更多的空间，把需要收集的 Region 放入 CSet 当中</li>
<li>最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中，这阶段需要停顿线程，但是可并行执行（<strong>防止漏标</strong>）</li>
<li>筛选回收：并发清理阶段，首先对 CSet 中各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划，也需要 STW</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-G1收集器.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p><strong>Mixed GC</strong>：当很多对象晋升到老年代时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，除了回收整个 young region，还会回收一部分的 old region，过程同 YGC</p>
<p>注意：<strong>是一部分老年代，而不是全部老年代</strong>，可以选择哪些老年代 region 收集，对垃圾回收的时间进行控制</p>
<p>在 G1 中，Mixed GC 可以通过 <code>-XX:InitiatingHeapOccupancyPercent</code> 设置阈值</p>
</li>
<li>
<p><strong>Full GC</strong>：对象内存分配速度过快，Mixed GC 来不及回收，导致老年代被填满，就会触发一次 Full GC，G1 的 Full GC 算法就是单线程执行的垃圾回收，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免 Full GC</p>
<p>产生 Full GC 的原因：</p>
<ul>
<li>晋升时没有足够的空间存放晋升的对象</li>
<li>并发处理过程完成之前空间耗尽，浮动垃圾</li>
</ul>
</li>
</ul>
<hr>
<h5> 相关参数</h5>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li>
<li><code>-XX:G1HeapRegionSize</code>：设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域，默认是堆内存的 1/2000</li>
<li><code>-XX:MaxGCPauseMillis</code>：设置期望达到的最大 GC 停顿时间指标，JVM会尽力实现，但不保证达到，默认值是 200ms</li>
<li><code>-XX:+ParallelGcThread</code>：设置 STW 时 GC 线程数的值，最多设置为 8</li>
<li><code>-XX:ConcGCThreads</code>：设置并发标记线程数，设置为并行垃圾回收线程数 ParallelGcThreads 的1/4左右</li>
<li><code>-XX:InitiatingHeapoccupancyPercent</code>：设置触发并发 Mixed GC 周期的 Java 堆占用率阈值，超过此值，就触发 GC，默认值是 45</li>
<li><code>-XX:+ClassUnloadingWithConcurrentMark</code>：并发标记类卸载，默认启用，所有对象都经过并发标记后，就可以知道哪些类不再被使用，当一个类加载器的所有类都不再使用，则卸载它所加载的所有类</li>
<li><code>-XX:G1NewSizePercent</code>：新生代占用整个堆内存的最小百分比（默认5％）</li>
<li><code>-XX:G1MaxNewSizePercent</code>：新生代占用整个堆内存的最大百分比（默认60％）</li>
<li><code>-XX:G1ReservePercent=10</code>：保留内存区域，防止 to space（Survivor中的 to 区）溢出</li>
</ul>
<hr>
<h5> 调优</h5>
<p>G1 的设计原则就是简化 JVM 性能调优，只需要简单的三步即可完成调优：</p>
<ol>
<li>开启 G1 垃圾收集器</li>
<li>设置堆的最大内存</li>
<li>设置最大的停顿时间（STW）</li>
</ol>
<p>不断调优暂停时间指标：</p>
<ul>
<li><code>XX:MaxGCPauseMillis=x</code> 可以设置启动应用程序暂停的时间，G1会根据这个参数选择 CSet 来满足响应时间的设置</li>
<li>设置到 100ms 或者 200ms 都可以（不同情况下会不一样），但设置成50ms就不太合理</li>
<li>暂停时间设置的太短，就会导致出现 G1 跟不上垃圾产生的速度，最终退化成 Full GC</li>
<li>对这个参数的调优是一个持续的过程，逐步调整到最佳状态</li>
</ul>
<p>不要设置新生代和老年代的大小：</p>
<ul>
<li>避免使用 -Xmn 或 -XX:NewRatio 等相关选项显式设置年轻代大小，G1 收集器在运行的时候会调整新生代和老年代的大小，从而达到我们为收集器设置的暂停时间目标</li>
<li>设置了新生代大小相当于放弃了 G1 的自动调优，我们只需要设置整个堆内存的大小，剩下的交给 G1 自己去分配各个代的大小</li>
</ul>
<hr>
<h4> ZGC</h4>
<p>ZGC 收集器是一个可伸缩的、低延迟的垃圾收集器，基于 Region 内存布局的，不设分代，使用了读屏障、染色指针和内存多重映射等技术来实现<strong>可并发的标记压缩算法</strong></p>
<ul>
<li>在 CMS 和 G1 中都用到了写屏障，而 ZGC 用到了读屏障</li>
<li>染色指针：直接<strong>将少量额外的信息存储在指针上的技术</strong>，从 64 位的指针中拿高 4 位来标识对象此时的状态
<ul>
<li>染色指针可以使某个 Region 的存活对象被移走之后，这个 Region 立即就能够被释放和重用</li>
<li>可以直接从指针中看到引用对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集、是否被移动过（Remapped）、是否只能通过 finalize() 方法才能被访问到（Finalizable）</li>
<li>可以大幅减少在垃圾收集过程中内存屏障的使用数量，写屏障的目的通常是为了记录对象引用的变动情况，如果将这些信息直接维护在指针中，显然就可以省去一些专门的记录操作</li>
<li>可以作为一种可扩展的存储结构用来记录更多与对象标记、重定位过程相关的数据</li>
</ul>
</li>
<li>内存多重映射：多个虚拟地址指向同一个物理地址</li>
</ul>
<p>可并发的标记压缩算法：染色指针标识对象是否被标记或移动，读屏障保证在每次应用程序或 GC 程序访问对象时先根据染色指针的标识判断是否被移动，如果被移动就根据转发表访问新的移动对象，<strong>并更新引用</strong>，不会像 G1 一样必须等待垃圾回收完成才能访问</p>
<p>ZGC 目标：</p>
<ul>
<li>停顿时间不会超过 10ms</li>
<li>停顿时间不会随着堆的增大而增大（不管多大的堆都能保持在 10ms 以下）</li>
<li>可支持几百 M，甚至几 T 的堆大小（最大支持4T）</li>
</ul>
<p>ZGC 的工作过程可以分为 4 个阶段：</p>
<ul>
<li>并发标记（Concurrent Mark）： 遍历对象图做可达性分析的阶段，也要经过初始标记和最终标记，需要短暂停顿</li>
<li>并发预备重分配（Concurrent Prepare for Relocate）：根据特定的查询条件统计得出本次收集过程要清理哪些 Region，将这些 Region 组成重分配集（Relocation Set）</li>
<li>并发重分配（Concurrent Relocate）： 重分配是 ZGC 执行过程中的核心阶段，这个过程要把重分配集中的存活对象复制到新的 Region 上，并为重分配集中的<strong>每个 Region 维护一个转发表</strong>（Forward Table），记录从旧地址到新地址的转向关系</li>
<li>并发重映射（Concurrent Remap）：修正整个堆中指向重分配集中旧对象的所有引用，ZGC 的并发映射并不是一个必须要立即完成的任务，ZGC 很巧妙地把并发重映射阶段要做的工作，合并到下一次垃圾收集循环中的并发标记阶段里去完成，因为都是要遍历所有对象，这样合并节省了一次遍历的开销</li>
</ul>
<p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STW 的，但这部分的实际时间是非常少的，所以响应速度快，在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟</p>
<p>优点：高吞吐量、低延迟</p>
<p>缺点：浮动垃圾，当 ZGC 准备要对一个很大的堆做一次完整的并发收集，其全过程要持续十分钟以上，由于应用的对象分配速率很高，将创造大量的新对象产生浮动垃圾</p>
<p>参考文章：<a href="https://www.cnblogs.com/jimoer/p/13170249.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/jimoer/p/13170249.html</a></p>
<hr>
<h4> 总结</h4>
<p>Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 GC  不同：</p>
<ul>
<li>最小化地使用内存和并行开销，选 Serial GC</li>
<li>最大化应用程序的吞吐量，选 Parallel GC</li>
<li>最小化 GC 的中断或停顿时间，选 CMS GC</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-垃圾回收器总结.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 内存泄漏</h3>
<h4> 泄露溢出</h4>
<p>内存泄漏（Memory Leak）：是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果</p>
<p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。由于代码的实现不同就会出现很多种内存泄漏问题，让 JVM 误以为此对象还在引用中，无法回收，造成内存泄漏</p>
<p>内存溢出（out of memory）指的是申请内存时，没有足够的内存可以使用</p>
<p>内存泄漏和内存溢出的关系：内存泄漏的越来越多，最终会导致内存溢出</p>
<hr>
<h4> 几种情况</h4>
<h5> 静态集合</h5>
<p>静态集合类的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。原因是<strong>长生命周期的对象持有短生命周期对象的引用</strong>，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 单例模式</h5>
<p>单例模式和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏</p>
<hr>
<h5> 内部类</h5>
<p>内部类持有外部类的情况，如果一个外部类的实例对象调用方法返回了一个内部类的实例对象，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象也不会被回收，造成内存泄漏</p>
<hr>
<h5> 连接相关</h5>
<p>数据库连接、网络连接和 IO 连接等，当不再使用时，需要显式调用 close 方法来释放与连接，垃圾回收器才会回收对应的对象，否则将会造成大量的对象无法被回收，从而引起内存泄漏</p>
<hr>
<h5> 不合理域</h5>
<p>变量不合理的作用域，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏；如果没有及时地把对象设置为 null，也有可能导致内存泄漏的发生</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过 readFromNet 方法把接收消息保存在 msg 中，然后调用 saveDB 方法把内容保存到数据库中，此时 msg 已经可以被回收，但是 msg 的生命周期与对象的生命周期相同，造成 msg 不能回收，产生内存泄漏</p>
<p>解决：</p>
<ul>
<li>msg 变量可以放在 receiveMsg 方法内部，当方法使用完，msg 的生命周期也就结束，就可以被回收了</li>
<li>在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。</li>
</ul>
<hr>
<h5> 改变哈希</h5>
<p>当一个对象被存储进 HashSet 集合中以后，就<strong>不能修改这个对象中的那些参与计算哈希值的字段</strong>，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值不同，这种情况下使用该对象的当前引用作为的参数去 HashSet 集合中检索对象返回 false，导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏</p>
<hr>
<h5> 缓存泄露</h5>
<p>内存泄漏的一个常见来源是缓存，一旦把对象引用放入到缓存中，就会很容易被遗忘</p>
<p>使用 WeakHashMap 代表缓存，当除了自身有对 key 的引用外没有其他引用，map 会自动丢弃此值</p>
<hr>
<h4> 案例分析</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>程序并没有明显错误，但 pop 函数存在内存泄漏问题，因为 pop 函数只是把栈顶索引下移一位，并没有把上一个出栈索引处的引用置空，导致<strong>栈数组一直强引用着已经出栈的对象</strong></p>
<p>解决方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 类加载</h2>
<h3> 对象访存</h3>
<h4> 存储结构</h4>
<p>一个 Java 对象内存中存储为三部分：对象头（Header）、实例数据（Instance Data）和对齐填充 （Padding）</p>
<p>对象头：</p>
<ul>
<li>
<p>普通对象：分为两部分</p>
<ul>
<li>
<p><strong>Mark Word</strong>：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等</p>
<div class="language-ruby line-numbers-mode" data-ext="rb"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>Klass Word</strong>：类型指针，<strong>指向该对象的 Class 类对象的指针</strong>，虚拟机通过这个指针来确定这个对象是哪个类的实例；在 64 位系统中，开启指针压缩（-XX:+UseCompressedOops）或者 JVM 堆的最大值小于 32G，这个指针也是 4byte，否则是 8byte（就是 <strong>Java 中的一个引用的大小</strong>）</p>
</li>
</ul>
<div class="language-ruby line-numbers-mode" data-ext="rb"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>数组对象：如果对象是一个数组，那在对象头中还有一块数据用于记录数组长度（12 字节）</p>
<div class="language-ruby line-numbers-mode" data-ext="rb"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>实例数据：实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的，都需要记录起来</p>
<p>对齐填充：Padding 起占位符的作用。64 位系统，由于 HotSpot VM 的自动内存管理系统要求<strong>对象起始地址必须是 8 字节的整数倍</strong>，就是对象的大小必须是 8 字节的整数倍，而对象头部分正好是 8 字节的倍数（1 倍或者 2 倍），因此当对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p>
<p>32 位系统：</p>
<ul>
<li>
<p>一个 int 在 java 中占据 4byte，所以 Integer 的大小为：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-ruby line-numbers-mode" data-ext="rb"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><code>int[] arr = new int[10]</code></p>
<div class="language-ruby line-numbers-mode" data-ext="rb"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 实际大小</h4>
<p>浅堆（Shallow Heap）：<strong>对象本身占用的内存，不包括内部引用对象的大小</strong>，32 位系统中一个对象引用占 4 个字节，每个对象头占用 8 个字节，根据堆快照格式不同，对象的大小会同 8 字节进行对齐</p>
<p>JDK7 中的 String：2个 int 值共占 8 字节，value 对象引用占用 4 字节，对象头 8 字节，对齐后占 24 字节，为 String 对象的浅堆大小，与 value 实际取值无关，无论字符串长度如何，浅堆大小始终是 24 字节</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>保留集（Retained Set）：对象 A 的保留集指当对象 A 被垃圾回收后，可以被释放的所有的对象集合（包括 A 本身），所以对象 A 的保留集就是只能通过对象 A 被直接或间接访问到的所有对象的集合，就是仅被对象 A 所持有的对象的集合</p>
<p>深堆（Retained Heap）：指对象的保留集中所有的对象的浅堆大小之和，一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间</p>
<p>对象的实际大小：一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小</p>
<p>下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。那么对象 A 的浅堆大小只是 A 本身，<strong>A 的实际大小为 A、C、D 三者之和</strong>，A 的深堆大小为 A 与 D 之和，由于对象 C 还可以通过对象 B 访问到 C，因此 C 不在对象 A 的深堆范围内</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-对象的实际大小.png" style="zoom: 67%;">
<p>内存分析工具 MAT 提供了一种叫支配树的对象图，体现了对象实例间的支配关系</p>
<p>基本性质：</p>
<ul>
<li>
<p>对象 A 的子树（所有被对象 A 支配的对象集合）表示对象 A 的保留集（retained set），即深堆</p>
</li>
<li>
<p>如果对象 A 支配对象 B，那么对象 A 的直接支配者也支配对象 B</p>
</li>
<li>
<p>支配树的边与对象引用图的边不直接对应</p>
</li>
</ul>
<p>左图表示对象引用图，右图表示左图所对应的支配树：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-支配树.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>比如：对象 F 与对象 D 相互引用，因为到对象 F 的所有路径必然经过对象 D，因此对象 D 是对象 F 的直接支配者</p>
<p>参考文章：<a href="https://www.yuque.com/u21195183/jvm/nkq31c" target="_blank" rel="noopener noreferrer">https://www.yuque.com/u21195183/jvm/nkq31c</a></p>
<hr>
<h4> 节约内存</h4>
<ul>
<li>
<p>尽量使用基本数据类型</p>
</li>
<li>
<p>满足容量前提下，尽量用小字段</p>
</li>
<li>
<p>尽量用数组，少用集合，数组中是可以使用基本类型的，但是集合中只能放包装类型，如果需要使用集合，推荐比较节约内存的集合工具：fastutil</p>
<p>一个 ArrayList 集合，如果里面放了 10 个数字，占用多少内存：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>Mark Word 占 4byte，Klass Word 占 4byte，一个 int 字段占 4byte，elementData 数组占 12byte，数组中 10 个 Integer 对象占 10×16，所以整个集合空间大小为 184byte（深堆）</p>
</li>
<li>
<p>时间用 long/int 表示，不用 Date 或者 String</p>
</li>
</ul>
<hr>
<h4> 对象访问</h4>
<p>JVM 是通过<strong>栈帧中的对象引用</strong>访问到其内部的对象实例：</p>
<ul>
<li>
<p>句柄访问：Java 堆中会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息</p>
<p>优点：reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-对象访问-句柄访问.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>直接指针（HotSpot 采用）：Java 堆对象的布局必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的对象地址</p>
<p>优点：速度更快，<strong>节省了一次指针定位的时间开销</strong></p>
<p>缺点：对象被移动时（如进行 GC 后的内存重新排列），对象的 reference 也需要同步更新</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-对象访问-直接指针.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<p>参考文章：<a href="https://www.cnblogs.com/afraidToForget/p/12584866.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/afraidToForget/p/12584866.html</a></p>
<hr>
<h3> 对象创建</h3>
<h4> 生命周期</h4>
<p>在 Java 中，对象的生命周期包括以下几个阶段：</p>
<ol>
<li>

</li>
<li>

</li>
<li>

</li>
<li>

</li>
<li>

</li>
<li>

</li>
<li>

</li>
</ol>
<p>参考文章：<a href="https://blog.csdn.net/sodino/article/details/38387049" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/sodino/article/details/38387049</a></p>
<hr>
<h4> 创建时机</h4>
<p>类在第一次实例化加载一次，后续实例化不再加载，引用第一次加载的类</p>
<p>Java 对象创建时机：</p>
<ol>
<li>
<p>使用 new 关键字创建对象：由执行类实例创建表达式而引起的对象创建</p>
</li>
<li>
<p>使用 Class 类的 newInstance 方法（反射机制）</p>
</li>
<li>
<p>使用 Constructor 类的 newInstance 方法（反射机制）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 newInstance 方法的这两种方式创建对象使用的就是 Java 的反射机制，事实上 Class 的 newInstance 方法内部调用的也是 Constructor 的 newInstance 方法</p>
</li>
<li>
<p>使用 Clone 方法创建对象：用 clone 方法创建对象的过程中并不会调用任何构造函数，要想使用 clone 方法，我们就必须先实现 Cloneable 接口并实现其定义的 clone 方法</p>
</li>
<li>
<p>使用（反）序列化机制创建对象：当反序列化一个对象时，JVM 会创建一个<strong>单独的对象</strong>，在此过程中，JVM 并不会调用任何构造函数，为了反序列化一个对象，需要让类实现 Serializable 接口</p>
</li>
</ol>
<p>从 Java 虚拟机层面看，除了使用 new 关键字创建对象的方式外，其他方式全部都是通过转变为 invokevirtual 指令直接创建对象的</p>
<hr>
<h4> 创建过程</h4>
<p>创建对象的过程：</p>
<ol>
<li>
<p>判断对象对应的类是否加载、链接、初始化</p>
</li>
<li>
<p>为对象分配内存：指针碰撞、空闲链表。当一个对象被创建时，虚拟机就会为其分配内存来存放对象的实例变量及其从父类继承过来的实例变量，即使从<strong>隐藏变量</strong>也会被分配空间（继承部分解释了为什么会隐藏）</p>
</li>
<li>
<p>处理并发安全问题：</p>
<ul>
<li>采用 CAS 配上自旋保证更新的原子性</li>
<li>每个线程预先分配一块 TLAB</li>
</ul>
</li>
<li>
<p>初始化分配的空间：虚拟机将分配到的内存空间都初始化为零值（不包括对象头），保证对象实例字段在不赋值时可以直接使用，程序能访问到这些字段的数据类型所对应的零值</p>
</li>
<li>
<p>设置对象的对象头：将对象的所属类（类的元数据信息）、对象的 HashCode、对象的 GC 信息、锁信息等数据存储在对象头中</p>
</li>
<li>
<p>执行 init 方法进行实例化：实例变量初始化、实例代码块初始化 、构造函数初始化</p>
<ul>
<li>
<p>实例变量初始化与实例代码块初始化：</p>
<p>对实例变量直接赋值或者使用实例代码块赋值，<strong>编译器会将其中的代码放到类的构造函数中去</strong>，并且这些代码会被放在对超类构造函数的调用语句之后（Java 要求构造函数的第一条语句必须是超类构造函数的调用语句），构造函数本身的代码之前</p>
</li>
<li>
<p>构造函数初始化：</p>
<p><strong>Java 要求在实例化类之前，必须先实例化其超类，以保证所创建实例的完整性</strong>，在准备实例化一个类的对象前，首先准备实例化该类的父类，如果该类的父类还有父类，那么准备实例化该类的父类的父类，依次递归直到递归到 Object 类。然后从 Object 类依次对以下各类进行实例化，初始化父类中的变量和执行构造函数</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4> 承上启下</h4>
<ol>
<li>
<p>一个实例变量在对象初始化的过程中会被赋值几次？一个实例变量最多可以被初始化 4 次</p>
<p>JVM 在为一个对象分配完内存之后，会给每一个实例变量赋予默认值，这个实例变量被第一次赋值；在声明实例变量的同时对其进行了赋值操作，那么这个实例变量就被第二次赋值；在实例代码块中又对变量做了初始化操作，那么这个实例变量就被第三次赋值；；在构造函数中也对变量做了初始化操作，那么这个实例变量就被第四次赋值</p>
</li>
<li>
<p>类的初始化过程与类的实例化过程的异同？</p>
<p>类的初始化是指类加载过程中的初始化阶段对类变量按照代码进行赋值的过程；类的实例化是指在类完全加载到内存中后创建对象的过程（类的实例化触发了类的初始化，先初始化才能实例化）</p>
</li>
<li>
<p>假如一个类还未加载到内存中，那么在创建一个该类的实例时，具体过程是怎样的？（<strong>经典案例</strong>）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>static StaticTest st = new StaticTest();</code>：</p>
<ul>
<li>
<p>实例实例化不一定要在类初始化结束之后才开始</p>
</li>
<li>
<p>在同一个类加载器下，一个类型只会被初始化一次。所以一旦开始初始化一个类，无论是否完成后续都不会再重新触发该类型的初始化阶段了（只考虑在同一个类加载器下的情形）。因此在实例化上述程序中的 st 变量时，<strong>实际上是把实例化嵌入到了静态初始化流程中，并且在上面的程序中，嵌入到了静态初始化的起始位置</strong>，这就导致了实例初始化完全发生在静态初始化之前，这也是导致 a 为 110，b 为 0 的原因</p>
</li>
</ul>
<p>代码等价于：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<hr>
<h3> 加载过程</h3>
<h4> 生命周期</h4>
<p>类是在运行期间<strong>第一次使用时动态加载</strong>的（不使用不加载），而不是一次性加载所有类，因为一次性加载会占用很多的内存，加载的类信息存放于一块成为方法区的内存空间</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-类的生命周期.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>包括 7 个阶段：</p>
<ul>
<li>加载（Loading）</li>
<li>链接：验证（Verification）、准备（Preparation）、解析（Resolution）</li>
<li>初始化（Initialization）</li>
<li>使用（Using）</li>
<li>卸载（Unloading）</li>
</ul>
<hr>
<h4> 加载阶段</h4>
<p>加载是类加载的其中一个阶段，注意不要混淆</p>
<p>加载过程完成以下三件事：</p>
<ul>
<li>通过类的完全限定名称获取定义该类的二进制字节流（二进制字节码）</li>
<li>将该字节流表示的静态存储结构转换为方法区的运行时存储结构（Java 类模型）</li>
<li><strong>将字节码文件加载至方法区后，在堆中生成一个代表该类的 Class 对象，作为该类在方法区中的各种数据的访问入口</strong></li>
</ul>
<p>其中二进制字节流可以从以下方式中获取：</p>
<ul>
<li>从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础</li>
<li>从网络中获取，最典型的应用是 Applet</li>
<li>由其他文件生成，例如由 JSP 文件生成对应的 Class 类</li>
<li>运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 生成字节码</li>
</ul>
<p>方法区内部采用 C++ 的 instanceKlass 描述 Java 类的数据结构：</p>
<ul>
<li><code>_java_mirror</code> 即 Java 的类镜像，例如对 String 来说就是 String.class，作用是把 class 暴露给 Java 使用</li>
<li><code>_super</code> 即父类、<code>_fields</code> 即成员变量、<code>_methods</code> 即方法、<code>_constants</code> 即常量池、<code>_class_loader</code> 即类加载器、<code>_vtable</code> <strong>虚方法表</strong>、<code>_itable</code> 接口方法表</li>
</ul>
<p>加载过程：</p>
<ul>
<li>如果这个类还有父类没有加载，先加载父类</li>
<li>加载和链接可能是交替运行的</li>
<li>Class 对象和 _java_mirror 相互持有对方的地址，堆中对象通过 instanceKlass 和元空间进行交互</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-类的生命周期-加载.png" style="zoom:80%;">
<p>创建数组类有些特殊，因为数组类本身并不是由类加载器负责创建，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建，创建数组类的过程：</p>
<ul>
<li>如果数组的元素类型是引用类型，那么遵循定义的加载过程递归加载和创建数组的元素类型</li>
<li>JVM 使用指定的元素类型和数组维度来创建新的数组类</li>
<li><strong>基本数据类型由启动类加载器加载</strong></li>
</ul>
<hr>
<h4> 链接阶段</h4>
<h5> 验证</h5>
<p>确保 Class 文件的字节流中包含的信息是否符合 JVM 规范，保证被加载类的正确性，不会危害虚拟机自身的安全</p>
<p>主要包括<strong>四种验证</strong>：</p>
<ul>
<li>
<p>文件格式验证</p>
</li>
<li>
<p>语义检查，但凡在语义上不符合规范的，虚拟机不会给予验证通过</p>
<ul>
<li>
<p>是否所有的类都有父类的存在（除了 Object 外，其他类都应该有父类）</p>
</li>
<li>
<p>是否一些被定义为 final 的方法或者类被重写或继承了</p>
</li>
<li>
<p>非抽象类是否实现了所有抽象方法或者接口方法</p>
</li>
<li>
<p>是否存在不兼容的方法</p>
</li>
</ul>
</li>
<li>
<p>字节码验证，试图通过对字节码流的分析，判断字节码是否可以被正确地执行</p>
<ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
<li>函数的调用是否传递了正确类型的参数</li>
<li>变量的赋值是不是给了正确的数据类型</li>
<li>栈映射帧（StackMapTable）在这个阶段用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型</li>
</ul>
</li>
<li>
<p>符号引用验证，Class 文件在其常量池会通过字符串记录将要使用的其他类或者方法</p>
</li>
</ul>
<hr>
<h5> 准备</h5>
<p>准备阶段为<strong>静态变量（类变量）分配内存并设置初始值</strong>，使用的是方法区的内存：</p>
<p>说明：实例变量不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次</p>
<p>类变量初始化：</p>
<ul>
<li>static 变量分配空间和赋值是两个步骤：<strong>分配空间在准备阶段完成，赋值在初始化阶段完成</strong></li>
<li>如果 static 变量是 final 的基本类型以及字符串常量，那么编译阶段值（方法区）就确定了，准备阶段会显式初始化</li>
<li>如果 static 变量是 final 的，但属于引用类型或者构造器方法的字符串，赋值在初始化阶段完成</li>
</ul>
<p>实例：</p>
<ul>
<li>
<p>初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>常量 value 被初始化为 123 而不是 0：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故 boolean 的默认值就是 false</p>
</li>
</ul>
<hr>
<h5> 解析</h5>
<p>将常量池中类、接口、字段、方法的<strong>符号引用替换为直接引用</strong>（内存地址）的过程：</p>
<ul>
<li>符号引用：一组符号来描述目标，可以是任何字面量，属于编译原理方面的概念，如：包括类和接口的全限名、字段的名称和描述符、方法的名称和<strong>方法描述符</strong>（因为类还没有加载完，很多方法是找不到的）</li>
<li>直接引用：直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄，如果有了直接引用，那说明引用的目标必定已经存在于内存之中</li>
</ul>
<p>例如：在 <code>com.demo.Solution</code> 类中引用了 <code>com.test.Quest</code>，把 <code>com.test.Quest</code> 作为符号引用存进类常量池，在类加载完后，<strong>用这个符号引用去方法区找这个类的内存地址</strong></p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等</p>
<ul>
<li>在类加载阶段解析的是非虚方法，静态绑定</li>
<li>也可以在初始化阶段之后再开始解析，这是为了支持 Java 的<strong>动态绑定</strong></li>
<li>通过解析操作，符号引用就可以转变为目标方法在类的虚方法表中的位置，从而使得方法被成功调用</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 初始化</h4>
<h5> 介绍</h5>
<p>初始化阶段才真正开始执行类中定义的 Java 程序代码，在准备阶段，类变量已经赋过一次系统要求的初始值；在初始化阶段，通过程序制定的计划去初始化类变量和其它资源，执行 &lt;clinit&gt;</p>
<p>在编译生成 class 文件时，编译器会产生两个方法加于 class 文件中，一个是类的初始化方法 clinit，另一个是实例的初始化方法 init</p>
<p>类构造器&lt;clinit&gt;() 与实例构造器&lt;init&gt;() 不同，它不需要程序员进行显式调用，在一个类的生命周期中，类构造器最多被虚拟机<strong>调用一次</strong>，而实例构造器则会被虚拟机调用多次，只要程序员创建对象</p>
<p>类在第一次实例化加载一次，把 class 读入内存，后续实例化不再加载，引用第一次加载的类</p>
<hr>
<h5> clinit</h5>
<p>&lt;clinit&gt;()：类构造器，由编译器自动收集类中<strong>所有类变量的赋值动作和静态语句块</strong>中的语句合并产生的</p>
<p>作用：是在类加载过程中的初始化阶段进行静态变量初始化和执行静态代码块</p>
<ul>
<li>如果类中没有静态变量或静态代码块，那么 clinit 方法将不会被生成</li>
<li>clinit 方法只执行一次，在执行 clinit 方法时，必须先执行父类的clinit方法</li>
<li>static 变量的赋值操作和静态代码块的合并顺序由源文件中出现的顺序决定</li>
<li>static 不加 final 的变量都在初始化环节赋值</li>
</ul>
<p><strong>线程安全</strong>问题：</p>
<ul>
<li>虚拟机会保证一个类的 &lt;clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 &lt;clinit&gt;() 方法，其它线程都阻塞等待，直到活动线程执行 &lt;clinit&gt;() 方法完毕</li>
<li>如果在一个类的 &lt;clinit&gt;() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽</li>
</ul>
<p>特别注意：静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt;clinit&gt;() 方法，两者不同的是：</p>
<ul>
<li>在初始化一个接口时，并不会先初始化它的父接口，所以执行接口的 &lt;clinit&gt;() 方法不需要先执行父接口的 &lt;clinit&gt;() 方法</li>
<li>在初始化一个类时，不会先初始化所实现的接口，所以接口的实现类在初始化时不会执行接口的 &lt;clinit&gt;() 方法</li>
<li>只有当父接口中定义的变量使用时，父接口才会初始化</li>
</ul>
<hr>
<h5> 时机</h5>
<p>类的初始化是懒惰的，只有在首次使用时才会被装载，JVM 不会无条件地装载 Class 类型，Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化</p>
<p><strong>主动引用</strong>：虚拟机规范中并没有强制约束何时进行加载，但是规范严格规定了有且只有下列情况必须对类进行初始化（加载、验证、准备都会发生）：</p>
<ul>
<li>当创建一个类的实例时，使用 new 关键字，或者通过反射、克隆、反序列化（前文讲述的对象的创建时机）</li>
<li>当调用类的静态方法或访问静态字段时，遇到 getstatic、putstatic、invokestatic 这三条字节码指令，如果类没有进行过初始化，则必须先触发其初始化
<ul>
<li>getstatic：程序访问类的静态变量（不是静态常量，常量会被加载到运行时常量池）</li>
<li>putstatic：程序给类的静态变量赋值</li>
<li>invokestatic ：调用一个类的静态方法</li>
</ul>
</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用时，如果类没有进行初始化，则需要先触发其初始化</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化，但这条规则并<strong>不适用于接口</strong></li>
<li>当虚拟机启动时，需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类</li>
<li>MethodHandle 和 VarHandle 可以看作是轻量级的反射调用机制，而要想使用这两个调用， 就必须先使用 findStaticVarHandle 来初始化要调用的类</li>
<li>补充：当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化</li>
</ul>
<p><strong>被动引用</strong>：所有引用类的方式都不会触发初始化，称为被动引用</p>
<ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化，只会触发父类的初始化</li>
<li>通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法</li>
<li>常量（final 修饰）在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</li>
<li>调用 ClassLoader 类的 loadClass() 方法加载一个类，并不是对类的主动使用，不会导致类的初始化</li>
</ul>
<hr>
<h5> init</h5>
<p>init 指的是实例构造器，主要作用是在类实例化过程中执行，执行内容包括成员变量初始化和代码块的执行</p>
<p>实例化即调用 &lt;init&gt;()V ，虚拟机会保证这个类的构造方法的线程安全，先为实例变量分配内存空间，再执行赋默认值，然后根据源码中的顺序执行赋初值或代码块，没有成员变量初始化和代码块则不会执行</p>
<p>类实例化过程：<strong>父类的类构造器&lt;clinit&gt;() -&gt; 子类的类构造器&lt;clinit&gt;() -&gt; 父类的成员变量和实例代码块 -&gt; 父类的构造函数 -&gt; 子类的成员变量和实例代码块 -&gt; 子类的构造函数</strong></p>
<p>new 关键字会创建对象并复制 dup 一个对象引用，一个调用 &lt;init&gt; 方法，另一个用来赋值给接收者</p>
<hr>
<h4> 卸载阶段</h4>
<p>时机：执行了 System.exit() 方法，程序正常执行结束，程序在执行过程中遇到了异常或错误而异常终止，由于操作系统出现错误而导致Java 虚拟机进程终止</p>
<p>卸载类即该类的 <strong>Class 对象被 GC</strong>，卸载类需要满足3个要求:</p>
<ol>
<li>该类的所有的实例对象都已被 GC，也就是说堆不存在该类的实例对象</li>
<li>该类没有在其他任何地方被引用</li>
<li>该类的类加载器的实例已被 GC，一般是可替换类加载器的场景，如 OSGi、JSP 的重加载等，很难达成</li>
</ol>
<p>在 JVM 生命周期类，由 JVM 自带的类加载器加载的类是不会被卸载的，自定义的类加载器加载的类是可能被卸载。因为 JVM 会始终引用启动、扩展、系统类加载器，这些类加载器始终引用它们所加载的类，这些类始终是可及的</p>
<hr>
<h3> 类加载器</h3>
<h4> 类加载</h4>
<p>类加载方式：</p>
<ul>
<li>隐式加载：不直接在代码中调用 ClassLoader 的方法加载类对象
<ul>
<li>创建类对象、使用类的静态域、创建子类对象、使用子类的静态域</li>
<li>在 JVM 启动时，通过三大类加载器加载 class</li>
</ul>
</li>
<li>显式加载：
<ul>
<li>ClassLoader.loadClass(className)：只加载和连接，<strong>不会进行初始化</strong></li>
<li>Class.forName(String name, boolean initialize, ClassLoader loader)：使用 loader 进行加载和连接，根据参数 initialize 决定是否初始化</li>
</ul>
</li>
</ul>
<p>类的唯一性：</p>
<ul>
<li>在 JVM 中表示两个 class 对象判断为同一个类存在的两个必要条件：
<ul>
<li>类的完整类名必须一致，包括包名</li>
<li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同</li>
</ul>
</li>
<li>这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true</li>
</ul>
<p>命名空间：</p>
<ul>
<li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</li>
<li>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</li>
</ul>
<p>基本特征：</p>
<ul>
<li><strong>可见性</strong>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的</li>
<li><strong>单一性</strong>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，不会在子加载器中重复加载</li>
</ul>
<hr>
<h4> 加载器</h4>
<p>类加载器是 Java 的核心组件，用于加载字节码到 JVM 内存，得到 Class 类的对象</p>
<p>从 Java 虚拟机规范来讲，只存在以下两种不同的类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：使用 C++ 实现，是虚拟机自身的一部分</li>
<li>自定义类加载器（User-Defined ClassLoader）：Java 虚拟机规范<strong>将所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</strong>，使用 Java 语言实现，独立于虚拟机</li>
</ul>
<p>从 Java 开发人员的角度看：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：
<ul>
<li>处于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类</li>
<li>类加载器负责加载在 <code>JAVA_HOME/jre/lib</code> 或 <code>sun.boot.class.path</code> 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的类，并且是虚拟机识别的类库加载到虚拟机内存中</li>
<li>仅按照文件名识别，如 rt.jar 名字不符合的类库即使放在 lib 目录中也不会被加载</li>
<li>启动类加载器无法被 Java 程序直接引用，编写自定义类加载器时，如果要把加载请求委派给启动类加载器，直接使用 null 代替</li>
</ul>
</li>
<li>扩展类加载器（Extension ClassLoader）：
<ul>
<li>由 ExtClassLoader (sun.misc.Launcher$ExtClassLoader)  实现，上级为 Bootstrap，显示为 null</li>
<li>将 <code>JAVA_HOME/jre/lib/ext</code> 或者被 <code>java.ext.dir</code> 系统变量所指定路径中的所有类库加载到内存中</li>
<li>开发者可以使用扩展类加载器，创建的 JAR 放在此目录下，会由扩展类加载器自动加载</li>
</ul>
</li>
<li>应用程序类加载器（Application ClassLoader）：
<ul>
<li>由 AppClassLoader(sun.misc.Launcher$AppClassLoader) 实现，上级为 Extension</li>
<li>负责加载环境变量 classpath 或系统属性 <code>java.class.path</code> 指定路径下的类库</li>
<li>这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此称为系统类加载器</li>
<li>可以直接使用这个类加载器，如果应用程序中没有自定义类加载器，这个就是程序中默认的类加载器</li>
</ul>
</li>
<li>自定义类加载器：由开发人员自定义的类加载器，上级是 Application</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>补充两个类加载器：</p>
<ul>
<li>SecureClassLoader 扩展了 ClassLoader，新增了几个与使用相关的代码源和权限定义类验证（对 class 源码的访问权限）的方法，一般不会直接跟这个类打交道，更多是与它的子类 URLClassLoader 有所关联</li>
<li>ClassLoader 是一个抽象类，很多方法是空的没有实现，而 URLClassLoader 这个实现类为这些方法提供了具体的实现，并新增了 URLClassPath 类协助取得 Class 字节流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</li>
</ul>
<hr>
<h4> 常用API</h4>
<p>ClassLoader 类，是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p>
<p>获取 ClassLoader 的途径：</p>
<ul>
<li>获取当前类的 ClassLoader：<code>clazz.getClassLoader()</code></li>
<li>获取当前线程上下文的 ClassLoader：<code>Thread.currentThread.getContextClassLoader()</code></li>
<li>获取系统的 ClassLoader：<code>ClassLoader.getSystemClassLoader()</code></li>
<li>获取调用者的 ClassLoader：<code>DriverManager.getCallerClassLoader()</code></li>
</ul>
<p>ClassLoader 类常用方法：</p>
<ul>
<li><code>getParent()</code>：返回该类加载器的超类加载器</li>
<li><code>loadclass(String name)</code>：加载名为 name 的类，返回结果为 Class 类的实例，<strong>该方法就是双亲委派模式</strong></li>
<li><code>findclass(String name)</code>：查找二进制名称为 name 的类，返回结果为 Class 类的实例，该方法会在检查完父类加载器之后被 loadClass() 方法调用</li>
<li><code>findLoadedClass(String name)</code>：查找名称为 name 的已经被加载过的类，final 修饰无法重写</li>
<li><code>defineClass(String name, byte[] b, int off, int len)</code>：将<strong>字节流</strong>解析成 JVM 能够识别的类对象</li>
<li><code>resolveclass(Class\&lt;?&gt; c)</code>：链接指定的 Java 类，可以使类的 Class 对象创建完成的同时也被解析</li>
<li><code>InputStream getResourceAsStream(String name)</code>：指定资源名称获取输入流</li>
</ul>
<hr>
<h4> 加载模型</h4>
<h5> 加载机制</h5>
<p>在 JVM 中，对于类加载模型提供了三种，分别为全盘加载、双亲委派、缓存机制</p>
<ul>
<li>
<p>**全盘加载：**当一个类加载器负责加载某个 Class 时，该 Class 所依赖和引用的其他 Class 也将由该类加载器负责载入，除非显示指定使用另外一个类加载器来载入</p>
</li>
<li>
<p>**双亲委派：**某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，<strong>依次递归</strong>，如果父加载器可以完成类加载任务，就成功返回；只有当父加载器无法完成此加载任务时，才自己去加载</p>
</li>
<li>
<p>**缓存机制：**会保证所有加载过的 Class 都会被缓存，当程序中需要使用某个 Class 时，类加载器先从缓存区中搜寻该 Class，只有当缓存区中不存在该 Class 对象时，系统才会读取该类对应的二进制数据，并将其转换成 Class 对象存入缓冲区（方法区）中</p>
<ul>
<li>这就是修改了 Class 后，必须重新启动 JVM，程序所做的修改才会生效的原因</li>
</ul>
</li>
</ul>
<hr>
<h5> 双亲委派</h5>
<p>双亲委派模型（Parents Delegation Model）：该模型要求除了顶层的启动类加载器外，其它类加载器都要有父类加载器，这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）</p>
<p>工作过程：一个类加载器首先将类加载请求转发到父类加载器，只有当父类加载器无法完成时才尝试自己加载</p>
<p>双亲委派机制的优点：</p>
<ul>
<li>
<p>可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证全局唯一性</p>
</li>
<li>
<p>Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一</p>
</li>
<li>
<p>保护程序安全，防止类库的核心 API 被随意篡改</p>
<p>例如：在工程中新建 java.lang 包，接着在该包下新建 String 类，并定义 main 函数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>此时执行 main 函数会出现异常，在类 java.lang.String 中找不到 main 方法。因为双亲委派的机制，java.lang.String 的在启动类加载器（Bootstrap）得到加载，启动类加载器优先级更高，在核心 jre 库中有其相同名字的类文件，但该类中并没有 main 方法</p>
</li>
</ul>
<p>双亲委派机制的缺点：检查类是否加载的委托过程是单向的，这个方式虽然从结构上看比较清晰，使各个 ClassLoader 的职责非常明确，但<strong>顶层的 ClassLoader 无法访问底层的 ClassLoader 所加载的类</strong>（可见性）</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-双亲委派模型.png" style="zoom: 50%;">
<hr>
<h5> 源码分析</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 破坏委派</h5>
<p>双亲委派模型并不是一个具有强制性约束的模型，而是 Java 设计者推荐给开发者的类加载器实现方式</p>
<p>破坏双亲委派模型的方式：</p>
<ul>
<li>
<p>自定义 ClassLoader</p>
<ul>
<li>如果不想破坏双亲委派模型，只需要重写 findClass 方法</li>
<li>如果想要去破坏双亲委派模型，需要去**重写 loadClass **方法</li>
</ul>
</li>
<li>
<p>引入<strong>线程上下文类加载器</strong></p>
<p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的有 JDBC、JCE、JNDI 等。这些 SPI 接口由 Java 核心库来提供，而 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径 classpath 里，SPI 接口中的代码需要加载具体的实现类：</p>
<ul>
<li>SPI 的接口是 Java 核心库的一部分，是由引导类加载器来加载的</li>
<li>SPI 的实现类是由系统类加载器加载，引导类加载器是无法找到 SPI 的实现类，因为双亲委派模型中 BootstrapClassloader 无法委派 AppClassLoader 来加载类</li>
</ul>
<p>JDK 开发人员引入了线程上下文类加载器（Thread Context ClassLoader），这种类加载器可以通过 Thread  类的 setContextClassLoader 方法进行设置线程上下文类加载器，在执行线程中抛弃双亲委派加载模式，使程序可以逆向使用类加载器，使 Bootstrap 加载器拿到了 Application 加载器加载的类，破坏了双亲委派模型</p>
</li>
<li>
<p>实现程序的动态性，如代码热替换（Hot Swap）、模块热部署（Hot Deployment）</p>
<p>IBM 公司主导的 JSR一291（OSGiR4.2）实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换，在 OSGi 环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构</p>
<p>当收到类加载请求时，OSGi 将按照下面的顺序进行类搜索:</p>
<ol>
<li>将以 java.* 开头的类，委派给父类加载器加载</li>
<li>否则，将委派列表名单内的类，委派给父类加载器加载</li>
<li>否则，将 Import 列表中的类，委派给 Export 这个类的 Bundle 的类加载器加载</li>
<li>否则，查找当前 Bundle 的 ClassPath，使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的 Fragment Bundle 中，如果在就委派给 Fragment Bundle 类加载器加载</li>
<li>否则，查找 Dynamic Import 列表的 Bundle，委派给对应 Bundle 的类加载器加载</li>
<li>否则，类查找失败</li>
</ol>
<p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为，<strong>热替换的关键需求在于服务不能中断</strong>，修改必须立即表现正在运行的系统之中</p>
</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-热替换.png" style="zoom: 33%;">
<hr>
<h4> 沙箱机制</h4>
<p>沙箱机制（Sandbox）：将 Java 代码限定在虚拟机特定的运行范围中，并且严格限制代码对本地系统资源访问，来保证对代码的有效隔离，防止对本地系统造成破坏</p>
<p>沙箱<strong>限制系统资源访问</strong>，包括 CPU、内存、文件系统、网络，不同级别的沙箱对资源访问的限制也不一样</p>
<ul>
<li>JDK1.0：Java 中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码被看作是不受信的。对于授信的本地代码，可以访问一切本地资源，而对于非授信的远程代码不可以访问本地资源，其实依赖于沙箱机制。如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现</li>
<li>JDK1.1：针对安全机制做了改进，增加了安全策略。允许用户指定代码对本地资源的访问权限</li>
<li>JDK1.2：改进了安全机制，增加了代码签名，不论本地代码或是远程代码都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行权限控制</li>
<li>JDK1.6：当前最新的安全机制，引入了域（Domain）的概念。虚拟机会把所有代码加载到不同的系统域和应用域，不同的保护域对应不一样的权限。系统域部分专门负责与关键资源进行交互，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-沙箱机制.png" style="zoom:67%;">
<hr>
<h4> 自定义</h4>
<p>对于自定义类加载器的实现，只需要继承 ClassLoader 类，覆写 findClass 方法即可</p>
<p>作用：隔离加载类、修改类加载的方式、拓展加载源、防止源码泄漏</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> JDK9</h4>
<p>为了保证兼容性，JDK9 没有改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行做了一些变动：</p>
<ul>
<li>
<p>扩展机制被移除，扩展类加载器由于<strong>向后兼容性</strong>的原因被保留，不过被重命名为平台类加载器（platform classloader），可以通过 ClassLoader 的新方法 getPlatformClassLoader() 来获取</p>
</li>
<li>
<p>JDK9 基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数个 JMOD 文件），其中 Java 类库就满足了可扩展的需求，那就无须再保留 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录，此前使用这个目录或者 <code>java.ext.dirs</code> 系统变量来扩展 JDK 功能的机制就不需要再存在</p>
</li>
<li>
<p>启动类加载器、平台类加载器、应用程序类加载器全都继承于 <code>jdk.internal.loader.BuiltinClassLoader</code></p>
</li>
</ul>
<hr>
<h2> 运行机制</h2>
<h3> 执行过程</h3>
<p>Java 文件编译执行的过程：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java文件编译执行的过程.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>类加载器：用于装载字节码文件（.class文件）</li>
<li>运行时数据区：用于分配存储空间</li>
<li>执行引擎：执行字节码文件或本地方法</li>
<li>垃圾回收器：用于对 JVM 中的垃圾内容进行回收</li>
</ul>
<hr>
<h3> 字节码</h3>
<h4> 跨平台性</h4>
<p>Java 语言：跨平台的语言（write once ，run anywhere）</p>
<ul>
<li>当 Java 源代码成功编译成字节码后，在不同的平台上面运行<strong>无须再次编译</strong></li>
<li>让一个 Java 程序正确地运行在 JVM 中，Java 源码就必须要被编译为符合 JVM 规范的字节码</li>
</ul>
<p>编译过程中的编译器：</p>
<ul>
<li>
<p>前端编译器： Sun 的全量式编译器 javac、 Eclipse 的增量式编译器 ECJ，<strong>把源代码编译为字节码文件 .class</strong></p>
<ul>
<li>IntelliJ IDEA 使用 javac 编译器</li>
<li>Eclipse 中，当开发人员编写完代码后保存时，ECJ 编译器就会把未编译部分的源码逐行进行编译，而非每次都全量编译，因此 ECJ 的编译效率会比 javac 更加迅速和高效</li>
<li>前端编译器并不会直接涉及编译优化等方面的技术，具体优化细节移交给 HotSpot 的 JIT 编译器负责</li>
</ul>
</li>
<li>
<p>后端运行期编译器：HotSpot VM 的 C1、C2 编译器，也就是 JIT 编译器，Graal 编译器</p>
<ul>
<li>JIT 编译器：执行引擎部分详解</li>
<li>Graal 编译器：JDK10 HotSpot 加入的一个全新的即时编译器，编译效果短短几年时间就追平了 C2</li>
</ul>
</li>
<li>
<p>静态提前编译器：AOT  (Ahead Of Time Compiler）编译器，直接把源代码编译成本地机器代码</p>
<ul>
<li>
<p>JDK 9 引入，是与即时编译相对立的一个概念，即时编译指的是在程序的运行过程中将字节码转换为机器码，AOT 是程序运行之前便将字节码转换为机器码</p>
</li>
<li>
<p>优点：JVM 加载已经预编译成二进制库，可以直接执行，不必等待即时编译器的预热，减少 Java 应用第一次运行慢的现象</p>
</li>
<li>
<p>缺点：</p>
<ul>
<li>破坏了 Java <strong>一次编译，到处运行</strong>，必须为每个不同硬件编译对应的发行包</li>
<li>降低了 Java 链接过程的动态性，加载的代码在编译期就必须全部已知</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4> 语言发展</h4>
<p>机器码：各种用二进制编码方式表示的指令，与 CPU 紧密相关，所以不同种类的 CPU 对应的机器指令不同</p>
<p>指令：指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令，例如 mov，inc 等，可读性稍好，但是不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同</p>
<p>指令集：不同的硬件平台支持的指令是有区别的，每个平台所支持的指令，称之为对应平台的指令集</p>
<ul>
<li>x86 指令集，对应的是 x86 架构的平台</li>
<li>ARM 指令集，对应的是 ARM 架构的平台</li>
</ul>
<p>汇编语言：用助记符代替机器指令的操作码，用地址符号或标号代替指令或操作数的地址</p>
<ul>
<li>在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令</li>
<li>计算机只认识指令码，汇编语言编写的程序也必须翻译成机器指令码，计算机才能识别和执行</li>
</ul>
<p>高级语言：为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言</p>
<p>字节码：是一种中间状态（中间码）的二进制代码，比机器码更抽象，需要直译器转译后才能成为机器码</p>
<ul>
<li>字节码为了实现特定软件运行和软件环境，与硬件环境无关</li>
<li>通过编译器和虚拟机器实现，编译器将源码编译成字节码，虚拟机器将字节码转译为可以直接执行的指令</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-高级语言执行过程.png" style="zoom:50%;">
<hr>
<h4> 类结构</h4>
<h5> 文件结构</h5>
<p>字节码是一种二进制的类文件，是编译之后供虚拟机解释执行的二进制字节码文件，<strong>一个 class 文件对应一个 public 类型的类或接口</strong></p>
<p>字节码内容是 <strong>JVM 的字节码指令</strong>，不是机器码，C、C++ 经由编译器直接生成机器码，所以执行效率比 Java 高</p>
<p>JVM 官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html" target="_blank" rel="noopener noreferrer">https://docs.oracle.com/javase/specs/jvms/se8/html/index.html</a></p>
<p>根据 JVM 规范，类文件结构如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>说明</th>
<th>长度</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
<td>魔数，识别类文件格式</td>
<td>4个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>副版本号(小版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>主版本号(大版本)</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>常量池计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>常量池表</td>
<td>n个字节</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标识</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>父类索引</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>接口计数</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>接口索引集合</td>
<td>2个字节</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>字段计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>字段表</td>
<td>n个字节</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>方法计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>方法表</td>
<td>n个字节</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>属性计数器</td>
<td>2个字节</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性表</td>
<td>n个字节</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<p>Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型：无符号数和表</p>
<ul>
<li>无符号数属于基本的数据类型，以 u1、u2、u4、u8 来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码构成字符串</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，表都以 <code>_info</code> 结尾，用于描述有层次关系的数据，整个 Class 文件本质上就是一张表，由于表没有固定长度，所以通常会在其前面加上个数说明</li>
</ul>
<p>获取方式：</p>
<ul>
<li>HelloWorld.java 执行 <code>javac -parameters -d . HellowWorld.java</code>指令</li>
<li>写入文件指令 <code>javap -v xxx.class &gt;xxx.txt</code></li>
<li>IDEA 插件 jclasslib</li>
</ul>
<hr>
<h5> 魔数版本</h5>
<p>魔数：每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number），是 Class 文件的标识符，代表这是一个能被虚拟机接受的有效合法的 Class 文件，</p>
<ul>
<li>
<p>魔数值固定为 0xCAFEBABE，不符合则会抛出错误</p>
</li>
<li>
<p>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动</p>
</li>
</ul>
<p>版本：4 个 字节，5 6两个字节代表的是编译的副版本号 minor_version，而 7 8 两个字节是编译的主版本号 major_version</p>
<ul>
<li>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，反之 JVM 会抛出异常 <code>java.lang.UnsupportedClassVersionError</code></li>
</ul>
<table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td>52</td>
<td>0</td>
<td>1.8</td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody>
</table>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-类结构.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>图片来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1PJ411n7xZ</a></p>
<hr>
<h5> 常量池</h5>
<p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池计数器（constant_pool_count），这个容量计数是从 1 而不是 0 开始，是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达不引用任何一个常量池项目，这种情况可用索引值 0 来表示</p>
<p>constant_pool 是一种表结构，以1 ~ constant_pool_count - 1为索引，表明有多少个常量池表项。表项中存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池</p>
<ul>
<li>
<p>字面量（Literal） ：基本数据类型、字符串类型常量、声明为 final 的常量值等</p>
</li>
<li>
<p>符号引用（Symbolic References）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</p>
<ul>
<li>
<p>全限定名：com/test/Demo 这个就是类的全限定名，仅仅是把包名的 <code>.</code> 替换成 <code>/</code>，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个 <code>;</code> 表示全限定名结束</p>
</li>
<li>
<p>简单名称：指没有类型和参数修饰的方法或者字段名称，比如字段 x 的简单名称就是 x</p>
</li>
<li>
<p>描述符：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</p>
<table>
<thead>
<tr>
<th>标志符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>基本数据类型 byte</td>
</tr>
<tr>
<td>C</td>
<td>基本数据类型 char</td>
</tr>
<tr>
<td>D</td>
<td>基本数据类型 double</td>
</tr>
<tr>
<td>F</td>
<td>基本数据类型 float</td>
</tr>
<tr>
<td>I</td>
<td>基本数据类型 int</td>
</tr>
<tr>
<td>J</td>
<td>基本数据类型 long</td>
</tr>
<tr>
<td>S</td>
<td>基本数据类型 short</td>
</tr>
<tr>
<td>Z</td>
<td>基本数据类型 boolean</td>
</tr>
<tr>
<td>V</td>
<td>代表 void 类型</td>
</tr>
<tr>
<td>L</td>
<td>对象类型，比如：<code>Ljava/lang/Object;</code>，不同方法间用<code>;</code>隔开</td>
</tr>
<tr>
<td>[</td>
<td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<p>常量类型和结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>标志(或标识)</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_utf8_info</td>
<td>1</td>
<td>UTF-8编码的字符串</td>
</tr>
<tr>
<td>CONSTANT_Integer_info</td>
<td>3</td>
<td>整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Float_info</td>
<td>4</td>
<td>浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Long_info</td>
<td>5</td>
<td>长整型字面量</td>
</tr>
<tr>
<td>CONSTANT_Double_info</td>
<td>6</td>
<td>双精度浮点型字面量</td>
</tr>
<tr>
<td>CONSTANT_Class_info</td>
<td>7</td>
<td>类或接口的符号引用</td>
</tr>
<tr>
<td>CONSTANT_String_info</td>
<td>8</td>
<td>字符串类型字面量</td>
</tr>
<tr>
<td>CONSTANT_Fieldref_info</td>
<td>9</td>
<td>字段的符号引用</td>
</tr>
<tr>
<td>CONSTANT_Methodref_info</td>
<td>10</td>
<td>类中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref_info</td>
<td>11</td>
<td>接口中方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_NameAndType_info</td>
<td>12</td>
<td>字段或方法的符号引用</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle_info</td>
<td>15</td>
<td>表示方法句柄</td>
</tr>
<tr>
<td>CONSTANT_MethodType_info</td>
<td>16</td>
<td>标志方法类型</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic_info</td>
<td>18</td>
<td>表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<p>18 种常量没有出现 byte、short、char，boolean 的原因：编译之后都可以理解为 Integer</p>
<hr>
<h5> 访问标识</h5>
<p>访问标识（access_flag），又叫访问标志、访问标记，该标识用两个字节表示，用于识别一些类或者接口层次的访问信息，包括这个 Class 是类还是接口，是否定义为 public类型，是否定义为 abstract类型等</p>
<ul>
<li>类的访问权限通常为 ACC_ 开头的常量</li>
<li>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的，比如若是 public final 的类，则该标记为 <code>ACC_PUBLIC | ACC_FINAL</code></li>
<li>使用 <code>ACC_SUPER</code> 可以让类更准确地定位到父类的方法，确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义，现代编译器都会设置并且使用这个标记</li>
</ul>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>标志为 public 类型</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>标志被声明为 final，只有类可以设置</td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2之后编译出来的类的这个标志默认为真，使用增强的方法调用父类方法</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>标志此类并非由用户代码产生（由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>标志这是一个枚举</td>
</tr>
</tbody>
</table>
<hr>
<h5> 索引集合</h5>
<p>类索引、父类索引、接口索引集合</p>
<ul>
<li>
<p>类索引用于确定这个类的全限定名</p>
</li>
<li>
<p>父类索引用于确定这个类的父类的全限定名，Java 语言不允许多重继承，所以父类索引只有一个，除了Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为0</p>
</li>
<li>
<p>接口索引集合就用来描述这个类实现了哪些接口</p>
<ul>
<li>interfaces_count 项的值表示当前类或接口的直接超接口数量</li>
<li>interfaces[] 接口索引集合，被实现的接口将按 implements 语句后的接口顺序从左到右排列在接口索引集合中</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>长度</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>this_class</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces[interfaces_count]</td>
</tr>
</tbody>
</table>
<hr>
<h5> 字段表</h5>
<p>字段 fields 用于描述接口或类中声明的变量，包括类变量以及实例变量，但不包括方法内部、代码块内部声明的局部变量以及从父类或父接口继承。字段叫什么名字、被定义为什么数据类型，都是无法固定的，只能引用常量池中的常量来描述</p>
<p>fields_count（字段计数器），表示当前 class 文件 fields 表的成员个数，用两个字节来表示</p>
<p>fields[]（字段表）：</p>
<ul>
<li>
<p>表中的每个成员都是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述</p>
</li>
<li>
<p>字段访问标识：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否为private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否为protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否为static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否为final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否为volatile</td>
</tr>
<tr>
<td>ACC_TRANSTENT</td>
<td>0x0080</td>
<td>字段是否为transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否为由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否为enum</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>字段名索引：根据该值查询常量池中的指定索引项即可</p>
</li>
<li>
<p>描述符索引：用来描述字段的数据类型、方法的参数列表和返回值</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>byte</td>
<td>有符号字节型树</td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>Unicode字符，UTF-16编码</td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>双精度浮点数</td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>单精度浮点数</td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>整型数</td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>长整数</td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>有符号短整数</td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>布尔值true/false</td>
</tr>
<tr>
<td>V</td>
<td>void</td>
<td>代表void类型</td>
</tr>
<tr>
<td>L Classname</td>
<td>reference</td>
<td>一个名为Classname的实例</td>
</tr>
<tr>
<td>[</td>
<td>reference</td>
<td>一个一维数组</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>属性表集合：属性个数存放在 attribute_count 中，属性具体内容存放在 attribute 数组中，一个字段还可能拥有一些属性，用于存储更多的额外信息，比如初始化值、一些注释信息等</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于常量属性而言，attribute_length 值恒为2</p>
</li>
</ul>
<hr>
<h5> 方法表</h5>
<p>方法表是 methods 指向常量池索引集合，其中每一个 method_info 项都对应着一个类或者接口中的方法信息，完整描述了每个方法的签名</p>
<ul>
<li>如果这个方法不是抽象的或者不是 native 的，字节码中就会体现出来</li>
<li>methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法</li>
<li>methods 表可能会出现由编译器自动添加的方法，比如初始化方法 &lt;cinit&gt; 和实例化方法 &lt;init&gt;</li>
</ul>
<p>**重载（Overload）**一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存</p>
<p>methods_count（方法计数器）：表示 class 文件 methods 表的成员个数，使用两个字节来表示</p>
<p>methods[]（方法表）：每个表项都是一个 method_info 结构，表示当前类或接口中某个方法的完整描述</p>
<ul>
<li>
<p>方法表结构如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>含义</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>访问标志</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>字段名索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>descriptor_index</td>
<td>描述符索引</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>attrubutes_count</td>
<td>属性计数器</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>属性集合</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>方法表访问标志：</p>
<table>
<thead>
<tr>
<th>标志名称</th>
<th>标志值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>字段是否为 public</td>
</tr>
<tr>
<td>ACC_PRIVATE</td>
<td>0x0002</td>
<td>字段是否为 private</td>
</tr>
<tr>
<td>ACC_PROTECTED</td>
<td>0x0004</td>
<td>字段是否为 protected</td>
</tr>
<tr>
<td>ACC_STATIC</td>
<td>0x0008</td>
<td>字段是否为 static</td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>字段是否为 final</td>
</tr>
<tr>
<td>ACC_VOLATILE</td>
<td>0x0040</td>
<td>字段是否为 volatile</td>
</tr>
<tr>
<td>ACC_TRANSTENT</td>
<td>0x0080</td>
<td>字段是否为 transient</td>
</tr>
<tr>
<td>ACC_SYNCHETIC</td>
<td>0x1000</td>
<td>字段是否为由编译器自动产生</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>字段是否为 enum</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h5> 属性表</h5>
<p>属性表集合，指的是 Class 文件所携带的辅助信息，比如该 Class 文件的源文件的名称，以及任何带有 <code>RetentionPolicy.CLASS</code> 或者 <code>RetentionPolicy.RUNTIME</code> 的注解，这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试。字段表、方法表都可以有自己的属性表，用于描述某些场景专有的信息</p>
<p>attributes_ count（属性计数器）：表示当前文件属性表的成员个数</p>
<p>attributes[]（属性表）：属性表的每个项的值必须是 attribute_info 结构</p>
<ul>
<li>
<p>属性的通用格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>属性类型：</p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>使用位置</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Code</td>
<td>方法表</td>
<td>Java 代码编译成的字节码指令</td>
</tr>
<tr>
<td>ConstantValue</td>
<td>字段表</td>
<td>final 关键字定义的常量池</td>
</tr>
<tr>
<td>Deprecated</td>
<td>类、方法、字段表</td>
<td>被声明为 deprecated 的方法和字段</td>
</tr>
<tr>
<td>Exceptions</td>
<td>方法表</td>
<td>方法抛出的异常</td>
</tr>
<tr>
<td>EnclosingMethod</td>
<td>类文件</td>
<td>仅当一个类为局部类或者匿名类是才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td>InnerClass</td>
<td>类文件</td>
<td>内部类列表</td>
</tr>
<tr>
<td>LineNumberTable</td>
<td>Code 属性</td>
<td>Java 源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td>LocalVariableTable</td>
<td>Code 属性</td>
<td>方法的局部变量描述</td>
</tr>
<tr>
<td>StackMapTable</td>
<td>Code 属性</td>
<td>JDK1.6 中新增的属性，供新的类型检查检验器检查和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td>Signature</td>
<td>类，方法表，字段表</td>
<td>用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td>SourceFile</td>
<td>类文件</td>
<td>记录源文件名称</td>
</tr>
<tr>
<td>SourceDebugExtension</td>
<td>类文件</td>
<td>用于存储额外的调试信息</td>
</tr>
<tr>
<td>Syothetic</td>
<td>类，方法表，字段表</td>
<td>标志方法或字段为编泽器自动生成的</td>
</tr>
<tr>
<td>LocalVariableTypeTable</td>
<td>类</td>
<td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td>RuntimeVisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>为动态注解提供支持</td>
</tr>
<tr>
<td>RuntimelnvisibleAnnotations</td>
<td>类，方法表，字段表</td>
<td>用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td>RuntimeVisibleParameterAnnotation</td>
<td>方法表</td>
<td>作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象为方法</td>
</tr>
<tr>
<td>RuntirmelnvisibleParameterAnniotation</td>
<td>方法表</td>
<td>作用与 RuntimelnvisibleAnnotations 属性类似，作用对象哪个为方法参数</td>
</tr>
<tr>
<td>AnnotationDefauit</td>
<td>方法表</td>
<td>用于记录注解类元素的默认值</td>
</tr>
<tr>
<td>BootstrapMethods</td>
<td>类文件</td>
<td>用于保存 invokeddynanic 指令引用的引导方式限定符</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h4> 编译指令</h4>
<h5> javac</h5>
<p>javac：编译命令，将 java 源文件编译成 class 字节码文件</p>
<p><code>javac xx.java</code> 不会在生成对应的局部变量表等信息，使用 <code>javac -g xx.java</code> 可以生成所有相关信息</p>
<hr>
<h5> javap</h5>
<p>javap 反编译生成的字节码文件，根据 class 字节码文件，反解析出当前类对应的 code 区 （字节码指令）、局部变量表、异常表和代码行偏移量映射表、常量池等信息</p>
<p>用法：javap &lt;options&gt; &lt;classes&gt;</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 指令集</h4>
<h5> 执行指令</h5>
<p>Java 字节码属于 JVM 基本执行指令。由一个字节长度的代表某种操作的操作码（opcode）以及零至多个代表此操作所需参数的操作数（operand）所构成，虚拟机中许多指令并不包含操作数，只有一个操作码（零地址指令）</p>
<p>由于限制了 Java 虚拟机操作码的长度为一个字节（0~255），所以指令集的操作码总数不可能超过 256 条</p>
<p>在 JVM 的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如 iload 指令用于从局部变量表中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据</p>
<ul>
<li>i 代表对 int 类型的数据操作</li>
<li>l 代表 long</li>
<li>s 代表 short</li>
<li>b 代表 byte</li>
<li>c 代表 char</li>
<li>f 代表 float</li>
<li>d 代表 double</li>
</ul>
<p>大部分的指令都没有支持 byte、char、short、boolean 类型，编译器会在编译期或运行期将 byte 和 short 类型的数据带符号扩展（Sign-Extend-）为相应的 int 类型数据，将 boolean 和 char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据</p>
<p>在做值相关操作时:</p>
<ul>
<li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，也可能是对象的引用）被压入操作数栈</li>
<li>一个指令，也可以从操作数栈中取出一到多个值（pop 多次），完成赋值、加减乘除、方法传参、系统调用等等操作</li>
</ul>
<hr>
<h5> 加载存储</h5>
<p>加载和存储指令用于将数据从栈帧的局部变量表和操作数栈之间来回传递</p>
<p>局部变量压栈指令：将给定的局部变量表中的数据压入操作数栈</p>
<ul>
<li>xload、xload_n，x 表示取值数据类型，为 i、l、f、d、a， n 为 0 到 3</li>
<li>指令 xload_n 表示将第 n 个局部变量压入操作数栈，aload_n 表示将一个对象引用压栈</li>
<li>指令 xload n 通过指定参数的形式，把局部变量压入操作数栈，局部变量数量超过 4 个时使用这个命令</li>
</ul>
<p>常量入栈指令：将常数压入操作数栈，根据数据类型和入栈内容的不同，又分为 const、push、ldc 指令</p>
<ul>
<li>push：包括 bipush 和 sipush，区别在于接收数据类型的不同，bipush 接收 8 位整数作为参数，sipush 接收 16 位整数</li>
<li>ldc：如果以上指令不能满足需求，可以使用 ldc 指令，接收一个 8 位的参数，该参数指向常量池中的 int、 float 或者 String 的索引，将指定的内容压入堆栈。ldc_w 接收两个 8 位参数，能支持的索引范围更大，如果要压入的元素是 long 或 double 类型的，则使用 ldc2_w 指令</li>
<li>aconst_null 将 null 对象引用压入栈，iconst_m1 将 int 类型常量 -1 压入栈，iconst_0 将 int 类型常量 0 压入栈</li>
</ul>
<p>出栈装入局部变量表指令：将操作数栈中栈顶元素弹出后，装入局部变量表的指定位置，用于给局部变量赋值</p>
<ul>
<li>xstore、xstore_n，x 表示取值类型为 i、l、f、d、a， n 为 0 到 3</li>
<li>xastore 表示存入数组，x 取值为 i、l、f、d、a、b、c、s</li>
</ul>
<p>扩充局部变量表的访问索引的指令：wide</p>
<hr>
<h5> 算术指令</h5>
<p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把计算结果重新压入操作数栈</p>
<p>没有直接支持 byte、 short、 char 和 boolean 类型的算术指令，对于这些数据的运算，都使用 int 类型的指令来处理，数组类型也是转换成 int 数组</p>
<ul>
<li>
<p>加法指令：iadd、ladd、fadd、dadd</p>
</li>
<li>
<p>减法指令：isub、lsub、fsub、dsub</p>
</li>
<li>
<p>乘法指令：imu、lmu、fmul、dmul</p>
</li>
<li>
<p>除法指令：idiv、ldiv、fdiv、ddiv</p>
</li>
<li>
<p>求余指令：irem、lrem、frem、drem（remainder 余数）</p>
</li>
<li>
<p>取反指令：ineg、lneg、fneg、dneg （negation 取反）</p>
</li>
<li>
<p>自增指令：iinc（直接<strong>在局部变量 slot 上进行运算</strong>，不用放入操作数栈）</p>
</li>
<li>
<p>位运算指令，又可分为：</p>
<ul>
<li>位移指令：ishl、ishr、 iushr、lshl、lshr、 lushr</li>
<li>按位或指令：ior、lor</li>
<li>按位与指令：iand、land</li>
<li>按位异或指令：ixor、lxor</li>
</ul>
</li>
<li>
<p>比较指令：dcmpg、dcmpl、 fcmpg、fcmpl、lcmp</p>
</li>
</ul>
<p>运算模式：</p>
<ul>
<li>向最接近数舍入模式，JVM 在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示形式与该值一样接近，将优先选择最低有效位为零的</li>
<li>向零舍入模式：将浮点数转换为整数时，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果</li>
</ul>
<p>NaN 值：当一个操作产生溢出时，将会使用有符号的无穷大表示，如果某个操作结果没有明确的数学定义，将使用 NaN 值来表示</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>分析 i++</strong>：从字节码角度分析：a++ 和 ++a 的区别是先执行 iload 还是先执行 iinc</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>判断结果：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 类型转换</h5>
<p>类型转换指令可以将两种不同的数值类型进行相互转换，除了 boolean 之外的七种类型</p>
<p>宽化类型转换：</p>
<ul>
<li>
<p>JVM 支持以下数值的宽化类型转换（widening numeric conversion），小范围类型到大范围类型的安全转换</p>
<ul>
<li>从 int 类型到 long、float 或者 double 类型，对应的指令为 i2l、i2f、i2d</li>
<li>从 long 类型到 float、 double 类型，对应的指令为 l2f、l2d</li>
<li>从 float 类型到 double 类型，对应的指令为 f2d</li>
</ul>
</li>
<li>
<p>精度损失问题</p>
<ul>
<li>宽化类型转换是不会因为超过目标类型最大值而丢失信息</li>
<li>从 int 转换到 float 或者 long 类型转换到 double 时，将可能发生精度丢失</li>
</ul>
</li>
<li>
<p>从 byte、char 和 short 类型到 int 类型的宽化类型转换实际上是不存在的，JVM 把它们当作 int 处理</p>
</li>
</ul>
<p>窄化类型转换：</p>
<ul>
<li>
<p>Java 虚拟机直接支持以下窄化类型转换：</p>
<ul>
<li>从 int 类型至 byte、 short 或者 char 类型，对应的指令有 i2b、i2c、i2s</li>
<li>从 long 类型到 int 类型，对应的指令有 l2i</li>
<li>从 float 类型到 int 或者 long 类型，对应的指令有:f2i、f2l</li>
<li>从 double 类型到 int、long 或 float 者类型，对应的指令有 d2i、d2、d2f</li>
</ul>
</li>
<li>
<p>精度损失问题：</p>
<ul>
<li>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，转换过程可能会导致数值丢失精度</li>
<li>将一个浮点值窄化转换为整数类型 T（T 限于 int 或 long 类型之一）时，将遵循以下转换规则：
<ul>
<li>如果浮点值是 NaN，那转换结果就是 int 或 long 类型的 0</li>
<li>如果浮点值不是无穷大的话，浮点值使用 IEEE 754 的向零舍入模式取整，获得整数值 v，如果 v 在目标类型 T 的表示范围之内，那转换结果就是 v，否则将根据 v 的符号，转换为 T 所能表示的最大或者最小正数</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h5> 创建访问</h5>
<p>创建指令：</p>
<ul>
<li>
<p>创建类实例指令：new，接收一个操作数指向常量池的索引，表示要创建的类型，执行完成后将对象的引用压入栈</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>dup 是复制操作数栈栈顶的内容</strong>，需要两份引用原因：</p>
<ul>
<li>一个要配合 invokespecial 调用该对象的构造方法 &lt;init&gt;:()V （会消耗掉栈顶一个引用）</li>
<li>一个要配合 astore_1 赋值给局部变量</li>
</ul>
</li>
<li>
<p>创建数组的指令：newarray、anewarray、multianewarray</p>
<ul>
<li>newarray：创建基本类型数组</li>
<li>anewarray：创建引用类型数组</li>
<li>multianewarray：创建多维数组</li>
</ul>
</li>
</ul>
<p>字段访问指令：对象创建后可以通过对象访问指令获取对象实例或数组实例中的字段或者数组元素</p>
<ul>
<li>访问类字段（static字段，或者称为类变量）的指令：getstatic、putstatic</li>
<li>访问类实例字段（非static字段，或者称为实例变量）的指令：getfield、 putfield</li>
</ul>
<p>类型检查指令：检查类实例或数组类型的指令</p>
<ul>
<li>
<p>checkcast：用于检查类型强制转换是否可以进行，如果可以进行 checkcast 指令不会改变操作数栈，否则它会抛出 ClassCastException 异常</p>
</li>
<li>
<p>instanceof：判断给定对象是否是某一个类的实例，会将判断结果压入操作数栈</p>
</li>
</ul>
<hr>
<h5> 方法指令</h5>
<p>方法调用指令：invokevirtual、 invokeinterface、invokespecial、invokestatic、invokedynamic</p>
<p><strong>方法调用章节详解</strong></p>
<hr>
<h5> 操作数栈</h5>
<p>JVM 提供的操作数栈管理指令，可以用于直接操作操作数栈的指令</p>
<ul>
<li>
<p>pop、pop2：将一个或两个元素从栈顶弹出，并且直接废弃</p>
</li>
<li>
<p>dup、dup2，dup_x1、dup2_x1，dup_x2、dup2_x2：复制栈顶一个或两个数值并重新压入栈顶</p>
</li>
<li>
<p>swap：将栈最顶端的两个 slot 数值位置交换，JVM 没有提供交换两个 64 位数据类型数值的指令</p>
</li>
<li>
<p>nop：一个非常特殊的指令，字节码为 0x00，和汇编语言中的 nop 一样，表示什么都不做，一般可用于调试、占位等</p>
</li>
</ul>
<hr>
<h5> 控制转移</h5>
<p>比较指令：比较栈顶两个元素的大小，并将比较结果入栈</p>
<ul>
<li>lcmp：比较两个 long 类型值</li>
<li>fcmpl：比较两个 float 类型值（当遇到NaN时，返回-1）</li>
<li>fcmpg：比较两个 float 类型值（当遇到NaN时，返回1）</li>
<li>dcmpl：比较两个 double 类型值（当遇到NaN时，返回-1）</li>
<li>dcmpg：比较两个 double 类型值（当遇到NaN时，返回1）</li>
</ul>
<p>条件跳转指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ifeq</td>
<td>equals，当栈顶int类型数值等于0时跳转</td>
</tr>
<tr>
<td>ifne</td>
<td>not equals，当栈顶in类型数值不等于0时跳转</td>
</tr>
<tr>
<td>iflt</td>
<td>lower than，当栈顶in类型数值小于0时跳转</td>
</tr>
<tr>
<td>ifle</td>
<td>lower or equals，当栈顶in类型数值小于等于0时跳转</td>
</tr>
<tr>
<td>ifgt</td>
<td>greater than，当栈顶int类型数组大于0时跳转</td>
</tr>
<tr>
<td>ifge</td>
<td>greater or equals，当栈顶in类型数值大于等于0时跳转</td>
</tr>
<tr>
<td>ifnull</td>
<td>为 null 时跳转</td>
</tr>
<tr>
<td>ifnonnull</td>
<td>不为 null 时跳转</td>
</tr>
</tbody>
</table>
<p>比较条件跳转指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>if_icmpeq</td>
<td>比较栈顶两 int 类型数值大小（下同），当前者等于后者时跳转</td>
</tr>
<tr>
<td>if_icmpne</td>
<td>当前者不等于后者时跳转</td>
</tr>
<tr>
<td>if_icmplt</td>
<td>当前者小于后者时跳转</td>
</tr>
<tr>
<td>if_icmple</td>
<td>当前者小于等于后者时跳转</td>
</tr>
<tr>
<td>if_icmpgt</td>
<td>当前者大于后者时跳转</td>
</tr>
<tr>
<td>if_icmpge</td>
<td>当前者大于等于后者时跳转</td>
</tr>
<tr>
<td>if_acmpeq</td>
<td>当结果相等时跳转</td>
</tr>
<tr>
<td>if_acmpne</td>
<td>当结果不相等时跳转</td>
</tr>
</tbody>
</table>
<p>多条件分支跳转指令：</p>
<ul>
<li>tableswitch：用于 switch 条件跳转，case 值连续</li>
<li>lookupswitch：用于 switch 条件跳转，case 值不连续</li>
</ul>
<p>无条件跳转指令：</p>
<ul>
<li>
<p>goto：用来进行跳转到指定行号的字节码</p>
</li>
<li>
<p>goto_w：无条件跳转（宽索引）</p>
</li>
</ul>
<hr>
<h5> 异常处理</h5>
<h6> 处理机制</h6>
<p>抛出异常指令：athrow 指令</p>
<p>JVM 处理异常（catch 语句）不是由字节码指令来实现的，而是<strong>采用异常表来完成</strong>的</p>
<ul>
<li>
<p>代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>字节码：</p>
<ul>
<li>多出一个 <strong>Exception table</strong> 的结构，<strong>[from, to) 是前闭后开的检测范围</strong>，一旦这个范围内的字节码执行出现异常，则通过 type 匹配异常类型，如果一致，进入 target 所指示行号</li>
<li>11 行的字节码指令 astore_2 是将异常对象引用存入局部变量表的 slot 2 位置，因为异常出现时，只能进入 Exception table 中一个分支，所以局部变量表 slot 2 位置被共用</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h6> finally</h6>
<p>finally 中的代码被<strong>复制了 3 份</strong>，分别放入 try 流程，catch 流程以及 catch 剩余的异常类型流程（上节案例）</p>
<ul>
<li>
<p>代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>字节码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h6> return</h6>
<ul>
<li>
<p>吞异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>由于 finally 中的 ireturn 被插入了所有可能的流程，因此返回结果以 finally 的为准</li>
<li>字节码中没有 <strong>athrow</strong> ，表明如果在 finally 中出现了 return，会<strong>吞掉异常</strong></li>
</ul>
</li>
<li>
<p>不吞异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h5> 同步控制</h5>
<p>方法级的同步：是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中，虚拟机可以从方法常量池的方法表结构中的 ACC_SYNCHRONIZED 访问标志得知一个方法是否声明为同步方法</p>
<p>方法内指定指令序列的同步：有 monitorenter 和 monitorexit 两条指令来支持 synchronized 关键字的语义</p>
<ul>
<li>montiorenter：进入并获取对象监视器，即为栈顶对象加锁</li>
<li>monitorexit：释放并退出对象监视器，即为栈顶对象解锁</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码指令同步控制.png" style="zoom: 33%;">
<hr>
<h4> 执行流程</h4>
<p>原始 Java 代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>javap -v Demo.class：省略</p>
<ul>
<li>
<p>常量池载入运行时常量池</p>
</li>
<li>
<p>方法区字节码载入方法区</p>
</li>
<li>
<p>main 线程开始运行，分配栈帧内存：（操作数栈stack=2，局部变量表locals=4）</p>
</li>
<li>
<p><strong>执行引擎</strong>开始执行字节码</p>
<p><code>bipush 10</code>：将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令</p>
<ul>
<li>sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节）</li>
<li>ldc 将一个 int 压入操作数栈</li>
<li>ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节）</li>
<li>这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池</li>
</ul>
<p><code>istore_1</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 1</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>ldc #3</code>：从常量池加载 #3 数据到操作数栈<br>
Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算完成</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>istore_2</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 2</p>
<p><code>iload_1</code>：将局部变量表的 slot 1 数据弹出，放入操作数栈栈顶</p>
<p><code>iload_2</code>：将局部变量表的 slot 2 数据弹出，放入操作数栈栈顶</p>
<p><code>iadd</code>：执行相加操作</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>istore_3</code>：将操作数栈顶数据弹出，存入局部变量表的 slot 3</p>
<p><code>getstatic #4</code>：获取静态字段</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程4.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>iload_3</code>：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程5.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p><code>invokevirtual #5</code>：</p>
<ul>
<li>找到常量池 #5 项</li>
<li>定位到方法区 java/io/PrintStream.println:(I)V 方法</li>
<li><strong>生成新的栈帧</strong>（分配 locals、stack等）</li>
<li>传递参数，执行新栈帧中的字节码</li>
<li>执行完毕，弹出栈帧</li>
<li>清除 main 操作数栈内容</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-字节码执行流程6.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>return：完成 main 方法调用，弹出 main 栈帧，程序结束</p>
</li>
</ul>
<hr>
<h3> 执行引擎</h3>
<h4> 基本介绍</h4>
<p>执行引擎：Java 虚拟机的核心组成部分之一，类加载主要任务是负责装载字节码到其内部，但字节码并不能够直接运行在操作系统之上，需要执行引擎将<strong>字节码指令解释/编译为对应平台上的本地机器指令</strong>，进行执行</p>
<p>虚拟机是一个相对于物理机的概念，这两种机器都有代码执行能力：</p>
<ul>
<li>物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上</li>
<li>虚拟机的执行引擎是由软件自行实现的，可以不受物理条件制约地定制指令集与执行引擎的结构体系</li>
</ul>
<p>Java 是<strong>半编译半解释型语言</strong>，将解释执行与编译执行二者结合起来进行：</p>
<ul>
<li>解释器：根据预定义的规范对字节码采用逐行解释的方式执行，将每条字节码文件中的内容翻译为对应平台的本地机器指令执行</li>
<li>即时编译器（JIT : Just In Time Compiler）：虚拟机运行时将源代码直接编译成<strong>和本地机器平台相关的机器码</strong>后再执行，并存入 Code Cache，下次遇到相同的代码直接执行，效率高</li>
</ul>
<hr>
<h4> 执行方式</h4>
<p>HotSpot VM 采用<strong>解释器与即时编译器并存的架构</strong>，解释器和即时编译器能够相互协作，去选择最合适的方式来权衡编译本地代码和直接解释执行代码的时间</p>
<p>HostSpot JVM 的默认执行方式：</p>
<ul>
<li>当程序启动后，解释器可以马上发挥作用立即执行，省去编译器编译的时间（解释器存在的<strong>必要性</strong>）</li>
<li>随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，将有价值的字节码编译为本地机器指令，以换取更高的程序执行效率</li>
</ul>
<p>HotSpot VM 可以通过 VM 参数设置程序执行方式：</p>
<ul>
<li>-Xint：完全采用解释器模式执行程序</li>
<li>-Xcomp：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li>-Xmixed：采用解释器 + 即时编译器的混合模式共同执行程序</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-执行引擎工作流程.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 热点探测</h4>
<p>热点代码：被 JIT 编译器编译的字节码，根据代码被调用执行的频率而定，一个被多次调用的方法或者一个循环次数较多的循环体都可以被称之为热点代码</p>
<p>热点探测：JIT 编译器在运行时会针热点代码做出深度优化，将其直接编译为对应平台的本地机器指令进行缓存，以提升程序执行性能</p>
<p>JIT 编译在默认情况是异步进行的，当触发某方法或某代码块的优化时，先将其放入编译队列，然后由编译线程进行编译，编译之后的代码放在 CodeCache 中，通过 <code>-XX:-BackgroundCompilation</code> 参数可以关闭异步编译</p>
<ul>
<li><strong>CodeCache</strong> 用于缓存编译后的机器码、动态生成的代码和本地方法代码 JNI</li>
<li>如果 CodeCache 区域被占满，编译器被停用，字节码将不会编译为机器码，应用程序继续运行，但运行性能会降低很多</li>
</ul>
<p>HotSpot VM 采用的热点探测方式是基于计数器的热点探测，为每一个方法都建立 2 个不同类型的计数器：方法调用计数器（Invocation Counter）和回边计数器（BackEdge Counter）</p>
<ul>
<li>
<p>方法调用计数器：用于统计方法被调用的次数，默认阈值在 Client 模式 下是 1500 次，在 Server 模式下是 10000 次（需要进行激进的优化），超过这个阈值，就会触发 JIT 编译，阈值可以通过虚拟机参数 <code>-XX:CompileThreshold</code> 设置</p>
<p>工作流程：当一个方法被调用时， 会先检查该方法是否存在被 JIT 编译过的版本，存在则使用编译后的本地代码来执行；如果不存在则将此方法的调用计数器值加 1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值，如果超过阈值会向即时编译器<strong>提交一个该方法的代码编译请求</strong></p>
</li>
<li>
<p>回边计数器：统计一个方法中循环体代码执行的次数，在字节码中控制流向后跳转的指令称为回边</p>
<p>如果一个方法中的循环体需要执行多次，可以优化为为栈上替换，简称 OSR (On StackReplacement) 编译，<strong>OSR 替换循环代码体的入口，C1、C2 替换的是方法调用的入口</strong>，OSR 编译后会出现方法的整段代码被编译了，但是只有循环体部分才执行编译后的机器码，其他部分仍是解释执行</p>
</li>
</ul>
<hr>
<h4> 分层编译</h4>
<p>HotSpot VM 内嵌两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，简称 C1 编译器和 C2 编译器</p>
<p>C1 编译器会对字节码进行简单可靠的优化，耗时短，以达到更快的编译速度，C1 编译器的优化方法：</p>
<ul>
<li>
<p>方法内联：<strong>将调用的函数代码编译到调用点处</strong>，这样可以减少栈帧的生成，减少参数传递以及跳转过程</p>
<p>方法内联能够消除方法调用的固定开销，任何方法除非被内联，否则调用都会有固定开销，来源于保存程序在该方法中的执行位置，以及新建、压入和弹出新方法所使用的栈帧。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>square 是热点方法，会进行内联，把方法内代码拷贝粘贴到调用者的位置：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>还能够进行常量折叠（constant folding）的优化：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>冗余消除：根据运行时状况进行代码折叠或削除</p>
</li>
<li>
<p>内联缓存：是一种加快动态绑定的优化技术（方法调用部分详解）</p>
</li>
</ul>
<p>C2 编译器进行耗时较长的优化以及激进优化，优化的代码执行效率更高，当激进优化的假设不成立时，再退回使用 C1 编译，这也是使用分层编译的原因</p>
<p>C2 的优化主要是在全局层面，逃逸分析是优化的基础：标量替换、栈上分配、同步消除</p>
<p>VM 参数设置：</p>
<ul>
<li>-client：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器</li>
<li>-server：指定 Java 虚拟机运行在 Server 模式下，并使用 C2 编译器</li>
<li><code>-server -XX:+TieredCompilation</code>：在 1.8 之前，分层编译默认是关闭的，可以添加该参数开启</li>
</ul>
<p>分层编译策略 (Tiered Compilation)：程序解释执行可以触发 C1 编译，将字节码编译成机器码，加上性能监控，C2 编译会根据性能监控信息进行激进优化，JVM 将执行状态分成了 5 个层次：</p>
<ul>
<li>
<p>0 层，解释执行（Interpreter）</p>
</li>
<li>
<p>1 层，使用 C1 即时编译器编译执行（不带 profiling）</p>
</li>
<li>
<p>2 层，使用 C1 即时编译器编译执行（带基本的 profiling）</p>
</li>
<li>
<p>3 层，使用 C1 即时编译器编译执行（带完全的 profiling）</p>
</li>
<li>
<p>4 层，使用 C2 即时编译器编译执行（C1 和 C2 协作运行）</p>
<p>说明：profiling 是指在运行过程中收集一些程序执行状态的数据，例如方法的调用次数，循环的回边次数等</p>
</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/20bd2e9b1f03" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/20bd2e9b1f03</a></p>
<hr>
<h3> 方法调用</h3>
<h4> 方法识别</h4>
<p>Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）</p>
<ul>
<li><strong>方法描述符是由方法的参数类型以及返回类型所构成</strong>，Java 层面叫方法特征签名</li>
<li>在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错</li>
</ul>
<p>JVM 根据名字和描述符来判断的，只要返回值不一样（方法描述符不一样），其它完全一样，在 JVM 中是允许的，但 Java 语言不允许</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 调用机制</h4>
<p>方法调用并不等于方法执行，方法调用阶段唯一的任务就是<strong>确定被调用方法的版本</strong>，不是方法的具体运行过程</p>
<p>在 JVM 中，将符号引用转换为直接引用有两种机制：</p>
<ul>
<li>静态链接：当一个字节码文件被装载进 JVM 内部时，如果被调用的目标方法在编译期可知，且运行期保持不变，将调用方法的符号引用转换为直接引用的过程称之为静态链接（类加载的解析阶段）</li>
<li>动态链接：被调用的方法在编译期无法被确定下来，只能在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此被称为动态链接（初始化后的解析阶段）</li>
</ul>
<ul>
<li>对应方法的绑定（分配）机制：静态绑定和动态绑定，编译器已经区分了重载的方法（静态绑定和动态绑定），因此可以认为虚拟机中不存在重载</li>
</ul>
<p>非虚方法：</p>
<ul>
<li>非虚方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的</li>
<li>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法</li>
<li>所有普通成员方法、实例方法、被重写的方法都是虚方法</li>
</ul>
<p>动态类型语言和静态类型语言：</p>
<ul>
<li>
<p>在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之则是动态类型语言</p>
</li>
<li>
<p>静态语言是判断变量自身的类型信息；动态类型语言是判断变量值的类型信息，变量没有类型信息</p>
</li>
<li>
<p><strong>Java 是静态类型语言</strong>（尽管 Lambda 表达式为其增加了动态特性），JS，Python 是动态类型语言</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 调用指令</h4>
<h5> 五种指令</h5>
<p>普通调用指令：</p>
<ul>
<li>invokestatic：调用静态方法</li>
<li>invokespecial：调用私有方法、构造器，和父类的实例方法或构造器，以及所实现接口的默认方法</li>
<li>invokevirtual：调用所有虚方法（虚方法分派）</li>
<li>invokeinterface：调用接口方法</li>
</ul>
<p>动态调用指令：</p>
<ul>
<li>invokedynamic：动态解析出需要调用的方法
<ul>
<li>Java7 为了实现动态类型语言支持而引入了该指令，但是并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令</li>
<li>Java8 的 lambda 表达式的出现，invokedynamic 指令在 Java 中才有了直接生成方式</li>
</ul>
</li>
</ul>
<p>指令对比：</p>
<ul>
<li>普通调用指令固化在虚拟机内部，方法的调用执行不可干预，根据方法的符号引用链接到具体的目标方法</li>
<li>动态调用指令支持用户确定方法</li>
<li>invokestatic 和 invokespecial 指令调用的方法称为非虚方法，虚拟机能够直接识别具体的目标方法</li>
<li>invokevirtual 和 invokeinterface 指令调用的方法称为虚方法，虚拟机需要在执行过程中根据调用者的动态类型来确定目标方法</li>
</ul>
<p>指令说明：</p>
<ul>
<li>如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final，那么可以不通过动态绑定，直接确定目标方法</li>
<li>普通成员方法是由 invokevirtual 调用，属于<strong>动态绑定</strong>，即支持多态</li>
</ul>
<hr>
<h5> 符号引用</h5>
<p>在编译过程中，虚拟机并不知道目标方法的具体内存地址，Java 编译器会暂时用符号引用来表示该目标方法，这一符号引用包括目标方法所在的类或接口的名字，以及目标方法的方法名和方法描述符</p>
<p>符号引用存储在方法区常量池中，根据目标方法是否为接口方法，分为接口符号引用和非接口符号引用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找：</p>
<ol>
<li>在 C 中查找符合名字及描述符的方法</li>
<li>如果没有找到，在 C 的父类中继续搜索，直至 Object 类</li>
<li>如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。如果有多个符合条件的目标方法，则任意返回其中一个</li>
</ol>
<p>对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找：</p>
<ol>
<li>在 I 中查找符合名字及描述符的方法</li>
<li>如果没有找到，在 Object 类中的公有实例方法中搜索</li>
<li>如果没有找到，则在 I 的超接口中搜索，这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致</li>
</ol>
<hr>
<h5> 执行流程</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>几种不同的方法调用对应的字节码指令：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>invokespecial 调用该对象的构造方法 &lt;init&gt;:()V</li>
<li>invokevirtual 调用对象的成员方法</li>
<li><code>d.test4()</code> 是通过<strong>对象引用</strong>调用一个静态方法，在调用 invokestatic 之前执行了 pop 指令，把对象引用从操作数栈弹掉
<ul>
<li>不建议使用 <code>对象.静态方法()</code> 的方式调用静态方法，多了 aload 和 pop 指令</li>
<li>成员方法与静态方法调用的区别是：执行方法前是否需要对象引用</li>
</ul>
</li>
</ul>
<hr>
<h4> 多态原理</h4>
<h5> 执行原理</h5>
<p>Java 虚拟机中关于方法重写的判定基于方法描述符，如果子类定义了与父类中非私有、非静态方法同名的方法，只有当这两个方法的参数类型以及返回类型一致，Java 虚拟机才会判定为重写</p>
<p>理解多态：</p>
<ul>
<li>多态有编译时多态和运行时多态，即静态绑定和动态绑定</li>
<li>前者是通过方法重载实现，后者是通过重写实现（子类覆盖父类方法，虚方法表）</li>
<li>虚方法：运行时动态绑定的方法，对比静态绑定的非虚方法调用来说，虚方法调用更加耗时</li>
</ul>
<p>方法重写的本质：</p>
<ol>
<li>
<p>找到操作数栈的第一个元素<strong>所执行的对象的实际类型</strong>，记作 C</p>
</li>
<li>
<p>如果在类型 C 中找到与描述符和名称都相符的方法，则进行访问<strong>权限校验</strong>（私有的），如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常</p>
</li>
<li>
<p>找不到，就会按照继承关系从下往上依次对 C 的各个父类进行第二步的搜索和验证过程</p>
</li>
<li>
<p>如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError 异常</p>
</li>
</ol>
<hr>
<h5> 虚方法表</h5>
<p>在虚拟机工作过程中会频繁使用到动态绑定，每次动态绑定的过程中都要重新在类的元数据中搜索合适目标，影响到执行效率。为了提高性能，JVM 采取了一种用<strong>空间换取时间</strong>的策略来实现动态绑定，在每个<strong>类的方法区</strong>建立一个虚方法表（virtual method table），实现使用索引表来代替查找，可以快速定位目标方法</p>
<ul>
<li>invokevirtual 所使用的虚方法表（virtual method table，vtable），执行流程
<ol>
<li>先通过栈帧中的对象引用找到对象，分析对象头，找到对象的实际 Class</li>
<li>Class 结构中有 vtable，查表得到方法的具体地址，执行方法的字节码</li>
</ol>
</li>
<li>invokeinterface 所使用的接口方法表（interface method table，itable）</li>
</ul>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕</p>
<p>虚方法表的执行过程：</p>
<ul>
<li>对于静态绑定的方法调用而言，实际引用是一个指向方法的指针</li>
<li>对于动态绑定的方法调用而言，实际引用是方法表的索引值，也就是方法的间接地址。Java 虚拟机获取调用者的实际类型，并在该实际类型的虚方法表中，根据索引值获得目标方法内存偏移量（指针）</li>
</ul>
<p>为了优化对象调用方法的速度，方法区的类型信息会增加一个指针，该指针指向一个记录该类方法的方法表。每个类中都有一个虚方法表，本质上是一个数组，每个数组元素指向一个当前类及其祖先类中非私有的实例方法</p>
<p>方法表满足以下的特质：</p>
<ul>
<li>其一，子类方法表中包含父类方法表中的<strong>所有方法</strong>，并且在方法表中的索引值与父类方法表种的索引值相同</li>
<li>其二，<strong>非重写的方法指向父类的方法表项，与父类共享一个方法表项，重写的方法指向本身自己的实现</strong>，这就是为什么多态情况下可以访问父类的方法。</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-虚方法表.png" style="zoom: 80%;">
<p>Passenger 类的方法表包括两个方法，分别对应 0 号和 1 号。方法表调换了 toString 方法和 passThroughImmigration 方法的位置，是因为 toString 方法的索引值需要与 Object 类中同名方法的索引值一致，为了保持简洁，这里不考虑 Object 类中的其他方法。</p>
<p>虚方法表对性能的影响：</p>
<ul>
<li>使用了方法表的动态绑定与静态绑定相比，仅仅多出几个内存解引用操作：访问栈上的调用者、读取调用者的动态类型、读取该类型的方法表、读取方法表中某个索引值所对应的目标方法，但是相对于创建并初始化 Java 栈帧这操作的开销可以忽略不计</li>
<li>上述优化的效果看上去不错，但实际上<strong>仅存在于解释执行</strong>中，或者即时编译代码的最坏情况。因为即时编译还拥有另外两种性能更好的优化手段：内联缓存（inlining cache）和方法内联（method inlining）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-虚方法表指向.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>参考文档：<a href="https://www.cnblogs.com/kaleidoscope/p/9790766.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/kaleidoscope/p/9790766.html</a></p>
<hr>
<h5> 内联缓存</h5>
<p>内联缓存：是一种加快动态绑定的优化技术，能够缓存虚方法调用中<strong>调用者的动态类型以及该类型所对应的目标方法</strong>。在之后的执行过程中，如果碰到已缓存的类型，便会直接调用该类型所对应的目标方法；反之内联缓存则会退化至使用基于方法表的动态绑定</p>
<p>多态的三个术语：</p>
<ul>
<li>单态 (monomorphic)：指的是仅有一种状态的情况</li>
<li>多态 (polymorphic)：指的是有限数量种状态的情况，二态（bimorphic）是多态的其中一种</li>
<li>超多态 (megamorphic)：指的是更多种状态的情况，通常用一个具体数值来区分多态和超多态，在这个数值之下，称之为多态，否则称之为超多态</li>
</ul>
<p>对于内联缓存来说，有对应的单态内联缓存、多态内联缓存：</p>
<ul>
<li>单态内联缓存：只缓存了一种动态类型以及所对应的目标方法，实现简单，比较所缓存的动态类型，如果命中，则直接调用对应的目标方法。</li>
<li>多态内联缓存：缓存了多个动态类型及其目标方法，需要逐个将所缓存的动态类型与当前动态类型进行比较，如果命中，则调用对应的目标方法</li>
</ul>
<p>为了节省内存空间，<strong>Java 虚拟机只采用单态内联缓存</strong>，没有命中的处理方法：</p>
<ul>
<li>替换单态内联缓存中的纪录，类似于 CPU 中的数据缓存，对数据的局部性有要求，即在替换内联缓存之后的一段时间内，方法调用的调用者的动态类型应当保持一致，从而能够有效地利用内联缓存</li>
<li>劣化为超多态状态，这也是 Java 虚拟机的具体实现方式，这种状态实际上放弃了优化的机会，将直接访问方法表来动态绑定目标方法，但是与替换内联缓存纪录相比节省了写缓存的额外开销</li>
</ul>
<p>虽然内联缓存附带内联二字，但是并没有内联目标方法</p>
<p>参考文章：<a href="https://time.geekbang.org/column/intro/100010301" target="_blank" rel="noopener noreferrer">https://time.geekbang.org/column/intro/100010301</a></p>
<hr>
<h3> 代码优化</h3>
<h4> 语法糖</h4>
<p>语法糖：指 Java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担</p>
<h4> 构造器</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 拆装箱</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这段代码在 JDK 5 之前是无法编译通过的，必须改写为代码片段2：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>JDK5 以后编译阶段自动转换成上述片段</p>
<hr>
<h4> 泛型擦除</h4>
<p>泛型也是在 JDK 5 开始加入的特性，但 Java 在编译泛型代码后会执行<strong>泛型擦除</strong>的动作，即泛型信息在编译为字节码之后就丢失了，实际的类型都<strong>当做了 Object 类型</strong>来处理：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果前面的 x 变量类型修改为 int 基本类型那么最终生成的字节码是：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 可变参数</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可变参数 <code>String... args</code> 其实是 <code>String[] args</code> ， Java 编译器会在编译期间将上述代码变换为：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：如果调用了 <code>foo()</code> 则等价代码为 <code>foo(new String[]{})</code> ，创建了一个空的数组，而不会传递 null 进去</p>
<hr>
<h4> foreach</h4>
<p>数组的循环：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译后为循环取数：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>集合的循环：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译后转换为对迭代器的调用：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：foreach 循环写法，能够配合数组以及所有实现了 Iterable 接口的集合类一起使用，其中 Iterable 用来获取集合的迭代器</p>
<hr>
<h4> switch</h4>
<h5> 字符串</h5>
<p>switch 可以作用于字符串和枚举类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：<strong>switch 配合 String 和枚举使用时，变量不能为 null</strong></p>
<p>会被编译器转换为：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：</p>
<ul>
<li>执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较</li>
<li>hashCode 是为了提高效率，减少可能的比较；而 equals 是为了防止 hashCode 冲突</li>
</ul>
<hr>
<h5> 枚举</h5>
<p>switch 枚举的例子，原始代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译转换后的代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 枚举类</h4>
<p>JDK 7 新增了枚举类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>编译转换后：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> try-w-r</h4>
<p>JDK 7 开始新增了对需要关闭的资源处理的特殊语法 <code>try-with-resources</code>，格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中资源对象需要实现 <strong>AutoCloseable</strong> 接口，例如 InputStream、OutputStream、Connection、Statement、ResultSet 等接口都实现了 AutoCloseable ，使用 try-withresources可以不用写 finally 语句块，编译器会帮助生成关闭资源代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换成：</p>
<p><code>addSuppressed(Throwable e)</code>：添加被压制异常，是为了防止异常信息的丢失（<strong>fianlly 中如果抛出了异常</strong>）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 方法重写</h4>
<p>方法重写时对返回值分两种情况：</p>
<ul>
<li>父子类的返回值完全一致</li>
<li>子类返回值可以是父类返回值的子类</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于子类，Java 编译器会做如下处理：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>其中桥接方法比较特殊，仅对 Java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突</p>
<hr>
<h4> 匿名内部类</h4>
<h5> 无参优化</h5>
<p>源代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转化后代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 带参优化</h5>
<p>引用局部变量的匿名内部类，源代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>转换后代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>局部变量在底层创建为内部类的成员变量，必须是 final 的原因：</p>
<ul>
<li>
<p>在 Java 中方法调用是值传递的，在匿名内部类中对变量的操作都是基于原变量的副本，不会影响到原变量的值，所以<strong>原变量的值的改变也无法同步到副本中</strong></p>
</li>
<li>
<p>外部变量为 final 是在编译期以强制手段确保用户不会在内部类中做修改原变量值的操作，也是<strong>防止外部操作修改了变量而内部类无法随之变化</strong>出现的影响</p>
<p>在创建 <code>Candy11$1 </code> 对象时，将 x 的值赋值给了 <code>Candy11$1</code> 对象的 val 属性，x 不应该再发生变化了，因为发生变化，this.val$x 属性没有机会再跟着变化</p>
</li>
</ul>
<hr>
<h4> 反射优化</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>foo.invoke 0 ~ 15 次调用的是 MethodAccessor 的实现类 <code>NativeMethodAccessorImpl.invoke0()</code>，本地方法执行速度慢；当调用到第 16 次时，会采用运行时生成的类 <code>sun.reflect.GeneratedMethodAccessor1</code> 代替</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过查看 ReflectionFactory 源码可知：</p>
<ul>
<li>sun.reflect.noInflation 可以用来禁用膨胀，直接生成 GeneratedMethodAccessor1，但首次生成比较耗时，如果仅反射调用一次，不划算</li>
<li>sun.reflect.inflationThreshold 可以修改膨胀阈值</li>
</ul>
<hr>
<h2> 系统优化</h2>
<h3> 性能调优</h3>
<h4> 性能指标</h4>
<p>性能指标主要是吞吐量、响应时间、QPS、TPS 等、并发用户数等，而这些性能指标又依赖于系统服务器的资源，如 CPU、内存、磁盘 IO、网络 IO 等，对于这些指标数据的收集，通常可以根据Java本身的工具或指令进行查询</p>
<p>几个重要的指标：</p>
<ol>
<li>停顿时间（响应时间）：提交请求和返回该请求的响应之间使用的时间，比如垃圾回收中 STW 的时间</li>
<li>吞吐量：对单位时间内完成的工作量（请求）的量度（可以对比 GC 的性能指标）</li>
<li>并发数：同一时刻，对服务器有实际交互的请求数</li>
<li>QPS：Queries Per Second，每秒处理的查询量</li>
<li>TPS：Transactions Per Second，每秒产生的事务数</li>
<li>内存占用：Java 堆区所占的内存大小</li>
</ol>
<hr>
<h4> 优化步骤</h4>
<p>对于一个系统要部署上线时，则一定会对 JVM 进行调整，不经过任何调整直接上线，容易出现线上系统频繁 FullGC 造成系统卡顿、CPU 使用频率过高、系统无反应等问题</p>
<ol>
<li>
<p>性能监控：通过运行日志、堆栈信息、线程快照等信息监控是否出现 GC 频繁、OOM、内存泄漏、死锁、响应时间过长等情况</p>
</li>
<li>
<p>性能分析：</p>
<ul>
<li>打印 GC 日志，通过 GCviewer 或者 <a href="http://gceasy.io" target="_blank" rel="noopener noreferrer">http://gceasy.io</a> 来分析异常信息</li>
</ul>
<ul>
<li>
<p>运用命令行工具、jstack、jmap、jinfo 等</p>
</li>
<li>
<p>dump 出堆文件，使用内存分析工具分析文件</p>
</li>
<li>
<p>使用阿里 Arthas、jconsole、JVisualVM 来<strong>实时查看 JVM 状态</strong></p>
</li>
<li>
<p>jstack 查看堆栈信息</p>
</li>
</ul>
</li>
<li>
<p>性能调优：</p>
<ul>
<li>适当增加内存，根据业务背景选择垃圾回收器</li>
</ul>
<ul>
<li>
<p>优化代码，控制内存使用</p>
</li>
<li>
<p>增加机器，分散节点压力</p>
</li>
<li>
<p>合理设置线程池线程数量</p>
</li>
<li>
<p>使用中间件提高程序效率，比如缓存、消息队列等</p>
</li>
</ul>
</li>
</ol>
<hr>
<h4> 参数调优</h4>
<p>对于 JVM 调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型</p>
<ul>
<li>
<p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>设置年轻代中 Eden 区和两个 Survivor 区的大小比例。该值如果不设置，则默认比例为 8:1:1。Java 官方通过增大 Eden 区的大小，来减少 YGC 发生的次数，虽然次数减少了，但 Eden 区满的时候，由于占用的空间较大，导致释放缓慢，此时 STW 的时间较长，因此需要按照程序情况去调优</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>年轻代和老年代默认比例为 1:2，可以通过调整二者空间大小比率来设置两者的大小。</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>线程堆栈的设置：<strong>每个线程默认会开启 1M 的堆栈</strong>，用于存放栈帧、调用参数、局部变量等，但一般 256K 就够用，通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>一般一天超过一次 FullGC 就是有问题，首先通过工具查看是否出现内存泄露，如果出现内存泄露则调整代码，没有的话则调整 JVM 参数</p>
</li>
<li>
<p>系统 CPU 持续飙高的话，首先先排查代码问题，如果代码没问题，则咨询运维或者云服务器供应商，通常服务器重启或者服务器迁移即可解决</p>
</li>
<li>
<p>如果数据查询性能很低下的话，如果系统并发量并没有多少，则应更加关注数据库的相关问题</p>
</li>
<li>
<p>如果服务器配置还不错，JDK8 开始尽量使用 G1 或者新生代和老年代组合使用并行垃圾回收器</p>
</li>
</ul>
<hr>
<h3> 命令行篇</h3>
<h4> jps</h4>
<p>jps（Java Process Statu）：显示指定系统内所有的 HotSpot 虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程，进程的本地虚拟机 ID 与操作系统的进程 ID 是一致的，是唯一的</p>
<p>使用语法：<code>jps [options] [hostid]</code></p>
<p>options 参数：</p>
<ul>
<li>
<p>-q：仅仅显示 LVMID（local virtual machine id），即本地虚拟机唯一 id，不显示主类的名称等</p>
</li>
<li>
<p>-l：输出应用程序主类的全类名或如果进程执行的是 jar 包，则输出 jar 完整路径</p>
</li>
<li>
<p>-m：输出虚拟机进程启动时传递给主类 main()的参数</p>
</li>
<li>
<p>-v：列出虚拟机进程启动时的JVM参数，比如 -Xms20m -Xmx50m是启动程序指定的 jvm 参数</p>
</li>
</ul>
<p>ostid 参数：RMI注册表中注册的主机名，如果想要远程监控主机上的 java 程序，需要安装 jstatd</p>
<hr>
<h4> jstat</h4>
<p>jstat（JVM Statistics Monitoring Tool）：用于监视 JVM 各种运行状态信息的命令行工具，可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据，在没有 GUI 的图形界面，只提供了纯文本控制台环境的服务器上，它是运行期定位虚拟机性能问题的首选工具，常用于检测垃圾回收问题以及内存泄漏问题</p>
<p>使用语法：<code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</code></p>
<p>查看命令相关参数：jstat-h 或 jstat-help</p>
<ul>
<li>
<p>vmid 是进程 id 号</p>
</li>
<li>
<p>option 参数：</p>
<p>类装载相关：</p>
<ul>
<li>-class：显示 ClassLoader 的相关信息，类的装载、卸载数量、总空间、类装载所消耗的时间等</li>
</ul>
<p>垃圾回收相关：</p>
<ul>
<li>
<p>-gc：显示与GC相关的堆信息，年轻代、老年代、永久代等的容量、已用空间、GC时间合计等信息</p>
</li>
<li>
<p>-gccapacity：显示内容与 -gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间</p>
</li>
<li>
<p>-gcutil：显示内容与 -gc 基本相同，但输出主要关注已使用空间占总空间的百分比</p>
</li>
<li>
<p>-gccause：与 -gcutil 功能一样，但是会额外输出导致最后一次或当前正在发生的 GC 产生的原因</p>
</li>
<li>
<p>-gcnew：显示新生代 GC 状况</p>
</li>
<li>
<p>-gcnewcapacity：显示内容与 -gcnew 基本相同，输出主要关注使用到的最大、最小空间</p>
</li>
<li>
<p>-geold：显示老年代 GC 状况</p>
</li>
<li>
<p>-gcoldcapacity：显示内容与 -gcold 基本相同，输出主要关注使用到的最大、最小空间</p>
</li>
<li>
<p>-gcpermcapacity：显示永久代使用到的最大、最小空间</p>
</li>
</ul>
<p>JIT 相关：</p>
<ul>
<li>
<p>-compiler：显示 JIT 编译器编译过的方法、耗时等信息</p>
</li>
<li>
<p>-printcompilation：输出已经被 JIT 编译的方法</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4> jinfo</h4>
<p>jinfo（Configuration Info for Java）：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数，开发人员可以很方便地找到 Java 虚拟机参数的当前值</p>
<p>使用语法：<code>jinfo [options] pid</code></p>
<p>options 参数：</p>
<ul>
<li>no option：输出全部的参数和系统属性</li>
<li>-flag name：输出对应名称的参数</li>
<li>-flag [+-]name：开启或者关闭对应名称的参数 只有被标记为manageable的参数才可以被动态修改</li>
<li>-flag name=value：设定对应名称的参数</li>
<li>-flags：输出全部的参数</li>
<li>-sysprops：输出系统属性</li>
</ul>
<hr>
<h4> jmap</h4>
<p>jmap（JVM Memory Map）：获取 dump 文件，还可以获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等</p>
<p>使用语法：</p>
<ul>
<li>
<p><code>jmap [options] &lt;pid&gt;</code></p>
</li>
<li>
<p><code>jmap [options] &lt;executable &lt;core&gt;</code></p>
</li>
<li>
<p><code>jmap [options] [server_id@] &lt;remote server IP or hostname&gt;</code></p>
</li>
</ul>
<p>option 参数：</p>
<ul>
<li>-dump：生成 dump 文件（Java堆转储快照，二进制文件），-dump:live 只保存堆中的存活对象</li>
<li>-heap：输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息，以及内存的使用信息等</li>
<li>-histo：输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live 只统计堆中的存活对象</li>
<li>-J &lt;flag&gt;：传递参数给 jmap 启动的 jvm</li>
<li>-finalizerinfo：显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象，仅 linux/solaris 平台有效</li>
<li>-permstat：以 ClassLoader 为统计口径输出永久代的内存状态信息，仅 linux/solaris 平台有效</li>
<li>-F：当虚拟机进程对 -dump 选项没有任何响应时，强制执行生成 dump 文件，仅 linux/solaris 平台有效</li>
</ul>
<hr>
<h4> jhat</h4>
<p>jhat（JVM Heap Analysis Tool）：Sun JDK 提供的 jhat 命令与 jmap 命令搭配使用，用于<strong>分析 jmap 生成的 heap dump 文件</strong>（堆转储快照），jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 文件的分析结果后，用户可以在浏览器中查看分析结果</p>
<p>使用语法：<code>jhat &lt;options&gt; &lt;dumpfile&gt;</code></p>
<p>options 参数：</p>
<ul>
<li>-stack false｜true：关闭｜打开对象分配调用栈跟踪</li>
<li>-refs false｜true：关闭｜打开对象引用跟踪</li>
<li>-port port-number：设置 jhat HTTP Server 的端口号，默认 7000</li>
<li>-exclude exclude-file：执行对象查询时需要排除的数据成员</li>
<li>-baseline exclude-file：指定一个基准堆转储</li>
<li>-debug int：设置 debug 级别</li>
<li>-version：启动后显示版本信息就退出</li>
<li>-J &lt;flag&gt;：传入启动参数，比如 -J-Xmx512m</li>
</ul>
<p>说明：jhat 命令在 JDK9、JDK10 中已经被删除，官方建议用 VisualVM 代替</p>
<hr>
<h4> jstack</h4>
<p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪），线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合</p>
<p>线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题，用 jstack 显示各个线程调用的堆栈情况</p>
<p>使用语法：<code>jstack [options] pid</code></p>
<p>options 参数：</p>
<ul>
<li>-F：当正常输出的请求不被响应时，强制输出线程堆栈</li>
<li>-l：除堆栈外，显示关于锁的附加信息</li>
<li>-m：如果调用本地方法的话，可以显示 C/C++ 的堆栈</li>
</ul>
<p>在 thread dump 中的几种状态：</p>
<ul>
<li>
<p>死锁：Deadlock</p>
</li>
<li>
<p>等待资源：Waiting on condition</p>
</li>
<li>
<p>等待获取监视器：Waiting on monitor entry</p>
</li>
<li>
<p>阻塞：Blocked</p>
</li>
<li>
<p>执行中：Runnable</p>
</li>
<li>
<p>暂停：Suspended</p>
</li>
<li>
<p>对象等待中：Object.wait() 或 TIMED＿WAITING</p>
</li>
<li>
<p>停止：Parked</p>
</li>
</ul>
<hr>
<h4> jcmd</h4>
<p>jcmd 是一个多功能命令行工具，可以用来实现前面除了 jstat 之外所有命令的功能，比如 dump、内存使用、查看 Java 进程、导出线程信息、执行 GC、JVM 运行时间等</p>
<p>jcmd -l：列出所有的JVM进程</p>
<p>jcmd 进程号 help：针对指定的进程，列出支持的所有具体命令</p>
<ul>
<li>Thread.print：可以替换 jstack 指令</li>
</ul>
<ul>
<li>
<p>GC.class_histogram：可以替换 jmap 中的 -histo 操作</p>
</li>
<li>
<p>GC.heap_dump：可以替换 jmap 中的 -dump 操作</p>
</li>
<li>
<p>GC.run：可以查看GC的执行情况</p>
</li>
<li>
<p>VM.uptime：可以查看程序的总执行时间，可以替换 jstat 指令中的 -t  操作</p>
</li>
<li>
<p>VM.system_properties：可以替换 jinfo -sysprops 进程 id</p>
</li>
<li>
<p>VM.flags：可以获取 JVM 的配置参数信息</p>
</li>
</ul>
<hr>
<h4> jstatd</h4>
<p>jstatd 是一个 RMI 服务端程序，相当于代理服务器，建立本地计算机与远程监控工具的通信，jstatd 服务器将本机的 Java 应用程序信息传递到远程计算机</p>
<p>远程主机信息收集，前面的指令只涉及到监控本机的 Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如 jps、jstat），为了启用远程监控，则需要配合使用 jstatd 工具。</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-jstatd图解.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> GUI工具</h3>
<p>工具的使用此处不再多言，推荐一个写的非常好的文章，JVM 调优部分的笔记全部参考此文章编写</p>
<p>视频链接：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=304" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1PJ411n7xZ?p=304</a></p>
<p>文章链接：<a href="https://www.yuque.com/u21195183/jvm/lv1zot" target="_blank" rel="noopener noreferrer">https://www.yuque.com/u21195183/jvm/lv1zot</a></p>
<hr>
<h3> 运行参数</h3>
<h4> 参数选项</h4>
<p>添加 JVM 参数选项：进入 Run/Debug Configurations → VM options 设置参数</p>
<ul>
<li>
<p>标准参数选项：<code>java [-options] class [args...]</code> 或 <code>java [-options] -jar jarfile [args...]</code></p>
<p>命令：<code>-? -help</code> 可以输出此命令的相关选项</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Hotspot JVM 有两种模式，分别是 Server 和 Client，分别通过 -server 和- client 设置模式：</p>
<ul>
<li>
<p>32 位系统上，默认使用 Client 类型的 JVM，要使用 Server 模式，机器配置至少有 2 个以上的内核和 2G 以上的物理内存，Client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器</p>
</li>
<li>
<p>64 位系统上，只支持 Server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</p>
</li>
</ul>
</li>
<li>
<p>-X 参数选项：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>-XX 参数选项：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>程序运行中：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 打印参数</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 内存参数</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>说明：参数前面是<code>+</code>号说明是开启，如果是<code>- </code>号说明是关闭</p>
<hr>
<h4> OOM参数</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 日志参数</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 其他参数</h4>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 代码获取</h4>
<p>Java 提供了 java.lang.management 包用于监视和管理 Java 虚拟机和 Java 运行时中的其他组件，允许本地或远程监控和管理运行的 Java 虚拟机。ManagementFactory 类较为常用，Runtime 类可获取内存、CPU 核数等相关的数据，通过使用这些方法，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 日志分析</h3>
<h4> 日志分类</h4>
<p>HotSpot VM 的 GC 按照回收区域分为两类：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p>
<ul>
<li>
<p>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为：</p>
<ul>
<li>新生代收集（Minor GC/Young GC）：只是新生代（Eden/S0、S1）的垃圾收集</li>
<li>老年代收集（Major GC/Old GC）：只是老年代的垃圾收集，只有 CMS GC 会有单独收集老年代的行为</li>
</ul>
</li>
<li>
<p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集，只有 G1 GC 会有这种行为</p>
</li>
<li>
<p>整堆收集（Full GC）：收集整个 Java 堆和方法区的垃圾收集。</p>
</li>
</ul>
<p>Minor GC/Young GC 日志：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>Full GC 日志：</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr>
<h4> 日志解析</h4>
<p>通过日志看垃圾收集器：</p>
<ul>
<li>
<p>Serial 收集器：新生代显示 <code>[DefNew</code>，即 <code>Default New Generation</code></p>
</li>
<li>
<p>ParNew 收集器：新生代显示 <code>[ParNew</code>，即 <code>Parallel New Generation</code></p>
</li>
<li>
<p>Parallel Scavenge 收集器：新生代显示 <code>[PSYoungGen</code>，JDK1.7 使用的 PSYoungGen</p>
</li>
<li>
<p>Parallel Old 收集器：老年代显示 <code>[ParoldGen</code></p>
</li>
<li>
<p>G1 收集器：显示 <code>garbage-first heap</code></p>
</li>
</ul>
<p>通过日志看 GC 原因：</p>
<ul>
<li>
<p>Allocation Failure：表明本次引起 GC 的原因是因为新生代中没有足够的区域存放需要分配的数据</p>
</li>
<li>
<p>Metadata GCThreshold：Metaspace 区不足</p>
</li>
<li>
<p>FErgonomics：JVM 自适应调整导致的 GC</p>
</li>
<li>
<p>System：调用了 System.gc() 方法</p>
</li>
</ul>
<p>通过日志看 GC 前后情况：GC 前内存占用 → GC 后内存占用（该区域内存总大小）</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>
<p>中括号内：GC 回收前年轻代堆大小 → 回收后大小（年轻代堆总大小）</p>
</li>
<li>
<p>括号外：GC 回收前年轻代和老年代大小 → 回收后大小（年轻代和老年代总大小）</p>
</li>
</ul>
<ul>
<li>Minor GC 堆内存总容量 = 9/10 年轻代 + 老年代，Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系：Eden:S0:S1=8:1:1</li>
</ul>
<p>通过日志看 GC 时间：GC 日志中有三个时间 user、sys、real</p>
<ul>
<li>
<p>user：进程执行用户态代码（核心之外）所使用的时间，这是执行此进程所使用的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内，在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</p>
</li>
<li>
<p>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的 CPU 时间</p>
</li>
<li>
<p>real：程序从开始到结束所用的时钟时间，这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成），对于并行 GC，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数</p>
</li>
</ul>
<p>由于多核的原因，一般的 GC 事件中，real time 小于 sys time＋user time，因为是多个线程并发的去做 GC。如果 real＞sys＋user 的话，则说明 IO 负载非常重或 CPU 不够用</p>
<hr>
<h4> 分析工具</h4>
<p>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的</p>
<ul>
<li>官网地址：<a href="https://gceasy.io/" target="_blank" rel="noopener noreferrer">https://gceasy.io/</a></li>
</ul>
<p>GCViewer 是一款离线的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:&lt;file&gt;，还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等），当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用</p>
<ul>
<li>
<p>源码下载：<a href="https://github.com/chewiebug/GCViewer" target="_blank" rel="noopener noreferrer">https://github.com/chewiebug/GCViewer</a></p>
</li>
<li>
<p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog" target="_blank" rel="noopener noreferrer">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p>
</li>
</ul>
<p>参考文章：<a href="https://www.yuque.com/u21195183/jvm/ukmb3k" target="_blank" rel="noopener noreferrer">https://www.yuque.com/u21195183/jvm/ukmb3k</a></p>
<hr>
]]></content:encoded>
      <enclosure url="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-Java7内存结构图.png" type="image/png"/>
    </item>
    <item>
      <title>JavaSE</title>
      <link>https://newzone.top/Java/JavaSE.html</link>
      <guid>https://newzone.top/Java/JavaSE.html</guid>
      <source url="https://newzone.top/rss.xml">JavaSE</source>
      <description>JavaSE 基础 数据 变量类型 成员变量 局部变量 静态变量 定义位置 在类中，方法外 方法中或者方法的形参 在类中，方法外 初始化值 有默认初始化值 无，赋值后才能使用 有默认初始化值 调用方法 对象调用 对象调用，类名调用 存储位置 堆中 栈中 方法区（JDK8 以后移到堆中） 生命周期 与对象共存亡 与方法共存亡 与类共存亡 别名 实例变量 类变量，静态成员变量</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> JavaSE</h1>
<h2> 基础</h2>
<h3> 数据</h3>
<h4> 变量类型</h4>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">成员变量</th>
<th style="text-align:center">局部变量</th>
<th style="text-align:center">静态变量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义位置</td>
<td style="text-align:center">在类中，方法外</td>
<td style="text-align:center">方法中或者方法的形参</td>
<td style="text-align:center">在类中，方法外</td>
</tr>
<tr>
<td style="text-align:center">初始化值</td>
<td style="text-align:center">有默认初始化值</td>
<td style="text-align:center">无，赋值后才能使用</td>
<td style="text-align:center">有默认初始化值</td>
</tr>
<tr>
<td style="text-align:center">调用方法</td>
<td style="text-align:center">对象调用</td>
<td style="text-align:center"></td>
<td style="text-align:center">对象调用，类名调用</td>
</tr>
<tr>
<td style="text-align:center">存储位置</td>
<td style="text-align:center">堆中</td>
<td style="text-align:center">栈中</td>
<td style="text-align:center">方法区（JDK8 以后移到堆中）</td>
</tr>
<tr>
<td style="text-align:center">生命周期</td>
<td style="text-align:center">与对象共存亡</td>
<td style="text-align:center">与方法共存亡</td>
<td style="text-align:center">与类共存亡</td>
</tr>
<tr>
<td style="text-align:center">别名</td>
<td style="text-align:center">实例变量</td>
<td style="text-align:center"></td>
<td style="text-align:center">类变量，静态成员变量</td>
</tr>
</tbody>
</table>
<p>静态变量只有一个，成员变量是类中的变量，局部变量是方法中的变量</p>
<p>初学时笔记内容参考视频：<a href="https://www.bilibili.com/video/BV1TE41177mP%EF%BC%8C%E9%9A%8F%E7%9D%80%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%B7%B1%E5%85%A5%E5%8F%88%E5%A2%9E%E5%8A%A0%E5%BE%88%E5%A4%9A%E7%9F%A5%E8%AF%86" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1TE41177mP，随着学习的深入又增加很多知识</a></p>
<hr>
<h4> 数据类型</h4>
<h5> 基本类型</h5>
<p>Java 语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型</p>
<p><strong>byte：</strong></p>
<ul>
<li>byte 数据类型是 8 位、有符号的，以二进制补码表示的整数，<strong>8 位一个字节</strong>，首位是符号位</li>
<li>最小值是 -128（-2^7）、最大值是 127（2^7-1）</li>
<li>默认值是 <code>0</code></li>
<li>byte 类型用在大型数组中节约空间，主要代替整数，byte 变量占用的空间只有 int 类型的四分之一</li>
<li>例子：<code>byte a = 100，byte b = -50</code></li>
</ul>
<p><strong>short：</strong></p>
<ul>
<li>short 数据类型是 16 位、有符号的以二进制补码表示的整数</li>
<li>最小值是 -32768（-2^15）、最大值是 32767（2^15 - 1）</li>
<li>short 数据类型也可以像 byte 那样节省空间，一个 short 变量是 int 型变量所占空间的二分之一</li>
<li>默认值是 <code>0</code></li>
<li>例子：<code>short s = 1000，short r = -20000</code></li>
</ul>
<p><strong>int：</strong></p>
<ul>
<li>int 数据类型是 32 位 4 字节、有符号的以二进制补码表示的整数</li>
<li>最小值是 -2,147,483,648（-2^31）、最大值是 2,147,483,647（2^31 - 1）</li>
<li>一般地整型变量默认为 int 类型</li>
<li>默认值是 <code>0</code></li>
<li>例子：<code>int a = 100000, int b = -200000</code></li>
</ul>
<p><strong>long：</strong></p>
<ul>
<li>long 数据类型是 64 位 8 字节、有符号的以二进制补码表示的整数</li>
<li>最小值是 -9,223,372,036,854,775,808（-2^63）、最大值是 9,223,372,036,854,775,807（2^63 -1）</li>
<li>这种类型主要使用在需要比较大整数的系统上</li>
<li>默认值是 <code> 0L</code></li>
<li>例子： <code>long a = 100000L，Long b = -200000L</code>，L 理论上不分大小写，但是若写成 I 容易与数字 1 混淆，不容易分辩</li>
</ul>
<p><strong>float：</strong></p>
<ul>
<li>float 数据类型是单精度、32 位、符合 IEEE 754 标准的浮点数</li>
<li>float 在储存大型浮点数组的时候可节省内存空间</li>
<li>默认值是 <code>0.0f</code></li>
<li>浮点数不能用来表示精确的值，如货币</li>
<li>例子：<code>float f1 = 234.5F</code></li>
</ul>
<p><strong>double：</strong></p>
<ul>
<li>double 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数</li>
<li>浮点数的默认类型为 double 类型</li>
<li>double 类型同样不能表示精确的值，如货币</li>
<li>默认值是 <code>0.0d</code></li>
<li>例子：<code>double d1 = 123.4</code></li>
</ul>
<p><strong>boolean：</strong></p>
<ul>
<li>boolean 数据类型表示一位的信息</li>
<li>只有两个取值：true 和 false</li>
<li>JVM 规范指出 boolean 当做 int 处理，boolean 数组当做 byte 数组处理，这样可以得出 boolean 类型单独使用占了 4 个字节，在数组中是 1 个字节</li>
<li>默认值是 <code>false</code></li>
<li>例子：<code>boolean one = true</code></li>
</ul>
<p><strong>char：</strong></p>
<ul>
<li>char 类型是一个单一的 16 位<strong>两个字节</strong>的 Unicode 字符</li>
<li>最小值是 <code>\u0000</code>（即为 0）</li>
<li>最大值是 <code>\uffff</code>（即为 65535）</li>
<li>char 数据类型可以<strong>存储任何字符</strong></li>
<li>例子：<code>char c = 'A'</code>，<code>char c = '张'</code></li>
</ul>
<hr>
<h5> 上下转型</h5>
<ul>
<li>
<p>float 与 double：</p>
<p>Java 不能隐式执行<strong>向下转型</strong>，因为这会使得精度降低，但是可以向上转型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>隐式类型转换：</p>
<p>字面量 1 是 int 类型，比 short 类型精度要高，因此不能隐式地将 int 类型向下转型为 short 类型</p>
<p>使用 += 或者 ++ 运算符会执行类型转换：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h5> 引用类型</h5>
<p>引用数据类型：类，接口，数组都是引用数据类型，又叫包装类</p>
<p>包装类的作用：</p>
<ul>
<li>包装类作为类首先拥有了 Object 类的方法</li>
<li>包装类作为引用类型的变量可以<strong>存储 null 值</strong></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Java 为包装类做了一些特殊功能，具体来看特殊功能主要有：</p>
<ul>
<li>
<p>可以把基本数据类型的值转换成字符串类型的值</p>
<ol>
<li>调用 toString() 方法</li>
<li>调用 Integer.toString(基本数据类型的值) 得到字符串</li>
<li>直接把基本数据类型 + 空字符串就得到了字符串（推荐使用）</li>
</ol>
</li>
<li>
<p>把字符串类型的数值转换成对应的基本数据类型的值（<strong>重要</strong>）</p>
<ol>
<li>Xxx.parseXxx("字符串类型的数值") → <code>Integer.parseInt(numStr)</code></li>
<li>Xxx.valueOf("字符串类型的数值")   → <code>Integer.valueOf(numStr)</code> （推荐使用）</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h5> 类型对比</h5>
<ul>
<li>
<p>有了基本数据类型，为什么还要引用数据类型？</p>
<blockquote>
<p>引用数据类型封装了数据和处理该数据的方法，比如 Integer.parseInt(String) 就是将 String 字符类型数据转换为 Integer 整型</p>
<p>Java 中大部分类和方法都是针对引用数据类型，包括泛型和集合</p>
</blockquote>
</li>
<li>
<p>引用数据类型那么好，为什么还用基本数据类型？</p>
<blockquote>
<p>引用类型的对象要多储存对象头，对基本数据类型来说空间浪费率太高。逻辑上来讲，Java 只有包装类就够了，为了运行速度，需要用到基本数据类型；优先考虑运行效率的问题，所以二者同时存在是合乎情理的</p>
</blockquote>
</li>
<li>
<p>Java 集合不能存放基本数据类型，只存放对象的引用？</p>
<blockquote>
<p>不能放基本数据类型是因为不是 Object 的子类。泛型思想，如果不用泛型要写很多参数类型不同的但功能相同的函数（方法重载）</p>
</blockquote>
</li>
<li>
<p>==</p>
<blockquote>
<p>== 比较基本数据类型：比较的是具体的值<br>
== 比较引用数据类型：比较的是对象地址值</p>
</blockquote>
</li>
</ul>
<hr>
<h4> 装箱拆箱</h4>
<p><strong>自动装箱</strong>：可以直接把基本数据类型的值或者变量赋值给包装类</p>
<p><strong>自动拆箱</strong>：可以把包装类的变量直接赋值给基本数据类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>自动装箱</strong>反编译后底层调用 <code>Integer.valueOf()</code> 实现，源码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自动拆箱调用 <code>java.lang.Integer#intValue</code>，源码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 缓存池</h4>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>
<p>new Integer(123)：每次都会新建一个对象</p>
</li>
<li>
<p>Integer.valueOf(123)：会使用缓存池中的对象，多次调用取得同一个对象的引用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。编译器会在自动装箱过程调用 valueOf() 方法，因此多个值相同且值在缓存池范围内的 Integer 实例使用自动装箱来创建，那么就会引用相同的对象</p>
<p><strong>基本类型对应的缓存池如下：</strong></p>
<ul>
<li>Boolean values true and false</li>
<li>all byte values</li>
<li>Short values between -128 and 127</li>
<li>Long values between -128 and 127</li>
<li>Integer values between -128 and 127</li>
<li>Character in the range \u0000 to \u007F (0 and 127)</li>
</ul>
<p>在 jdk 1.8 所有的数值类缓冲池中，<strong>Integer 的缓存池 IntegerCache 很特殊，这个缓冲池的下界是 -128，上界默认是 127</strong>，但是上界是可调的，在启动 JVM 时通过 <code>AutoBoxCacheMax=&lt;size&gt;</code> 来指定这个缓冲池的大小，该选项在 JVM 初始化的时候会设定一个名为 java.lang.Integer.IntegerCache 系统属性，然后 IntegerCache 初始化的时候就会读取该系统属性来决定上界</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 输入数据</h4>
<p>语法：<code>Scanner sc = new Scanner(System.in)</code></p>
<ul>
<li>next()：遇到了空格，就不再录入数据了，结束标记：空格、tab 键</li>
<li>nextLine()：可以将数据完整的接收过来，结束标记：回车换行符</li>
</ul>
<p>一般使用 <code>sc.nextInt()</code> 或者 <code>sc.nextLine()</code> 接受整型和字符串，然后转成需要的数据类型</p>
<ul>
<li>Scanner：<code>BufferedReader br = new BufferedReader(new InputStreamReader(System.in))</code></li>
<li>print：<code>PrintStream.write()</code></li>
</ul>
<blockquote>
<p>使用引用数据类型的API</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 数组</h3>
<h4> 初始化</h4>
<p>数组就是存储数据长度固定的容器，存储多个数据的数据类型要一致，<strong>数组也是一个对象</strong></p>
<p>创建数组：</p>
<ul>
<li>数据类型[] 数组名：<code>int[] arr</code>  （常用）</li>
<li>数据类型 数组名[]：<code>int arr[]</code></li>
</ul>
<p>静态初始化：</p>
<ul>
<li>数据类型[] 数组名 = new 数据类型[]{元素1,元素2,...}：<code>int[] arr = new int[]{11,22,33}</code></li>
<li>数据类型[] 数组名 = {元素1,元素2,...}：<code>int[] arr = {44,55,66}</code></li>
</ul>
<p>动态初始化</p>
<ul>
<li>数据类型[] 数组名 = new 数据类型[数组长度]：<code>int[] arr = new int[3]</code></li>
</ul>
<h4> 元素访问</h4>
<ul>
<li>
<p><strong>索引</strong>：每一个存储到数组的元素，都会自动的拥有一个编号，从 <strong>0</strong> 开始。这个自动编号称为数组索引（index），可以通过数组的索引访问到数组中的元素</p>
</li>
<li>
<p><strong>访问格式</strong>：数组名[索引]，<code>arr[0]</code></p>
</li>
<li>
<p><strong>赋值：</strong><code>arr[0] = 10</code></p>
</li>
</ul>
<hr>
<h4> 内存分配</h4>
<p>内存是计算机中的重要器件，临时存储区域，作用是运行程序。编写的程序是存放在硬盘中，在硬盘中的程序是不会运行的，必须放进内存中才能运行，运行完毕后会清空内存，Java 虚拟机要运行程序，必须要对内存进行空间的分配和管理</p>
<table>
<thead>
<tr>
<th>区域名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>寄存器</td>
<td>给 CPU 使用</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>JVM 在使用操作系统功能的时候使用</td>
</tr>
<tr>
<td>方法区</td>
<td>存储可以运行的 class 文件</td>
</tr>
<tr>
<td>堆内存</td>
<td>存储对象或者数组，new 来创建的，都存储在堆内存</td>
</tr>
<tr>
<td>方法栈</td>
<td>方法运行时使用的内存，比如 main 方法运行，进入方法栈中执行</td>
</tr>
</tbody>
</table>
<p>内存分配图：<strong>Java 数组分配在堆内存</strong></p>
<ul>
<li>
<p>一个数组内存图</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/数组内存分配-一个数组内存图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>两个数组内存图</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/数组内存分配-两个数组内存图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>多个数组指向相同内存图</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/数组内存分配-多个数组指向一个数组内存图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<hr>
<h4> 数组异常</h4>
<ul>
<li>
<p>索引越界异常：ArrayIndexOutOfBoundsException</p>
</li>
<li>
<p>空指针异常：NullPointerException</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>arr = null，表示变量 arr 将不再保存数组的内存地址，也就不允许再操作数组，因此运行的时候会抛出空指针异常。在开发中，空指针异常是不能出现的，一旦出现了，就必须要修改编写的代码</p>
<p>解决方案：给数组一个真正的堆内存空间引用即可</p>
</li>
</ul>
<hr>
<h4> 二维数组</h4>
<p>二维数组也是一种容器，不同于一维数组，该容器存储的都是一维数组容器</p>
<p>初始化：</p>
<ul>
<li>
<p>动态初始化：数据类型[][] 变量名 = new 数据类型[m] [n]，<code>int[][] arr = new int[3][3]</code></p>
<ul>
<li>m 表示这个二维数组，可以存放多少个一维数组，行</li>
<li>n 表示每一个一维数组，可以存放多少个元素，列</li>
</ul>
</li>
<li>
<p>静态初始化</p>
<ul>
<li><code>数据类型[][] 变量名 = new 数据类型 [][]{{元素1, 元素2...} , {元素1, 元素2...} </code></li>
<li><code>数据类型[][] 变量名 = {{元素1, 元素2...}, {元素1, 元素2...}...}</code></li>
<li><code>int[][] arr = {{11,22,33}, {44,55,66}}</code></li>
</ul>
</li>
</ul>
<p>遍历：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 运算</h3>
<ul>
<li>
<p>i++ 与 ++i 的区别？</p>
<p>i++ 表示先将 i 放在表达式中运算，然后再加 1，++i 表示先将 i 加 1，然后再放在表达式中运算</p>
</li>
<li>
<p>|| 和 |，&amp;&amp; 和&amp; 的区别，逻辑运算符</p>
<p><strong>&amp; 和| 称为布尔运算符，位运算符；&amp;&amp; 和 || 称为条件布尔运算符，也叫短路运算符</strong></p>
<p>如果 &amp;&amp; 运算符的第一个操作数是 false，就不需要考虑第二个操作数的值了，因为无论第二个操作数的值是什么，其结果都是 false；同样，如果第一个操作数是 true，|| 运算符就返回 true，无需考虑第二个操作数的值；但 &amp; 和 | 却不是这样，它们总是要计算两个操作数。为了提高性能，<strong>尽可能使用 &amp;&amp; 和 || 运算符</strong></p>
</li>
<li>
<p>异或 ^：两位相异为 1，相同为 0，又叫不进位加法</p>
</li>
<li>
<p>同或：两位相同为 1，相异为 0</p>
</li>
<li>
<p>switch：从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>switch 不支持 long、float、double，switch 的设计初衷是对那些只有少数几个值的类型进行等值判断，如果值过于复杂，那么用 if 比较合适</p>
</li>
<li>
<p>break：跳出一层循环</p>
</li>
<li>
<p>移位运算：计算机里一般用<strong>补码表示数字</strong>，正数、负数的表示区别就是最高位是 0 还是 1</p>
<ul>
<li>
<p>正数的原码反码补码相同，最高位为 0</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>负数：<br>
原码：最高位为 1，其余位置和正数相同<br>
反码：保证符号位不变，其余位置取反<br>
补码：保证符号位不变，其余位置取反后加 1，即反码 +1</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>补码 → 原码：符号位不变，其余位置取反加 1</p>
</li>
</ul>
<p>运算符：</p>
<ul>
<li><code>&gt;&gt;</code> 运算符：将二进制位进行右移操作，相当于除 2</li>
<li><code>&lt;&lt;</code> 运算符：将二进制位进行左移操作，相当于乘 2</li>
<li><code>&gt;&gt;&gt;</code> 运算符：无符号右移，忽略符号位，空位都以 0 补齐</li>
</ul>
<p>运算规则：</p>
<ul>
<li>
<p>正数的左移与右移，空位补 0</p>
</li>
<li>
<p>负数原码的左移与右移，空位补 0</p>
<p>负数反码的左移与右移，空位补 1</p>
<p>负数补码，左移低位补 0（会导致负数变为正数的问题，因为移动了符号位），右移高位补 1</p>
</li>
<li>
<p>无符号移位，空位补 0</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3> 参数</h3>
<h4> 形参实参</h4>
<p>形参：</p>
<ul>
<li>形式参数，用于定义方法的时候使用的参数，只能是变量</li>
<li>形参只有在方法被调用的时候，虚拟机才分配内存单元，方法调用结束之后便会释放所分配的内存单元</li>
</ul>
<p>实参：调用方法时传递的数据可以是常量，也可以是变量</p>
<h4> 可变参数</h4>
<p>可变参数用在形参中可以接收多个数据，在方法内部<strong>本质上就是一个数组</strong></p>
<p>格式：数据类型... 参数名称</p>
<p>作用：传输参数非常灵活，可以不传输参数、传输一个参数、或者传输一个数组</p>
<p>可变参数的注意事项：</p>
<ul>
<li>一个形参列表中可变参数只能有一个</li>
<li>可变参数必须放在形参列表的<strong>最后面</strong></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 方法</h3>
<h4> 方法概述</h4>
<p>方法（method）是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集</p>
<p>注意：方法必须先创建才可以使用，该过程成为方法定义，方法创建后并不是直接可以运行的，需要手动使用后才执行，该过程成为方法调用</p>
<p>在方法内部定义的叫局部变量，局部变量不能加 static，包括 protected、private、public 这些也不能加</p>
<p>原因：局部变量是保存在栈中的，而静态变量保存于方法区（JDK8 在堆中），局部变量出了方法就被栈回收了，而静态变量不会，所以<strong>在局部变量前不能加 static 关键字</strong>，静态变量是定义在类中，又叫类变量</p>
<hr>
<h4> 定义调用</h4>
<p>定义格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>调用格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>方法名：调用方法时候使用的标识</li>
<li>参数：由数据类型和变量名组成，多个参数之间用逗号隔开</li>
<li>方法体：完成功能的代码块</li>
<li>return：如果方法操作完毕，有数据返回，用于把数据返回给调用者</li>
</ul>
<p>如果方法操作完毕</p>
<ul>
<li>void 类型的方法，直接调用即可，而且方法体中一般不写 return</li>
<li>非 void 类型的方法，推荐用变量接收调用</li>
</ul>
<p>原理：每个方法在被调用执行的时候，都会进入栈内存，并且拥有自己独立的内存空间，方法内部代码调用完毕之后，会从栈内存中弹栈消失</p>
<hr>
<h4> 注意事项</h4>
<ul>
<li>
<p>方法不能嵌套定义</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>void 表示无返回值，可以省略 return，也可以单独的书写 return，后面不加数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 方法重载</h4>
<h5> 重载介绍</h5>
<p>方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载：</p>
<ol>
<li>多个方法在<strong>同一个类</strong>中</li>
<li>多个方法具有<strong>相同的方法名</strong></li>
<li>多个方法的<strong>参数不相同</strong>，类型不同或者数量不同</li>
</ol>
<p>重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式</p>
<p>重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，<strong>不能通过返回值来判定两个方法是否构成重载</strong></p>
<p>原理：JVM → 运行机制 → 方法调用 → 多态原理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 方法选取</h5>
<p>重载的方法在编译过程中即可完成识别，方法调用时 Java 编译器会根据所传入参数的声明类型（注意与实际类型区分）来选取重载方法。选取的过程共分为三个阶段：</p>
<ul>
<li>一阶段：在不考虑对基本类型自动装拆箱 (auto-boxing，auto-unboxing)，以及可变长参数的情况下选取重载方法</li>
<li>二阶段：如果第一阶段中没有找到适配的方法，那么在允许自动装拆箱，但不允许可变长参数的情况下选取重载方法</li>
<li>三阶段：如果第二阶段中没有找到适配的方法，那么在允许自动装拆箱以及可变长参数的情况下选取重载方法</li>
</ul>
<p>如果 Java 编译器在同一个阶段中找到了多个适配的方法，那么会选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系，<strong>一般会选择形参为参数类型的子类的方法，因为子类时更具体的实现</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因此不提倡可变长参数方法的重载</p>
<hr>
<h5> 继承重载</h5>
<p>除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。如果子类定义了与父类中<strong>非私有方法</strong>同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载</p>
<ul>
<li>如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法</li>
<li>如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法，也就是<strong>多态</strong></li>
</ul>
<hr>
<h4> 参数传递</h4>
<p>Java 的参数是以<strong>值传递</strong>的形式传入方法中</p>
<p>值传递和引用传递的区别在于传递后会不会影响实参的值：<strong>值传递会创建副本</strong>，引用传递不会创建副本</p>
<ul>
<li>
<p>基本数据类型：形式参数的改变，不影响实际参数</p>
<p>每个方法在栈内存中，都会有独立的栈空间，方法运行结束后就会弹栈消失</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>引用类型：形式参数的改变，影响实际参数的值</p>
<p><strong>引用数据类型的传参，本质上是将对象的地址以值的方式传递到形参中</strong>，内存中会造成两个引用指向同一个内存的效果，所以即使方法弹栈，堆内存中的数据也已经是改变后的结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 枚举</h3>
<p>枚举是 Java 中的一种特殊类型，为了做信息的标志和信息的分类</p>
<p>定义枚举的格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>枚举的特点：</p>
<ul>
<li>枚举类是用 final 修饰的，枚举类不能被继承</li>
<li>枚举类默认继承了 java.lang.Enum 枚举类</li>
<li>枚举类的第一行都是常量，必须是罗列枚举类的实例名称</li>
<li>枚举类相当于是多例设计模式</li>
<li>每个枚举项都是一个实例，是一个静态成员变量</li>
</ul>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String name()</td>
<td>获取枚举项的名称</td>
</tr>
<tr>
<td>int ordinal()</td>
<td>返回枚举项在枚举类中的索引值</td>
</tr>
<tr>
<td>int compareTo(E  o)</td>
<td>比较两个枚举项，返回的是索引值的差值</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回枚举常量的名称</td>
</tr>
<tr>
<td>static &lt;T&gt; T  valueOf(Class&lt;T&gt; type,String  name)</td>
<td>获取指定枚举类中的指定名称的枚举值</td>
</tr>
<tr>
<td>values()</td>
<td>获得所有的枚举项</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>源码分析：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>API 使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> Debug</h3>
<p>Debug 是供程序员使用的程序调试工具，它可以用于查看程序的执行流程，也可以用于追踪程序执行过程来调试程序。</p>
<p>加断点 → Debug 运行 → 单步运行 → 看 Debugger 窗口 → 看 Console 窗口</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug按键说明.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Debug条件断点.png" alt="Debug条件断点" style="zoom:50%;">
<hr>
<h2> 对象</h2>
<h3> 概述</h3>
<p>Java 是一种面向对象的高级编程语言</p>
<p>面向对象三大特征：<strong>封装，继承，多态</strong></p>
<p>两个概念：类和对象</p>
<ul>
<li>类：相同事物共同特征的描述，类只是学术上的一个概念并非真实存在的，只能描述一类事物</li>
<li>对象：是真实存在的实例， 实例 == 对象，<strong>对象是类的实例化</strong></li>
<li>结论：有了类和对象就可以描述万千世界所有的事物，必须先有类才能有对象</li>
</ul>
<hr>
<h3> 类</h3>
<h4> 定义</h4>
<p>定义格式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>类名的首字母建议大写，满足驼峰模式，比如 StudentNameCode</li>
<li>一个 Java 代码中可以定义多个类，按照规范一个 Java 文件一个类</li>
<li>一个 Java 代码文件中，只能有一个类是 public 修饰，<strong>public 修饰的类名必须成为当前 Java 代码的文件名称</strong></li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 构造器</h4>
<p>构造器格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>作用：初始化类的一个对象返回</p>
<p>分类：无参数构造器，有参数构造器</p>
<p>注意：<strong>一个类默认自带一个无参数构造器</strong>，写了有参数构造器默认的无参数构造器就消失，还需要用无参数构造器就要重新写</p>
<p>构造器初始化对象的格式：类名 对象名称 = new 构造器</p>
<ul>
<li>无参数构造器的作用：初始化一个类的对象（使用对象的默认值初始化）返回</li>
<li>有参数构造器的作用：初始化一个类的对象（可以在初始化对象的时候为对象赋值）返回</li>
</ul>
<hr>
<h3> 包</h3>
<p>包：分门别类的管理各种不同的技术，便于管理技术，扩展技术，阅读技术</p>
<p>定义包的格式：<code>package 包名</code>，必须放在类名的最上面</p>
<p>导包格式：<code>import 包名.类名</code></p>
<p>相同包下的类可以直接访问；不同包下的类必须导包才可以使用</p>
<hr>
<h3> 封装</h3>
<p>封装的哲学思维：合理隐藏，合理暴露</p>
<p>封装最初的目的：提高代码的安全性和复用性，组件化</p>
<p>封装的步骤：</p>
<ol>
<li><strong>成员变量应该私有，用 private 修饰，只能在本类中直接访问</strong></li>
<li><strong>提供成套的 getter 和 setter 方法暴露成员变量的取值和赋值</strong></li>
</ol>
<p>使用 private 修饰成员变量的原因：实现数据封装，不想让别人使用修改你的数据，比较安全</p>
<hr>
<h3> this</h3>
<p>this 关键字的作用：</p>
<ul>
<li>this 关键字代表了当前对象的引用</li>
<li>this 出现在方法中：<strong>哪个对象调用这个方法 this 就代表谁</strong></li>
<li>this 可以出现在构造器中：代表构造器正在初始化的那个对象</li>
<li>this 可以区分变量是访问的成员变量还是局部变量</li>
</ul>
<hr>
<h3> static</h3>
<h4> 基本介绍</h4>
<p>Java 是通过成员变量是否有 static 修饰来区分是类的还是属于对象的</p>
<p>按照有无 static 修饰，成员变量和方法可以分为：</p>
<ul>
<li>
<p>成员变量：</p>
<ul>
<li>静态成员变量（类变量）：static 修饰的成员变量，属于类本身，<strong>与类一起加载一次，只有一个</strong>，直接用类名访问即可</li>
<li>实例成员变量：无 static 修饰的成员变量，属于类的每个对象的，<strong>与类的对象一起加载</strong>，对象有多少个，实例成员变量就加载多少个，必须用类的对象来访问</li>
</ul>
</li>
<li>
<p>成员方法：</p>
<ul>
<li>静态方法：有 static 修饰的成员方法称为静态方法也叫类方法，属于类本身的，直接用类名访问即可</li>
<li>实例方法：无 static 修饰的成员方法称为实例方法，属于类的每个对象的，必须用类的对象来访问</li>
</ul>
</li>
</ul>
<hr>
<h4> static 用法</h4>
<p>成员变量的访问语法：</p>
<ul>
<li>
<p>静态成员变量：只有一份可以被类和类的对象<strong>共享访问</strong></p>
<ul>
<li>类名.静态成员变量（同一个类中访问静态成员变量可以省略类名不写）</li>
<li>对象.静态成员变量（不推荐）</li>
</ul>
</li>
<li>
<p>实例成员变量：</p>
<ul>
<li>对象.实例成员变量（先创建对象）</li>
</ul>
</li>
</ul>
<p>成员方法的访问语法：</p>
<ul>
<li>
<p>静态方法：有 static 修饰，属于类</p>
<ul>
<li>类名.静态方法（同一个类中访问静态成员可以省略类名不写）</li>
<li>对象.静态方法（不推荐，参考 JVM → 运行机制 → 方法调用）</li>
</ul>
</li>
<li>
<p>实例方法：无 static 修饰，属于对象</p>
<ul>
<li>对象.实例方法</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 两个问题</h4>
<p>内存问题：</p>
<ul>
<li>
<p>栈内存存放 main 方法和地址</p>
</li>
<li>
<p>堆内存存放对象和变量</p>
</li>
<li>
<p>方法区存放 class 和静态变量（jdk8 以后移入堆）</p>
</li>
</ul>
<p>访问问题：</p>
<ul>
<li>实例方法是否可以直接访问实例成员变量？可以，因为它们都属于对象</li>
<li>实例方法是否可以直接访问静态成员变量？可以，静态成员变量可以被共享访问</li>
<li>实例方法是否可以直接访问实例方法? 可以，实例方法和实例方法都属于对象</li>
<li>实例方法是否可以直接访问静态方法？可以，静态方法可以被共享访问</li>
<li>静态方法是否可以直接访问实例变量？ 不可以，实例变量<strong>必须用对象访问</strong>！！</li>
<li>静态方法是否可以直接访问静态变量？ 可以，静态成员变量可以被共享访问。</li>
<li>静态方法是否可以直接访问实例方法? 不可以，实例方法必须用对象访问！！</li>
<li>静态方法是否可以直接访问静态方法？可以，静态方法可以被共享访问！！</li>
</ul>
<hr>
<h3> 继承</h3>
<h4> 基本介绍</h4>
<p>继承是 Java 中一般到特殊的关系，是一种子类到父类的关系</p>
<ul>
<li>被继承的类称为：父类/超类</li>
<li>继承父类的类称为：子类</li>
</ul>
<p>继承的作用：</p>
<ul>
<li><strong>提高代码的复用</strong>，相同代码可以定义在父类中</li>
<li>子类继承父类，可以直接使用父类这些代码（相同代码重复利用）</li>
<li>子类得到父类的属性（成员变量）和行为（方法），还可以定义自己的功能，子类更强大</li>
</ul>
<p>继承的特点：</p>
<ol>
<li>子类的全部构造器默认先访问父类的无参数构造器，再执行自己的构造器</li>
<li><strong>单继承</strong>：一个类只能继承一个直接父类</li>
<li>多层继承：一个类可以间接继承多个父类（家谱）</li>
<li>一个类可以有多个子类</li>
<li>一个类要么默认继承了 Object 类，要么间接继承了 Object 类，<strong>Object 类是 Java 中的祖宗类</strong></li>
</ol>
<p>继承的格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>子类不能继承父类的东西：</p>
<ul>
<li>子类不能继承父类的构造器，子类有自己的构造器</li>
<li>子类是不能可以继承父类的私有成员的，可以反射暴力去访问继承自父类的私有成员</li>
<li>子类是不能继承父类的静态成员，父类静态成员只有一份可以被子类共享访问，<strong>共享并非继承</strong></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 变量访问</h4>
<p>继承后成员变量的访问特点：<strong>就近原则</strong>，子类有找子类，子类没有找父类，父类没有就报错</p>
<p>如果要申明访问父类的成员变量可以使用：super.父类成员变量，super指父类引用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 方法访问</h4>
<p>子类继承了父类就得到了父类的方法，<strong>可以直接调用</strong>，受权限修饰符的限制，也可以重写方法</p>
<p>方法重写：子类重写一个与父类申明一样的方法来<strong>覆盖</strong>父类的该方法</p>
<p>方法重写的校验注解：@Override</p>
<ul>
<li>方法加了这个注解，那就必须是成功重写父类的方法，否则报错</li>
<li>@Override 优势：可读性好，安全，优雅</li>
</ul>
<p><strong>子类可以扩展父类的功能，但不能改变父类原有的功能</strong>，重写有以下三个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型</li>
<li>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</li>
</ul>
<p>继承中的隐藏问题：</p>
<ul>
<li>子类和父类方法都是静态的，那么子类中的方法会隐藏父类中的方法</li>
<li>在子类中可以定义和父类成员变量同名的成员变量，此时子类的成员变量隐藏了父类的成员变量，在创建对象为对象分配内存的过程中，<strong>隐藏变量依然会被分配内存</strong></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 常见问题</h4>
<ul>
<li>
<p>为什么子类构造器会先调用父类构造器？</p>
<ol>
<li>子类的构造器的第一行默认 super() 调用父类的无参数构造器，写不写都存在</li>
<li>子类继承父类，子类就得到了父类的属性和行为。调用子类构造器初始化子类对象数据时，必须先调用父类构造器初始化继承自父类的属性和行为</li>
<li>参考 JVM → 类加载 → 对象创建</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>为什么 Java 是单继承的？</strong></p>
<p>答：反证法，假如 Java 可以多继承，请看如下代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> super</h3>
<p>继承后 super 调用父类构造器，父类构造器初始化继承自父类的数据。</p>
<p>总结与拓展：</p>
<ul>
<li>this 代表了当前对象的引用（继承中指代子类对象）：this.子类成员变量、this.子类成员方法、<strong>this(...)</strong> 可以根据参数匹配访问本类其他构造器</li>
<li>super 代表了父类对象的引用（继承中指代了父类对象空间）：super.父类成员变量、super.父类的成员方法、super(...) 可以根据参数匹配访问父类的构造器</li>
</ul>
<p>注意：</p>
<ul>
<li>this(...) 借用本类其他构造器，super(...) 调用父类的构造器</li>
<li>this(...) 或 super(...) 必须放在构造器的第一行，否则报错</li>
<li>this(...) 和 super(...) <strong>不能同时出现</strong>在构造器中，因为构造函数必须出现在第一行上，只能选择一个</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> final</h3>
<h4> 基本介绍</h4>
<p>final 用于修饰：类，方法，变量</p>
<ul>
<li>final 修饰类，类不能被继承了，类中的方法和变量可以使用</li>
<li>final 可以修饰方法，方法就不能被重写</li>
<li>final 修饰变量总规则：变量有且仅能被赋值一次</li>
</ul>
<p>final 和 abstract 的关系是<strong>互斥关系</strong>，不能同时修饰类或者同时修饰方法</p>
<hr>
<h4> 修饰变量</h4>
<h5> 静态变量</h5>
<p>final 修饰静态成员变量，变量变成了常量</p>
<p>常量：有 public static final 修饰，名称字母全部大写，多个单词用下划线连接</p>
<p>final 修饰静态成员变量可以在哪些地方赋值：</p>
<ol>
<li>
<p>定义的时候赋值一次</p>
</li>
<li>
<p>可以在静态代码块中赋值一次</p>
</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 实例变量</h5>
<p>final 修饰变量的总规则：有且仅能被赋值一次</p>
<p>final 修饰实例成员变量可以在哪些地方赋值 1 次：</p>
<ol>
<li>定义的时候赋值一次</li>
<li>可以在实例代码块中赋值一次</li>
<li>可以在每个构造器中赋值一次</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 抽象类</h3>
<h4> 基本介绍</h4>
<blockquote>
<p>父类知道子类要完成某个功能，但是每个子类实现情况不一样</p>
</blockquote>
<p>抽象方法：没有方法体，只有方法签名，必须用 abstract 修饰的方法就是抽象方法</p>
<p>抽象类：拥有抽象方法的类必须定义成抽象类，必须用 abstract 修饰，<strong>抽象类是为了被继承</strong></p>
<p>一个类继承抽象类，<strong>必须重写抽象类的全部抽象方法</strong>，否则这个类必须定义成抽象类</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 常见问题</h4>
<p>一、抽象类是否有构造器，是否可以创建对象?</p>
<ul>
<li>抽象类有构造器，但是抽象类不能创建对象，类的其他成分它都具备，构造器提供给子类继承后调用父类构造器使用</li>
<li>抽象类中存在抽象方法，但不能执行，<strong>抽象类中也可没有抽象方法</strong></li>
</ul>
<blockquote>
<p>抽象在学术上本身意味着不能实例化</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>二、static 与 abstract 能同时使用吗？</p>
<p>答：不能，被 static 修饰的方法属于类，是类自己的东西，不是给子类来继承的，而抽象方法本身没有实现，就是用来给子类继承</p>
<hr>
<h4> 存在意义</h4>
<p><strong>被继承</strong>，抽象类就是为了被子类继承，否则抽象类将毫无意义（核心）</p>
<p>抽象类体现的是"模板思想"：<strong>部分实现，部分抽象</strong>，可以使用抽象类设计一个模板模式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 接口</h3>
<h4> 基本介绍</h4>
<p>接口是 Java 语言中一种引用类型，是方法的集合。</p>
<p>接口是更加彻底的抽象，接口中只有抽象方法和常量，没有其他成分</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>抽象方法：接口中的抽象方法默认会加上 public abstract 修饰，所以可以省略不写</p>
</li>
<li>
<p>静态方法：静态方法必须有方法体</p>
</li>
<li>
<p>常量：是 public static final 修饰的成员变量，仅能被赋值一次，值不能改变。常量的名称规范上要求全部大写，多个单词下划线连接，public static final 可以省略不写</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 实现接口</h4>
<p><strong>接口是用来被类实现的。</strong></p>
<ul>
<li>类与类是继承关系：一个类只能直接继承一个父类，单继承</li>
<li>类与接口是实现关系：一个类可以实现多个接口，多实现，接口不能继承类</li>
<li>接口与接口继承关系：<strong>多继承</strong></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现多个接口的使用注意事项：</p>
<ol>
<li>
<p>当一个类实现多个接口时，多个接口中存在同名的静态方法并不会冲突，只能通过各自接口名访问静态方法</p>
</li>
<li>
<p>当一个类实现多个接口时，多个接口中存在同名的默认方法，实现类必须重写这个方法</p>
</li>
<li>
<p>当一个类既继承一个父类，又实现若干个接口时，父类中成员方法与接口中默认方法重名，子类<strong>就近选择执行父类</strong>的成员方法</p>
</li>
<li>
<p>接口中，没有构造器，<strong>不能创建对象</strong>，接口是更彻底的抽象，连构造器都没有，自然不能创建对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<hr>
<h4> 新增功能</h4>
<p>jdk1.8 以后新增的功能：</p>
<ul>
<li>默认方法（就是普通实例方法）
<ul>
<li>必须用 default 修饰，默认会 public 修饰</li>
<li>必须用接口的实现类的对象来调用</li>
<li>必须有默认实现</li>
</ul>
</li>
<li>静态方法
<ul>
<li>默认会 public 修饰</li>
<li>接口的静态方法必须用接口的类名本身来调用</li>
<li>调用格式：ClassName.method()</li>
<li>必须有默认实现</li>
</ul>
</li>
<li>私有方法：JDK 1.9 才开始有的，只能在<strong>本类中</strong>被其他的默认方法或者私有方法访问</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 对比抽象类</h4>
<table>
<thead>
<tr>
<th><strong>参数</strong></th>
<th><strong>抽象类</strong></th>
<th><strong>接口</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>默认的方法实现</td>
<td>可以有默认的方法实现</td>
<td>接口完全是抽象的，jdk8 以后有默认的实现</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用 <strong>extends</strong> 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。</td>
<td>子类使用关键字 <strong>implements</strong> 来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>与正常Java类的区别</td>
<td>除了不能实例化抽象类之外，和普通 Java 类没有任何区别</td>
<td>接口是完全不同的类型</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象方法有 <strong>public</strong>、<strong>protected</strong> 和 <strong>default</strong> 这些修饰符</td>
<td>接口默认修饰符是 <strong>public</strong>，别的修饰符需要有方法体</td>
</tr>
<tr>
<td>main方法</td>
<td>抽象方法可以有 main 方法并且我们可以运行它</td>
<td>jdk8 以前接口没有 main 方法，不能运行；jdk8 以后接口可以有 default 和 static 方法，可以运行 main 方法</td>
</tr>
<tr>
<td>多继承</td>
<td>抽象方法可以继承一个类和实现多个接口</td>
<td>接口可以继承一个或多个其它接口，接口不可继承类</td>
</tr>
<tr>
<td>速度</td>
<td>比接口速度要快</td>
<td>接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法</td>
</tr>
<tr>
<td>添加新方法</td>
<td>如果往抽象类中添加新的方法，可以给它提供默认的实现，因此不需要改变现在的代码</td>
<td>如果往接口中添加方法，那么必须改变实现该接口的类</td>
</tr>
</tbody>
</table>
<hr>
<h3> 多态</h3>
<h4> 基本介绍</h4>
<p>多态的概念：同一个实体同时具有多种形式同一个类型的对象，执行同一个行为，在不同的状态下会表现出不同的行为特征</p>
<p>多态的格式：</p>
<ul>
<li>父类类型范围 &gt; 子类类型范围</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>多态的执行：</p>
<ul>
<li>对于方法的调用：<strong>编译看左边，运行看右边</strong>（分派机制）</li>
<li>对于变量的调用：<strong>编译看左边，运行看左边</strong></li>
</ul>
<p>多态的使用规则：</p>
<ul>
<li>必须存在继承或者实现关系</li>
<li>必须存在父类类型的变量引用子类类型的对象</li>
<li>存在方法重写</li>
</ul>
<p>多态的优势：</p>
<ul>
<li>在多态形式下，右边对象可以实现组件化切换，便于扩展和维护，也可以实现类与类之间的<strong>解耦</strong></li>
<li>父类类型作为方法形式参数，传递子类对象给方法，可以传入一切子类对象进行方法的调用，更能体现出多态的<strong>扩展性</strong>与便利性</li>
</ul>
<p>多态的劣势：</p>
<ul>
<li>多态形式下，不能直接调用子类特有的功能，因为编译看左边，父类中没有子类独有的功能，所以代码在编译阶段就直接报错了</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 上下转型</h4>
<blockquote>
<p>基本数据类型的转换：</p>
<ol>
<li>小范围类型的变量或者值可以直接赋值给大范围类型的变量</li>
<li>大范围类型的变量或者值必须强制类型转换给小范围类型的变量</li>
</ol>
</blockquote>
<p>引用数据类型的<strong>自动</strong>类型转换语法：子类类型的对象或者变量可以自动类型转换赋值给父类类型的变量</p>
<p><strong>父类引用指向子类对象</strong></p>
<ul>
<li><strong>向上转型 (upcasting)</strong>：通过子类对象（小范围）实例化父类对象（大范围），这种属于自动转换</li>
<li><strong>向下转型 (downcasting)</strong>：通过父类对象（大范围）实例化子类对象（小范围），这种属于强制转换</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> instanceof</h4>
<p>instanceof：判断左边的对象是否是右边的类的实例，或者是其直接或间接子类，或者是其接口的实现类</p>
<ul>
<li>引用类型强制类型转换：父类类型的变量或者对象强制类型转换成子类类型的变量，否则报错</li>
<li>强制类型转换的格式：<strong>类型 变量名称 = (类型)(对象或者变量)</strong></li>
<li>有继承/实现关系的两个类型就可以进行强制类型转换，编译阶段一定不报错，但是运行阶段可能出现类型转换异常 ClassCastException</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 内部类</h3>
<h4> 概述</h4>
<p>内部类是类的五大成分之一：成员变量，方法，构造器，代码块，内部类</p>
<p>概念：定义在一个类里面的类就是内部类</p>
<p>作用：提供更好的封装性，体现出组件思想，<strong>间接解决类无法多继承引起的一系列问题</strong></p>
<p>分类：静态内部类、实例内部类（成员内部类）、局部内部类、<strong>匿名内部类</strong>（重点）</p>
<hr>
<h4> 静态内部类</h4>
<p>定义：有 static 修饰，属于外部类本身，会加载一次</p>
<p>静态内部类中的成分研究：</p>
<ul>
<li>类有的成分它都有，静态内部类属于外部类本身，只会加载一次</li>
<li>特点与外部类是完全一样的，只是位置在别人里面</li>
<li>可以定义静态成员</li>
</ul>
<p>静态内部类的访问格式：外部类名称.内部类名称</p>
<p>静态内部类创建对象的格式：外部类名称.内部类名称 对象名称 = new 外部类名称.内部类构造器</p>
<p>静态内部类的访问拓展：</p>
<ul>
<li>静态内部类中是否可以直接访问外部类的静态成员?	可以，外部类的静态成员只有一份，可以被共享</li>
<li>静态内部类中是否可以直接访问外部类的实例成员?	不可以，外部类的成员必须用外部类对象访问</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 实例内部类</h4>
<p>定义：无 static 修饰的内部类，属于外部类的每个对象，跟着外部类对象一起加载</p>
<p>实例内部类的成分特点：实例内部类中不能定义静态成员，其他都可以定义</p>
<p>实例内部类的访问格式：外部类名称.内部类名称</p>
<p>创建对象的格式：外部类名称.内部类名称 对象名称 = new 外部类构造器.new 内部构造器</p>
<ul>
<li><code>Outter.Inner in = new Outter().new Inner()</code></li>
</ul>
<p><strong>实例内部类可以访问外部类的全部成员</strong></p>
<ul>
<li>实例内部类中可以直接访问外部类的静态成员，外部类的静态成员可以被共享访问</li>
<li>实例内部类中可以访问外部类的实例成员，实例内部类属于外部类对象，可以直接访问外部类对象的实例成员</li>
</ul>
<hr>
<h4> 局部内部类</h4>
<p>局部内部类：定义在方法中，在构造器中，代码块中，for 循环中定义的内部类</p>
<p>局部内部类中的成分特点：只能定义实例成员，不能定义静态成员</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 匿名内部类</h4>
<p>匿名内部类：没有名字的局部内部类</p>
<p>匿名内部类的格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>匿名内部类的特点：</p>
<ul>
<li>匿名内部类不能定义静态成员</li>
<li>匿名内部类一旦写出来，就会立即创建一个匿名内部类的对象返回</li>
<li><strong>匿名内部类的对象的类型相当于是当前 new 的那个的类型的子类类型</strong></li>
<li>匿名内部类引用局部变量必须是<strong>常量</strong>，底层创建为内部类的成员变量（原因：JVM → 运行机制 → 代码优化）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 权限符</h3>
<p>权限修饰符：有四种**（private -&gt; 缺省 -&gt; protected - &gt; public ）**<br>
可以修饰成员变量，修饰方法，修饰构造器，内部类，不同修饰符修饰的成员能够被访问的权限将受到限制</p>
<table>
<thead>
<tr>
<th>四种修饰符访问权限</th>
<th style="text-align:center">private</th>
<th style="text-align:center">缺省</th>
<th style="text-align:center">protected</th>
<th style="text-align:center">public</th>
</tr>
</thead>
<tbody>
<tr>
<td>本类中</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>本包下的子类中</td>
<td style="text-align:center">X</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>本包下其他类中</td>
<td style="text-align:center">X</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>其他包下的子类中</td>
<td style="text-align:center">X</td>
<td style="text-align:center">X</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td>其他包下的其他类中</td>
<td style="text-align:center">X</td>
<td style="text-align:center">X</td>
<td style="text-align:center">X</td>
<td style="text-align:center">√</td>
</tr>
</tbody>
</table>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见</p>
<ul>
<li>基类的 protected 成员是包内可见的，并且对子类可见</li>
<li>若子类与基类不在同一包中，那么子类实例可以访问其从基类继承而来的 protected 方法（重写），而不能访问基类实例的 protected 方法</li>
</ul>
<hr>
<h3> 代码块</h3>
<h4> 静态代码块</h4>
<p>静态代码块的格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>静态代码块特点：
<ul>
<li>必须有 static 修饰，只能访问静态资源</li>
<li>会与类一起优先加载，且自动触发执行一次</li>
</ul>
</li>
<li>静态代码块作用：
<ul>
<li>可以在执行类的方法等操作之前先在静态代码块中进行静态资源的初始化</li>
<li><strong>先执行静态代码块，在执行 main 函数里的操作</strong></li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 实例代码块</h4>
<p>实例代码块的格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>实例代码块的特点：</p>
<ul>
<li>无 static 修饰，属于对象</li>
<li>会与类的对象一起加载，每次创建类的对象的时候，实例代码块都会被加载且自动触发执行一次</li>
<li>实例代码块的代码在底层实际上是提取到每个构造器中去执行的</li>
</ul>
</li>
<li>
<p>实例代码块的作用：实例代码块可以在创建对象之前进行实例资源的初始化操作</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> API</h2>
<h3> Object</h3>
<h4> 基本介绍</h4>
<p>Object 类是 Java 中的祖宗类，一个类或者默认继承 Object 类，或者间接继承 Object 类，Object 类的方法是一切子类都可以直接使用</p>
<p>Object 类常用方法：</p>
<ul>
<li><code>public String toString()</code>：默认是返回当前对象在堆内存中的地址信息：类的全限名@内存地址，例：Student@735b478；
<ul>
<li>直接输出对象名称，默认会调用 toString() 方法，所以省略 toString() 不写；</li>
<li>如果输出对象的内容，需要重写 toString() 方法，toString 方法存在的意义是为了被子类重写</li>
</ul>
</li>
<li><code>public boolean equals(Object o)</code>：默认是比较两个对象的引用是否相同</li>
<li><code>protected Object clone()</code>：创建并返回此对象的副本</li>
</ul>
<p>只要两个对象的内容一样，就认为是相等的：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>面试题</strong>：== 和 equals 的区别</p>
<ul>
<li>== 比较的是变量（栈）内存中存放的对象的（堆）内存地址，用来判断两个对象的<strong>地址</strong>是否相同，即是否是指相同一个对象，比较的是真正意义上的指针操作</li>
<li>Object 类中的方法，<strong>默认比较两个对象的引用</strong>，重写 equals 方法比较的是两个对象的<strong>内容</strong>是否相等，所有的类都是继承自 java.lang.Object 类，所以适用于所有对象</li>
</ul>
<p>hashCode 的作用：</p>
<ul>
<li>hashCode 的存在主要是用于查找的快捷性，如 Hashtable，HashMap 等，可以在散列存储结构中确定对象的存储地址</li>
<li>如果两个对象相同，就是适用于 equals(java.lang.Object) 方法，那么这两个对象的 hashCode 一定要相同</li>
<li>哈希值相同的数据不一定内容相同，内容相同的数据哈希值一定相同</li>
</ul>
<hr>
<h4> 深浅克隆</h4>
<p>Object 的 clone() 是 protected 方法，一个类不显式去重写 clone()，就不能直接去调用该类实例的 clone() 方法</p>
<p>深浅拷贝（克隆）的概念：</p>
<ul>
<li>
<p>浅拷贝 (shallowCopy)：<strong>对基本数据类型进行值传递，对引用数据类型只是复制了引用</strong>，被复制对象属性的所有的引用仍然指向原来的对象，简而言之就是增加了一个指针指向原来对象的内存地址</p>
<p><strong>Java 中的复制方法基本都是浅拷贝</strong>：Object.clone()、System.arraycopy()、Arrays.copyOf()</p>
</li>
<li>
<p>深拷贝 (deepCopy)：对基本数据类型进行值传递，对引用数据类型是一个整个独立的对象拷贝，会拷贝所有的属性并指向的动态分配的内存，简而言之就是把所有属性复制到一个新的内存，增加一个指针指向新内存。所以使用深拷贝的情况下，释放内存的时候不会出现使用浅拷贝时释放同一块内存的错误</p>
</li>
</ul>
<p>Cloneable 接口是一个标识性接口，即该接口不包含任何方法（包括 clone），但是如果一个类想合法的进行克隆，那么就必须实现这个接口，在使用 clone() 方法时，若该类未实现 Cloneable 接口，则抛出异常</p>
<ul>
<li>
<p>Clone &amp; Copy：<code>Student s = new Student</code></p>
<p><code>Student s1 = s</code>：只是 copy 了一下 reference，s 和 s1 指向内存中同一个 Object，对对象的修改会影响对方</p>
<p><code>Student s2 = s.clone()</code>：会生成一个新的 Student 对象，并且和 s 具有相同的属性值和方法</p>
</li>
<li>
<p>Shallow Clone &amp; Deep Clone：</p>
<p>浅克隆：Object 中的 clone() 方法在对某个对象克隆时对其仅仅是简单地执行域对域的 copy</p>
<ul>
<li>对基本数据类型和包装类的克隆是没有问题的。String、Integer 等包装类型在内存中是<strong>不可以被改变的对象</strong>，所以在使用克隆时可以视为基本类型，只需浅克隆引用即可</li>
<li>如果对一个引用类型进行克隆时只是克隆了它的引用，和原始对象共享对象成员变量</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Object浅克隆.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>深克隆：在对整个对象浅克隆后，对其引用变量进行克隆，并将其更新到浅克隆对象中去</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>SDP → 创建型 → 原型模式</p>
<hr>
<h3> Objects</h3>
<p>Objects 类与 Object 是继承关系</p>
<p>Objects 的方法：</p>
<ul>
<li>
<p><code>public static boolean equals(Object a, Object b)</code>：比较两个对象是否相同</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><code>public static boolean isNull(Object obj)</code>：判断变量是否为 null ，为 null 返回 true</p>
</li>
<li>
<p><code>public static String toString(对象)</code>：返回参数中对象的字符串表示形式</p>
</li>
<li>
<p><code>public static String toString(对象, 默认字符串)</code>：返回对象的字符串表示形式</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> String</h3>
<h4> 基本介绍</h4>
<p>String 被声明为 final，因此不可被继承 <strong>（Integer 等包装类也不能被继承）</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串，同时使用 <code>coder</code> 来标识使用了哪种编码</p>
<p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组，并且 String 内部没有改变 value 数组的方法，因此可以<strong>保证 String 不可变，也保证线程安全</strong></p>
<p>注意：不能改变的意思是<strong>每次更改字符串都会产生新的对象</strong>，并不是对原始对象进行改变</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 常用方法</h4>
<p>常用 API：</p>
<ul>
<li>
<p><code>public boolean equals(String s)</code>：比较两个字符串内容是否相同、区分大小写</p>
</li>
<li>
<p><code>public boolean equalsIgnoreCase(String anotherString)</code>：比较字符串的内容，忽略大小写</p>
</li>
<li>
<p><code>public int length()</code>：返回此字符串的长度</p>
</li>
<li>
<p><code>public String trim()</code>：返回一个字符串，其值为此字符串，并删除任何前导和尾随空格</p>
</li>
<li>
<p><code>public String[] split(String regex)</code>：将字符串按给定的正则表达式分割成字符串数组</p>
</li>
<li>
<p><code>public char charAt(int index)</code>：取索引处的值</p>
</li>
<li>
<p><code>public char[] toCharArray()</code>：将字符串拆分为字符数组后返回</p>
</li>
<li>
<p><code>public boolean startsWith(String prefix)</code>：测试此字符串是否以指定的前缀开头</p>
</li>
<li>
<p><code>public int indexOf(String str)</code>：返回指定子字符串第一次出现的字符串内的索引，没有返回 -1</p>
</li>
<li>
<p><code>public int lastIndexOf(String str)</code>：返回字符串最后一次出现 str 的索引，没有返回 -1</p>
</li>
<li>
<p><code>public String substring(int beginIndex)</code>：返回子字符串，以原字符串指定索引处到结尾</p>
</li>
<li>
<p><code>public String substring(int i, int j)</code>：指定索引处扩展到 j - 1 的位置，字符串长度为 j - i</p>
</li>
<li>
<p><code>public String toLowerCase()</code>：将此 String 所有字符转换为小写，使用默认语言环境的规则</p>
</li>
<li>
<p><code>public String toUpperCase()</code>：使用默认语言环境的规则将此 String 所有字符转换为大写</p>
</li>
<li>
<p><code>public String replace(CharSequence target, CharSequence replacement)</code>：使用新值，将字符串中的旧值替换，得到新的字符串</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 构造方式</h4>
<p>构造方法：</p>
<ul>
<li><code>public String()</code>：创建一个空白字符串对象，不含有任何内容</li>
<li><code>public String(char[] chs)</code>：根据字符数组的内容，来创建字符串对象</li>
<li><code>public String(String original)</code>：根据传入的字符串内容，来创建字符串对象</li>
</ul>
<p>直接赋值：<code>String s = "abc"</code> 直接赋值的方式创建字符串对象，内容就是 abc</p>
<ul>
<li>通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，虽然内容相同，但是地址值不同，<strong>返回堆内存中对象的引用</strong></li>
<li>直接赋值方式创建：以 <code>" "</code> 方式给出的字符串，只要字符序列相同（顺序和大小写），无论在程序代码中出现几次，JVM 都只会<strong>在 String Pool 中创建一个字符串对象</strong>，并在字符串池中维护</li>
</ul>
<p><code>String str = new String("abc")</code> 创建字符串对象：</p>
<ul>
<li>创建一个对象：字符串池中已经存在 abc 对象，那么直接在创建一个对象放入堆中，返回堆内引用</li>
<li>创建两个对象：字符串池中未找到 abc 对象，那么分别在堆中和字符串池中创建一个对象，字符串池中的比较都是采用 equals()<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String构造方法字节码.png" style="zoom: 67%;"></li>
</ul>
<p><code>new String("a") + new String("b")</code> 创建字符串对象：</p>
<ul>
<li>
<p>对象 1：new StringBuilder()</p>
</li>
<li>
<p>对象 2：new String("a")、对象 3：常量池中的 a</p>
</li>
<li>
<p>对象 4：new String("b")、对象 5：常量池中的 b<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/String拼接方法字节码.png" style="zoom:67%;"></p>
</li>
<li>
<p>StringBuilder 的 toString()：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>对象 6：new String("ab")</li>
<li>StringBuilder 的 toString() 调用，<strong>在字符串常量池中没有生成 ab</strong>，new String("ab") 会创建两个对象因为传参数的时候使用字面量创建了对象 ab，当使用数组构造 String 对象时，没有加入常量池的操作</li>
</ul>
</li>
</ul>
<hr>
<h4> String Pool</h4>
<h5> 基本介绍</h5>
<p>字符串常量池（String Pool / StringTable / 串池）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定，常量池类似于 Java 系统级别提供的<strong>缓存</strong>，存放对象和引用</p>
<ul>
<li>StringTable，类似 HashTable 结构，通过 <code>-XX:StringTableSize</code> 设置大小，JDK 1.8 中默认 60013</li>
<li>常量池中的字符串仅是符号，第一次使用时才变为对象，可以避免重复创建字符串对象</li>
<li>字符串<strong>变量</strong>的拼接的原理是 StringBuilder#append，append 方法比字符串拼接效率高（JDK 1.8）</li>
<li>字符串<strong>常量</strong>拼接的原理是编译期优化，拼接结果放入常量池</li>
<li>可以使用 String 的 intern() 方法在运行过程将字符串添加到 String Pool 中</li>
</ul>
<hr>
<h5> intern()</h5>
<p>JDK 1.8：当一个字符串调用 intern() 方法时，如果 String Pool 中：</p>
<ul>
<li>存在一个字符串和该字符串值相等，就会返回 String Pool 中字符串的引用（需要变量接收）</li>
<li>不存在，会把对象的<strong>引用地址</strong>复制一份放入串池，并返回串池中的引用地址，前提是堆内存有该对象，因为 Pool 在堆中，为了节省内存不再创建新对象</li>
</ul>
<p>JDK 1.6：将这个字符串对象尝试放入串池，如果有就不放入，返回已有的串池中的对象的引用；如果没有会把此对象复制一份，放入串池，把串池中的对象返回</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>== 比较基本数据类型：比较的是具体的值</li>
<li>== 比较引用数据类型：比较的是对象地址值</li>
</ul>
<p>结论：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 常见问题</h5>
<p>问题一：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问题二：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原因：</p>
<ul>
<li>
<p>System 类当调用 Version 的静态方法，导致 Version 初始化：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Version 类初始化时需要对静态常量字段初始化，被 launcher_name 静态常量字段所引用的 <code>"java"</code> 字符串字面量就被放入的字符串常量池：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h5> 内存位置</h5>
<p>Java 7 之前，String Pool 被放在运行时常量池中，属于永久代；Java 7 以后，String Pool 被移到堆中，这是因为永久代的空间有限，在大量使用字符串的场景下会导致 OutOfMemoryError 错误</p>
<p>演示 StringTable 位置：</p>
<ul>
<li>
<p><code>-Xmx10m</code> 设置堆内存 10m</p>
</li>
<li>
<p>在 JDK8 下设置： <code>-Xmx10m -XX:-UseGCOverheadLimit</code>（运行参数在 Run Configurations VM options）</p>
</li>
<li>
<p>在 JDK6 下设置： <code>-XX:MaxPermSize=10m</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/JVM-内存图对比.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 优化常量池</h4>
<p>两种方式：</p>
<ul>
<li>
<p>调整 -XX:StringTableSize=桶个数，数量越少，性能越差</p>
</li>
<li>
<p>intern 将字符串对象放入常量池，通过复用字符串的引用，减少内存占用</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 不可变好处</h4>
<ul>
<li>可以缓存 hash 值，例如 String 用做 HashMap 的 key，不可变的特性可以使得 hash 值也不可变，只要进行一次计算</li>
<li>String Pool 的需要，如果一个 String 对象已经被创建过了，就会从 String Pool 中取得引用，只有 String 是不可变的，才可能使用 String Pool</li>
<li>安全性，String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 的那一方以为现在连接的是其它主机，而实际情况却不一定是</li>
<li>String 不可变性天生具备线程安全，可以在多个线程中安全地使用</li>
<li>防止子类继承，破坏 String 的 API 的使用</li>
</ul>
<hr>
<h3> StringBuilder</h3>
<p>String StringBuffer 和 StringBuilder 区别：</p>
<ul>
<li>String : <strong>不可变</strong>的字符序列，线程安全</li>
<li>StringBuffer : <strong>可变</strong>的字符序列，线程安全，底层方法加 synchronized，效率低</li>
<li>StringBuilder : <strong>可变</strong>的字符序列，JDK5.0 新增；线程不安全，效率高</li>
</ul>
<p>相同点：底层使用 char[] 存储</p>
<p>构造方法：</p>
<ul>
<li><code>public StringBuilder()</code>：创建一个空白可变字符串对象，不含有任何内容</li>
<li><code>public StringBuilder(String str)</code>：根据字符串的内容，来创建可变字符串对象</li>
</ul>
<p>常用API :</p>
<ul>
<li><code>public StringBuilder append(任意类型)</code>：添加数据，并返回对象本身</li>
<li><code>public StringBuilder reverse()</code>：返回相反的字符序列</li>
<li><code>public String toString()</code>：通过 toString() 就可以实现把 StringBuilder 转换为 String</li>
</ul>
<p>存储原理：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>append 源码：扩容为二倍</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Arrays</h3>
<p>Array 的工具类 Arrays</p>
<p>常用API：</p>
<ul>
<li><code>public static String toString(int[] a)</code>：返回指定数组的内容的字符串表示形式</li>
<li><code>public static void sort(int[] a)</code>：按照数字顺序排列指定的数组</li>
<li><code>public static int binarySearch(int[] a, int key)</code>：利用二分查找返回指定元素的索引</li>
<li><code>public static &lt;T&gt; List&lt;T&gt; asList(T... a)</code>：返回由指定数组支持的列表</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Random</h3>
<p>用于生成伪随机数。</p>
<p>使用步骤：</p>
<ol>
<li>
<p>导入包：<code>import java.util.Random</code></p>
</li>
<li>
<p>创建对象：<code>Random r = new Random()</code></p>
</li>
<li>
<p>随机整数：<code>int num = r.nextInt(10)</code></p>
<ul>
<li>解释：10 代表的是一个范围，如果括号写 10，产生的随机数就是 0 - 9，括号写 20 的随机数则是 0 - 19</li>
<li>获取 0 - 10：<code>int num = r.nextInt(10 + 1)</code></li>
</ul>
</li>
<li>
<p>随机小数：<code>public double nextDouble()</code> 从范围 <code>0.0d</code> 至 <code>1.0d</code> （左闭右开），伪随机地生成并返回</p>
</li>
</ol>
<hr>
<h3> System</h3>
<p>System 代表当前系统</p>
<p>静态方法：</p>
<ul>
<li>
<p><code>public static void exit(int status)</code>：终止 JVM 虚拟机，<strong>非 0 是异常终止</strong></p>
</li>
<li>
<p><code>public static long currentTimeMillis()</code>：获取当前系统此刻时间毫秒值</p>
</li>
<li>
<p><code>static void arraycopy(Object var0, int var1, Object var2, int var3, int var4)</code>：数组拷贝</p>
<ul>
<li>参数一：原数组</li>
<li>参数二：从原数组的哪个位置开始赋值</li>
<li>参数三：目标数组</li>
<li>参数四：从目标数组的哪个位置开始赋值</li>
<li>参数五：赋值几个</li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Date</h3>
<p>构造器：</p>
<ul>
<li><code>public Date()</code>：创建当前系统的此刻日期时间对象。</li>
<li><code>public Date(long time)</code>：把时间毫秒值转换成日期对象</li>
</ul>
<p>方法：</p>
<ul>
<li><code>public long getTime()</code>：返回自 1970 年 1 月 1 日 00:00:00 GMT 以来总的毫秒数。</li>
</ul>
<p>时间记录的两种方式：</p>
<ol>
<li>Date 日期对象</li>
<li>时间毫秒值：从 <code>1970-01-01 00:00:00</code> 开始走到此刻的总的毫秒值，1s = 1000ms</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> DateFormat</h3>
<p>DateFormat 作用：</p>
<ol>
<li>可以把“日期对象”或者“时间毫秒值”格式化成我们喜欢的时间形式（格式化时间）</li>
<li>可以把字符串的时间形式解析成日期对象（解析字符串时间）</li>
</ol>
<p>DateFormat 是一个抽象类，不能直接使用，使用它的子类：SimpleDateFormat</p>
<p>SimpleDateFormat  简单日期格式化类：</p>
<ul>
<li><code>public SimpleDateFormat(String pattern)</code>：指定时间的格式创建简单日期对象</li>
<li><code>public String format(Date date) </code>：把日期对象格式化成我们喜欢的时间形式，返回字符串</li>
<li><code>public String format(Object time)</code>：把时间毫秒值格式化成设定的时间形式，返回字符串!</li>
<li><code>public Date parse(String date)</code>：把字符串的时间解析成日期对象</li>
</ul>
<blockquote>
<p>yyyy年MM月dd日 HH:mm:ss EEE a" 周几 上午下午</p>
</blockquote>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Calendar</h3>
<p>Calendar 代表了系统此刻日期对应的日历对象，是一个抽象类，不能直接创建对象</p>
<p>Calendar 日历类创建日历对象：<code>Calendar rightNow = Calendar.getInstance()</code>（<strong>饿汉单例模式</strong>）</p>
<p>Calendar 的方法：</p>
<ul>
<li><code>public static Calendar getInstance()</code>：返回一个日历类的对象</li>
<li><code>public int get(int field)</code>：取日期中的某个字段信息</li>
<li><code>public void set(int field,int value)</code>：修改日历的某个字段信息</li>
<li><code>public void add(int field,int amount)</code>：为某个字段增加/减少指定的值</li>
<li><code>public final Date getTime()</code>：拿到此刻日期对象</li>
<li><code>public long getTimeInMillis()</code>：拿到此刻时间毫秒值</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> LocalDateTime</h3>
<p>JDK1.8 新增，线程安全</p>
<ul>
<li>LocalDate       表示日期（年月日）</li>
<li>LocalTime       表示时间（时分秒）</li>
<li>LocalDateTime    表示时间+ 日期 （年月日时分秒）</li>
</ul>
<p>构造方法：</p>
<ul>
<li>public static LocalDateTime now()：获取当前系统时间</li>
<li>public static LocalDateTime of(年, 月 , 日, 时, 分, 秒)：使用指定年月日和时分秒初始化一个对象</li>
</ul>
<p>常用API：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public int getYear()</td>
<td>获取年</td>
</tr>
<tr>
<td>public int getMonthValue()</td>
<td>获取月份（1-12）</td>
</tr>
<tr>
<td>public int getDayOfMonth()</td>
<td>获取月份中的第几天（1-31）</td>
</tr>
<tr>
<td>public int getDayOfYear()</td>
<td>获取一年中的第几天（1-366）</td>
</tr>
<tr>
<td>public DayOfWeek getDayOfWeek()</td>
<td>获取星期</td>
</tr>
<tr>
<td>public int getMinute()</td>
<td>获取分钟</td>
</tr>
<tr>
<td>public int getHour()</td>
<td>获取小时</td>
</tr>
<tr>
<td>public LocalDate  toLocalDate()</td>
<td>转换成为一个 LocalDate 对象（年月日）</td>
</tr>
<tr>
<td>public LocalTime toLocalTime()</td>
<td>转换成为一个 LocalTime 对象（时分秒）</td>
</tr>
<tr>
<td>public String format(指定格式)</td>
<td>把一个 LocalDateTime 格式化成为一个字符串</td>
</tr>
<tr>
<td>public LocalDateTime parse(准备解析的字符串, 解析格式)</td>
<td>把一个日期字符串解析成为一个 LocalDateTime 对象</td>
</tr>
<tr>
<td>public static DateTimeFormatter ofPattern(String pattern)</td>
<td>使用指定的日期模板获取一个日期格式化器 DateTimeFormatter 对象</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public LocalDateTime plusYears (long years)</td>
<td>添加或者减去年</td>
</tr>
<tr>
<td>public LocalDateTime withYear(int year)</td>
<td>直接修改年</td>
</tr>
</tbody>
</table>
<p><strong>时间间隔</strong> Duration 类API：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static Period between(开始时间,结束时间)</td>
<td>计算两个“时间"的间隔</td>
</tr>
<tr>
<td>public int getYears()</td>
<td>获得这段时间的年数</td>
</tr>
<tr>
<td>public int getMonths()</td>
<td>获得此期间的总月数</td>
</tr>
<tr>
<td>public int getDays()</td>
<td>获得此期间的天数</td>
</tr>
<tr>
<td>public long toTotalMonths()</td>
<td>获取此期间的总月数</td>
</tr>
<tr>
<td>public static Durationbetween(开始时间,结束时间)</td>
<td>计算两个“时间"的间隔</td>
</tr>
<tr>
<td>public long toSeconds()</td>
<td>获得此时间间隔的秒</td>
</tr>
<tr>
<td>public long toMillis()</td>
<td>获得此时间间隔的毫秒</td>
</tr>
<tr>
<td>public long toNanos()</td>
<td>获得此时间间隔的纳秒</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Math</h3>
<p>Math 用于做数学运算</p>
<p>Math 类中的方法全部是静态方法，直接用类名调用即可：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static int abs(int a)</td>
<td>获取参数a的绝对值</td>
</tr>
<tr>
<td>public static double ceil(double a)</td>
<td>向上取整</td>
</tr>
<tr>
<td>public static double floor(double a)</td>
<td>向下取整</td>
</tr>
<tr>
<td>public static double pow(double a, double b)</td>
<td>获取 a 的 b 次幂</td>
</tr>
<tr>
<td>public static long round(double a)</td>
<td>四舍五入取整</td>
</tr>
<tr>
<td>public static int max(int a,int b)</td>
<td>返回较大值</td>
</tr>
<tr>
<td>public static int min(int a,int b)</td>
<td>返回较小值</td>
</tr>
<tr>
<td>public static double random()</td>
<td>返回值为 double 的正值，<code>[0.0,1.0)</code></td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> DecimalFormat</h3>
<p>使任何形式的数字解析和格式化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> BigDecimal</h3>
<p>Java 在 java.math 包中提供的 API 类，用来对超过16位有效位的数进行精确的运算</p>
<p>构造方法：</p>
<ul>
<li><code>public static BigDecimal valueOf(double val)</code>：包装浮点数成为大数据对象。</li>
<li><code>public BigDecimal(double val)</code></li>
<li><code>public BigDecimal(String val)</code></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>public BigDecimal add(BigDecimal value)</code>：加法运算</li>
<li><code>public BigDecimal subtract(BigDecimal value)</code>：减法运算</li>
<li><code>public BigDecimal multiply(BigDecimal value)</code>：乘法运算</li>
<li><code>public BigDecimal divide(BigDecimal value)</code>：除法运算</li>
<li><code>public double doubleValue()</code>：把 BigDecimal 转换成 double 类型</li>
<li><code>public int intValue()</code>：转为 int 其他类型相同</li>
<li><code>public BigDecimal divide (BigDecimal value，精确几位，舍入模式)</code>：除法</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：</p>
<ol>
<li>BigDecimal 是用来进行精确计算的</li>
<li>创建 BigDecimal 的对象，构造方法使用参数类型为字符串的</li>
<li>四则运算中的除法，如果除不尽请使用 divide 的三个参数的方法</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Regex</h3>
<h4> 概述</h4>
<p>正则表达式的作用：是一些特殊字符组成的校验规则，可以校验信息的正确性，校验邮箱、电话号码、金额等。</p>
<p>比如检验 qq 号：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>java.util.regex 包主要包括以下三个类：</p>
<ul>
<li>
<p>Pattern 类：</p>
<p>Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法，要创建一个 Pattern 对象，必须首先调用其公共静态编译方法，返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数</p>
</li>
<li>
<p>Matcher 类：</p>
<p>Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法，需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象</p>
</li>
<li>
<p>PatternSyntaxException：</p>
<p>PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。</p>
</li>
</ul>
<hr>
<h4> 字符匹配</h4>
<h5> 普通字符</h5>
<p>字母、数字、汉字、下划线、以及没有特殊定义的标点符号，都是“普通字符”。表达式中的普通字符，在匹配一个字符串的时候，匹配与之相同的一个字符。其他统称<strong>元字符</strong></p>
<hr>
<h5> 特殊字符</h5>
<p>\r\n 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td>将下一个字符标记为一个特殊字符或原义字符，告诉它是一个校验类，不是普通字符</td>
</tr>
<tr>
<td>\f</td>
<td>换页符</td>
</tr>
<tr>
<td>\n</td>
<td>换行符</td>
</tr>
<tr>
<td>\r</td>
<td>回车符</td>
</tr>
<tr>
<td>\t</td>
<td>制表符</td>
</tr>
<tr>
<td>\</td>
<td>代表 \ 本身</td>
</tr>
<tr>
<td>()</td>
<td>使用 () 定义一个子表达式。子表达式的内容可以当成一个独立元素</td>
</tr>
</tbody>
</table>
<hr>
<h5> 标准字符</h5>
<p>能够与多种字符匹配的表达式，注意区分大小写，大写是相反的意思，只能校验<strong>单</strong>个字符。</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配任意一个字符（除了换行符），如果要匹配包括 \n 在内的所有字符，一般用 [\s\S]</td>
</tr>
<tr>
<td>\d</td>
<td>数字字符，0~9 中的任意一个，等价于 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>非数字字符，等价于  [ ^0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>大小写字母或数字或下划线，等价于[a-zA-Z_0-9_]</td>
</tr>
<tr>
<td>\W</td>
<td>对\w取非，等价于[ ^\w]</td>
</tr>
<tr>
<td>\s</td>
<td>空格、制表符、换行符等空白字符的其中任意一个，等价于[\f\n\r\t\v]</td>
</tr>
<tr>
<td>\S</td>
<td>对 \s 取非</td>
</tr>
</tbody>
</table>
<p>\x 匹配十六进制字符，\0 匹配八进制，例如 \xA 对应值为 10 的 ASCII 字符 ，即 \n</p>
<hr>
<h5> 自定义符</h5>
<p>自定义符号集合，[ ] 方括号匹配方式，能够匹配方括号中<strong>任意一个</strong>字符</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>[ab5@]</td>
<td>匹配 "a" 或 "b" 或 "5" 或 "@"</td>
</tr>
<tr>
<td>[^abc]</td>
<td>匹配 "a","b","c" 之外的任意一个字符</td>
</tr>
<tr>
<td>[f-k]</td>
<td>匹配 "f"~"k" 之间的任意一个字母</td>
</tr>
<tr>
<td>[^A-F0-3]</td>
<td>匹配 "A","F","0"~"3" 之外的任意一个字符</td>
</tr>
<tr>
<td>[a-d[m-p]]</td>
<td>匹配 a 到 d 或者 m 到 p：[a-dm-p]（并集）</td>
</tr>
<tr>
<td>[a-z&amp;&amp;[m-p]]</td>
<td>匹配 a 到 z 并且 m 到 p：[a-dm-p]（交集）</td>
</tr>
<tr>
<td>[^]</td>
<td>取反</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>正则表达式的特殊符号，被包含到中括号中，则失去特殊意义，除了 ^,- 之外，需要在前面加 \</p>
</li>
<li>
<p>标准字符集合，除小数点外，如果被包含于中括号，自定义字符集合将包含该集合。<br>
比如：[\d. \ -+] 将匹配：数字、小数点、+、-</p>
</li>
</ul>
<hr>
<h5> 量词字符</h5>
<p>修饰匹配次数的特殊符号。</p>
<ul>
<li>匹配次数中的贪婪模式(匹配字符越多越好，默认 ！)，* 和 + 都是贪婪型元字符。</li>
<li>匹配次数中的非贪婪模式（匹配字符越少越好，修饰匹配次数的特殊符号后再加上一个 ? 号）</li>
</ul>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>X?</td>
<td>X 一次或一次也没，有相当于 <code>{0,1}</code></td>
</tr>
<tr>
<td>X*</td>
<td>X 不出现或出现任意次，相当于<code> {0,}</code></td>
</tr>
<tr>
<td>X+</td>
<td>X 至少一次，相当于 <code>{1,}</code></td>
</tr>
<tr>
<td n="">X</td>
<td>X 恰好 n 次</td>
</tr>
<tr>
<td>{n,}</td>
<td>X 至少 n 次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>X 至少 n 次，但是不超过 m 次</td>
</tr>
</tbody>
</table>
<hr>
<h4> 位置匹配</h4>
<h5> 字符边界</h5>
<p>本组标记匹配的不是字符而是位置，符合某种条件的位置</p>
<table>
<thead>
<tr>
<th>元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>^</td>
<td>与字符串开始的地方匹配（在字符集合中用来求非，在字符集合外用作匹配字符串的开头）</td>
</tr>
<tr>
<td>$</td>
<td>与字符串结束的地方匹配</td>
</tr>
<tr>
<td>\b</td>
<td>匹配一个单词边界</td>
</tr>
</tbody>
</table>
<hr>
<h5> 捕获组</h5>
<p>捕获组是把多个字符当一个单独单元进行处理的方法，它通过对括号内的字符分组来创建。</p>
<p>在表达式 <code>((A)(B(C)))</code>，有四个这样的组：((A)(B(C)))、(A)、(B(C))、(C)（按照括号从左到右依次为 group(1)...）</p>
<ul>
<li>调用 matcher 对象的 groupCount 方法返回一个 int 值，表示 matcher 对象当前有多个捕获组。</li>
<li>特殊的组 group(0)、group()，代表整个表达式，该组不包括在 groupCount 的返回值中。</li>
</ul>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>|  (分支结构)</td>
<td>左右两边表达式之间 "或" 关系，匹配左边或者右边</td>
</tr>
<tr>
<td>()  (捕获组)</td>
<td>(1) 在被修饰匹配次数的时候，括号中的表达式可以作为整体被修饰<br>(2) 取匹配结果的时候，括号中的表达式匹配到的内容可以被单独得到<br>(3) 每一对括号分配一个编号,()的捕获根据左括号的顺序从 1 开始自动编号。捕获元素编号为零的第一个捕获是由整个正则表达式模式匹配的文本</td>
</tr>
<tr>
<td>(?:Expression)   非捕获组</td>
<td>一些表达式中，不得不使用( )，但又不需要保存 () 中子表达式匹配的内容，这时可以用非捕获组来抵消使用( )带来的副作用。</td>
</tr>
</tbody>
</table>
<hr>
<h5> 反向引用</h5>
<p>反向引用（\number），又叫回溯引用：</p>
<ul>
<li>
<p>每一对()会分配一个编号，使用 () 的捕获根据左括号的顺序从1开始自动编号</p>
</li>
<li>
<p>通过反向引用，可以对分组已捕获的字符串进行引用，继续匹配</p>
</li>
<li>
<p><strong>把匹配到的字符重复一遍在进行匹配</strong></p>
</li>
<li>
<p>应用 1：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>首先匹配 ((\d)3)，其次 \1 匹配 ((\d)3) 已经匹配到的内容，\2 匹配 (\d)， {2} 指的是 \2 的值出现两次</li>
<li>实例：23238n22（匹配到 2 未来就继续匹配 2）</li>
<li>实例：43438n44</li>
</ul>
</li>
<li>
<p>应用 2：爬虫</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>匹配结果</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h5> 零宽断言</h5>
<p>预搜索（零宽断言）（环视）</p>
<ul>
<li>
<p>只进行子表达式的匹配，匹配内容不计入最终的匹配结果，是零宽度</p>
</li>
<li>
<p>判断当前位置的前后字符，是否符合指定的条件，但不匹配前后的字符，<strong>是对位置的匹配</strong></p>
</li>
<li>
<p>正则表达式匹配过程中，如果子表达式匹配到的是字符内容，而非位置，并被保存到最终的匹配结果中，那么就认为这个子表达式是占有字符的；如果子表达式匹配的仅仅是位置，或者匹配的内容并不保存到最终的匹配结果中，那么就认为这个子表达式是<strong>零宽度</strong>的。占有字符还是零宽度，是针对匹配的内容是否保存到最终的匹配结果中而言的</p>
<table>
<thead>
<tr>
<th>表达式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>(?=exp)</td>
<td>断言自身出现的位置的后面能匹配表达式exp</td>
</tr>
<tr>
<td>(?&lt;=exp)</td>
<td>断言自身出现的位置的前面能匹配表达式exp</td>
</tr>
<tr>
<td>(?!exp)</td>
<td>断言此位置的后面不能匹配表达式exp</td>
</tr>
<tr>
<td>(?&lt;!exp)</td>
<td>断言此位置的前面不能匹配表达式exp</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h4> 匹配模式</h4>
<p>正则表达式的匹配模式：</p>
<ul>
<li>IGNORECASE 忽略大小写模式
<ul>
<li>匹配时忽略大小写。</li>
<li>默认情况下，正则表达式是要区分大小写的。</li>
</ul>
</li>
<li>SINGLELINE 单行模式
<ul>
<li>整个文本看作一个字符串，只有一个开头，一个结尾。</li>
<li>使小数点 "." 可以匹配包含换行符（\n）在内的任意字符。</li>
</ul>
</li>
<li>MULTILINE 多行模式
<ul>
<li>每行都是一个字符串，都有开头和结尾。</li>
<li>在指定了 MULTILINE 之后，如果需要仅匹配字符串开始和结束位置，可以使用 \A 和 \Z</li>
</ul>
</li>
</ul>
<hr>
<h4> 分组匹配</h4>
<p>Pattern 类：</p>
<ul>
<li><code>static Pattern compile(String regex)</code>：将给定的正则表达式编译为模式</li>
<li><code>Matcher matcher(CharSequence input)</code>：创建一个匹配器，匹配给定的输入与此模式</li>
<li><code>static boolean matches(String regex, CharSequence input)</code>：编译正则表达式，并匹配输入</li>
</ul>
<p>Matcher 类：</p>
<ul>
<li><code>boolean find()</code>：扫描输入的序列，查找与该模式匹配的下一个子序列</li>
<li><code>String group()</code>：返回与上一个匹配的输入子序列，同 group(0)，匹配整个表达式的子字符串</li>
<li><code>String group(int group)</code>：返回在上一次匹配操作期间由给定组捕获的输入子序列</li>
<li><code>int groupCount()</code>：返回此匹配器模式中捕获组的数量</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>正则表达式改为 <code>"(([a-z]+)(?:[0-9]+))"</code>   没有 group(3) 因为是非捕获组</li>
<li>正则表达式改为 <code>"([a-z]+)([0-9]+)"</code>  没有 group(3)    aa232  - aa  --232</li>
</ul>
<hr>
<h4> 应用</h4>
<h5> 基本验证</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 验证号码</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 查找替换</h5>
<ul>
<li><code>public String[] split(String regex)</code>：按照正则表达式匹配的内容进行分割字符串，反回一个字符串数组</li>
<li><code>public String replaceAll(String regex,String newStr)</code>：按照正则表达式匹配的内容进行替换</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 搜索号码</h5>
<p>找出所有 189 和 132 开头的手机号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 集合</h2>
<h3> 集合概述</h3>
<p>集合是一个大小可变的容器，容器中的每个数据称为一个元素</p>
<p>集合特点：类型可以不确定，大小不固定；集合有很多，不同的集合特点和使用场景不同</p>
<p>数组：类型和长度一旦定义出来就都固定</p>
<p>作用：</p>
<ul>
<li>在开发中，很多时候元素的个数是不确定的</li>
<li>而且经常要进行元素的增删该查操作，集合都是非常合适的，开发中集合用的更多</li>
</ul>
<hr>
<h3> 存储结构</h3>
<p>数据结构指的是数据以什么方式组织在一起，不同的数据结构，增删查的性能是不一样的</p>
<p>数据存储的常用结构有：栈、队列、数组、链表和红黑树</p>
<ul>
<li>
<p>队列（queue）：先进先出，后进后出。(FIFO first in first out)</p>
</li>
<li>
<p>栈（stack）：后进先出，先进后出 （LIFO）</p>
</li>
<li>
<p>数组：数组是内存中的连续存储区域，分成若干等分的小区域（每个区域大小是一样的）元素存在索引</p>
<p>特点：<strong>查询元素快</strong>（根据索引快速计算出元素的地址，然后立即去定位），<strong>增删元素慢</strong>（创建新数组，迁移元素）</p>
</li>
<li>
<p>链表：元素不是内存中的连续区域存储，元素是游离存储的，每个元素会记录下个元素的地址<br>
特点：<strong>查询元素慢，增删元素快</strong>（针对于首尾元素，速度极快，一般是双链表）</p>
</li>
<li>
<p>树：</p>
<ul>
<li>
<p>二叉树：binary tree 永远只有一个根节点，是每个结点不超过2个节点的树（tree）</p>
<p>特点：二叉排序树：小的左边，大的右边，但是可能树很高，性能变差，为了做排序和搜索会进行左旋和右旋实现平衡查找二叉树，让树的高度差不大于1</p>
</li>
<li>
<p>红黑树（基于红黑规则实现自平衡的排序二叉树）：树保证到了很矮小，但是又排好序，性能最高的</p>
<p>特点：<strong>红黑树的增删查改性能都好</strong></p>
</li>
</ul>
</li>
</ul>
<p>各数据结构时间复杂度对比：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/数据结构的复杂度对比.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>图片来源：<a href="https://www.bigocheatsheet.com/" target="_blank" rel="noopener noreferrer">https://www.bigocheatsheet.com/</a></p>
<hr>
<h3> Collection</h3>
<h4> 概述</h4>
<p>Java 中集合的代表是 Collection，Collection 集合是 Java 中集合的祖宗类</p>
<p>Collection 集合底层为数组：<code>[value1, value2, ....]</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>集合的特点：</strong></p>
<ul>
<li>Set 系列集合：添加的元素是无序，不重复，无索引的
<ul>
<li>HashSet：添加的元素是无序，不重复，无索引的</li>
<li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li>
<li>TreeSet：不重复，无索引，按照大小默认升序排序</li>
</ul>
</li>
<li>List 系列集合：添加的元素是有序，可重复，有索引
<ul>
<li>ArrayList：添加的元素是有序，可重复，有索引</li>
<li>LinekdList：添加的元素是有序，可重复，有索引</li>
</ul>
</li>
</ul>
<hr>
<h4> API</h4>
<p>Collection 是集合的祖宗类，它的功能是全部集合都可以继承使用的，所以要学习它。</p>
<p>Collection 子类的构造器都有可以包装其他子类的构造方法，如：</p>
<ul>
<li>
<p><code>public ArrayList(Collection&lt;? extends E&gt; c)</code>：构造新集合，元素按照由集合的迭代器返回的顺序</p>
</li>
<li>
<p><code>public HashSet(Collection&lt;? extends E&gt; c)</code>：构造一个包含指定集合中的元素的新集合</p>
</li>
</ul>
<p>Collection API 如下：</p>
<ul>
<li><code>public boolean add(E e)</code>：把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code>：清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>：把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(Object obj)</code>：判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>：判断当前集合是否为空。</li>
<li><code>public int size()</code>：返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>：把集合中的元素，存储到数组中</li>
<li><code>public boolean addAll(Collection&lt;? extends E&gt; c)</code>：将指定集合中的所有元素添加到此集合</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 遍历</h4>
<p>Collection 集合的遍历方式有三种:</p>
<p>集合可以直接输出内容，因为底层重写了 toString() 方法</p>
<ol>
<li>
<p>迭代器</p>
<ul>
<li><code>public Iterator iterator()</code>：获取集合对应的迭代器，用来遍历集合中的元素的</li>
<li><code>E next()</code>：获取下一个元素值</li>
<li><code>boolean hasNext()</code>：判断是否有下一个元素，有返回 true ，反之返回 false</li>
<li><code>default void remove()</code>：从底层集合中删除此迭代器返回的最后一个元素，这种方法只能在每次调用 next() 时调用一次</li>
</ul>
</li>
<li>
<p>增强 for 循环：可以遍历集合或者数组，遍历集合实际上是迭代器遍历的简化写法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>缺点：遍历无法知道遍历到了哪个元素了，因为没有索引</p>
</li>
<li>
<p>JDK 1.8 开始之后的新技术 Lambda 表达式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<hr>
<h4> List</h4>
<h5> 概述</h5>
<p>List 集合继承了 Collection 集合全部的功能。</p>
<p>List 系列集合有索引，所以多了很多按照索引操作元素的功能：for 循环遍历（4 种遍历）</p>
<p>List 系列集合：</p>
<ul>
<li>
<p>ArrayList：添加的元素是有序，可重复，有索引</p>
</li>
<li>
<p>LinekdList：添加的元素是有序，可重复，有索引</p>
</li>
</ul>
<hr>
<h5> ArrayList</h5>
<h6> 介绍</h6>
<p>ArrayList 添加的元素，是有序，可重复，有索引的</p>
<ul>
<li><code>public boolean add(E e)</code>：将指定的元素追加到此集合的末尾</li>
<li><code>public void add(int index, E element)</code>：将指定的元素，添加到该集合中的指定位置上</li>
<li><code>public E get(int index)</code>：返回集合中指定位置的元素</li>
<li><code>public E remove(int index)</code>：移除列表中指定位置的元素，返回的是被移除的元素</li>
<li><code>public E set(int index, E element)</code>：用指定元素替换集合中指定位置的元素，返回更新前的元素值</li>
<li><code>int indexOf(Object o)</code>：返回列表中指定元素第一次出现的索引，如果不包含此元素，则返回 -1</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h6> 源码</h6>
<p>ArrayList 实现类集合底层<strong>基于数组存储数据</strong>的，查询快，增删慢，支持快速随机访问</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 <code>Cloneable</code> 接口 ，即覆盖了函数 <code>clone()</code>，能被克隆</li>
<li><code>ArrayList</code> 实现了 <code>Serializable </code> 接口，这意味着 <code>ArrayList</code> 支持序列化，能通过序列化去传输</li>
</ul>
<p>核心方法：</p>
<ul>
<li>
<p>构造函数：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量（惰性初始化），即向数组中添加第一个元素时，<strong>数组容量扩为 10</strong></p>
</li>
<li>
<p>添加元素：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 add 第 1 个元素到 ArrayList，size 是 0，进入 ensureCapacityInternal 方法，</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果需要的容量大于数组长度，进行扩容：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>指定索引插入，<strong>在旧数组上操作</strong>：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>扩容：新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，<code>oldCapacity &gt;&gt; 1</code> 需要取整，所以新容量大约是旧容量的 1.5 倍左右，即 oldCapacity+oldCapacity/2</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code>（底层 <code>System.arraycopy()</code>）把原数组整个复制到<strong>新数组</strong>中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>MAX_ARRAY_SIZE：要分配的数组的最大大小，分配更大的<strong>可能</strong>会导致</p>
<ul>
<li>OutOfMemoryError:Requested array size exceeds VM limit（请求的数组大小超出 VM 限制）</li>
<li>OutOfMemoryError: Java heap space（堆区内存不足，可以通过设置 JVM 参数 -Xmx 来调节）</li>
</ul>
</li>
<li>
<p>删除元素：需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，在旧数组上操作，该操作的时间复杂度为 O(N)，可以看到 ArrayList 删除元素的代价是非常高的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>序列化：ArrayList 基于数组并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，就没必要全部进行序列化。保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>ensureCapacity：增加此实例的容量，以确保它至少可以容纳最小容量参数指定的元素数，减少增量重新分配的次数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>Fail-Fast</strong>：快速失败，modCount 用来记录 ArrayList <strong>结构发生变化</strong>的次数，结构发生变化是指添加或者删除至少一个元素的操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，改变了抛出 ConcurrentModificationException 异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h5> Vector</h5>
<p>同步：Vector 的实现与 ArrayList 类似，但是方法上使用了 synchronized 进行同步</p>
<p>构造：默认长度为 10 的数组</p>
<p>扩容：Vector 的构造函数可以传入 capacityIncrement 参数，作用是在扩容时使容量 capacity 增长 capacityIncrement，如果这个参数的值小于等于 0（默认0），扩容时每次都令 capacity 为原来的两倍</p>
<p>对比 ArrayList</p>
<ol>
<li>
<p>Vector 是同步的，开销比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序来控制</p>
</li>
<li>
<p>Vector 每次扩容请求其大小的 2 倍（也可以通过构造函数设置增长的容量），而 ArrayList 是 1.5 倍</p>
</li>
<li>
<p>底层都是 <code>Object[]</code> 数组存储</p>
</li>
</ol>
<hr>
<h5> LinkedList</h5>
<h6> 介绍</h6>
<p>LinkedList 也是 List 的实现类：基于<strong>双向链表</strong>实现，使用 Node 存储链表节点信息，增删比较快，查询慢</p>
<p>LinkedList 除了拥有 List 集合的全部功能还多了很多操作首尾元素的特殊功能：</p>
<ul>
<li><code>public boolean add(E e)</code>：将指定元素添加到此列表的结尾</li>
<li><code>public E poll()</code>：检索并删除此列表的头（第一个元素）</li>
<li><code>public void addFirst(E e)</code>：将指定元素插入此列表的开头</li>
<li><code>public void addLast(E e)</code>：将指定元素添加到此列表的结尾</li>
<li><code>public E pop()</code>：从此列表所表示的堆栈处弹出一个元素</li>
<li><code>public void push(E e)</code>：将元素推入此列表所表示的堆栈</li>
<li><code>public int indexOf(Object o)</code>：返回此列表中指定元素的第一次出现的索引，如果不包含返回 -1</li>
<li><code>public int lastIndexOf(Object o)</code>：从尾遍历找</li>
<li><code> public boolean remove(Object o)</code>：一次只删除一个匹配的对象，如果删除了匹配对象返回 true</li>
<li><code>public E remove(int index)</code>：删除指定位置的元素</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h6> 源码</h6>
<p>LinkedList 是一个实现了 List 接口的<strong>双端链表</strong>，支持高效的插入和删除操作，另外也实现了 Deque 接口，使得 LinkedList 类也具有队列的特性</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/LinkedList底层结构.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>核心方法：</p>
<ul>
<li>
<p>使 LinkedList 变成线程安全的，可以调用静态类 Collections 类中的 synchronizedList 方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>私有内部类 Node：这个类代表双端链表的节点 Node</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>构造方法：只有无参构造和用已有的集合创建链表的构造方法</p>
</li>
<li>
<p>添加元素：默认加到尾部</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>获取元素：<code>get(int index)</code> 根据指定索引返回数据</p>
<ul>
<li>获取头节点 (index=0)：<code>getFirst()、element()、peek()、peekFirst()</code> 这四个获取头结点方法的区别在于对链表为空时的处理方式，是抛出异常还是返回NULL，其中 <code>getFirst() element()</code> 方法将会在链表为空时，抛出异常</li>
<li>获取尾节点 (index=-1)：getLast() 方法在链表为空时，抛出 NoSuchElementException，而 peekLast() 不会，只会返回 null</li>
</ul>
</li>
<li>
<p>删除元素：</p>
<ul>
<li>remove()、removeFirst()、pop()：删除头节点</li>
<li>removeLast()、pollLast()：删除尾节点，removeLast()在链表为空时抛出NoSuchElementException，而pollLast()方法返回null</li>
</ul>
</li>
</ul>
<p>对比 ArrayList</p>
<ol>
<li>是否保证线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全</li>
<li>底层数据结构：
<ul>
<li>Arraylist 底层使用的是 <code>Object</code> 数组</li>
<li>LinkedList 底层使用的是双向链表数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环）</li>
</ul>
</li>
<li>插入和删除是否受元素位置的影响：
<ul>
<li>ArrayList 采用数组存储，所以插入和删除元素受元素位置的影响</li>
<li>LinkedList采 用链表存储，所以对于<code>add(E e)</code>方法的插入，删除元素不受元素位置的影响</li>
</ul>
</li>
<li>是否支持快速随机访问：
<ul>
<li>LinkedList 不支持高效的随机元素访问，ArrayList 支持</li>
<li>快速随机访问就是通过元素的序号快速获取元素对象(对应于 <code>get(int index)</code> 方法)</li>
</ul>
</li>
<li>内存空间占用：
<ul>
<li>ArrayList 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间</li>
<li>LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）</li>
</ul>
</li>
</ol>
<hr>
<h4> Set</h4>
<h5> 概述</h5>
<p>Set 系列集合：</p>
<ul>
<li>HashSet：添加的元素是无序，不重复，无索引的</li>
<li>LinkedHashSet：添加的元素是有序，不重复，无索引的</li>
<li>TreeSet：不重复，无索引，按照大小默认升序排序</li>
</ul>
<p><strong>注意</strong>：没有索引，不能使用普通 for 循环遍历</p>
<hr>
<h5> HashSet</h5>
<p>哈希值：</p>
<ul>
<li>
<p>哈希值：JDK 根据对象的地址或者字符串或者数字计算出来的数值</p>
</li>
<li>
<p>获取哈希值：Object 类中的 public int hashCode()</p>
</li>
<li>
<p>哈希值的特点</p>
<ul>
<li>同一个对象多次调用 hashCode() 方法返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的，而重写 hashCode() 方法，可以实现让不同对象的哈希值相同</li>
</ul>
</li>
</ul>
<p><strong>HashSet 底层就是基于 HashMap 实现，值是  PRESENT = new Object()</strong></p>
<p>Set 集合添加的元素是无序，不重复的。</p>
<ul>
<li>
<p>是如何去重复的？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Set 系列集合元素无序的根本原因</p>
<p>Set 系列集合添加元素无序的根本原因是因为<strong>底层采用了哈希表存储元素</strong>。</p>
<ul>
<li>JDK 1.8 之前：哈希表 = 数组（初始容量16) + 链表  + （哈希算法）</li>
<li>JDK 1.8 之后：哈希表 = 数组（初始容量16) + 链表 + 红黑树  + （哈希算法）
<ul>
<li>当链表长度超过阈值 8 且当前数组的长度 &gt; 64时，将链表转换为红黑树，减少了查找时间</li>
<li>当链表长度超过阈值 8 且当前数组的长度 &lt; 64时，扩容</li>
</ul>
</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashSet底层结构哈希表.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>每个元素的 hashcode() 的值进行响应的算法运算，计算出的值相同的存入一个数组块中，以链表的形式存储，如果链表长度超过8就采取红黑树存储，所以输出的元素是无序的。</p>
</li>
<li>
<p>如何设置只要对象内容一样，就希望集合认为重复：<strong>重写 hashCode 和 equals 方法</strong></p>
</li>
</ul>
<hr>
<h5> Linked</h5>
<p>LinkedHashSet 为什么是有序的？</p>
<p>LinkedHashSet 底层依然是使用哈希表存储元素的，但是每个元素都额外带一个链来维护添加顺序，不光增删查快，还有顺序，缺点是多了一个存储顺序的链会<strong>占内存空间</strong>，而且不允许重复，无索引</p>
<hr>
<h5> TreeSet</h5>
<p>TreeSet 集合自排序的方式：</p>
<ol>
<li>有值特性的元素直接可以升序排序（浮点型，整型）</li>
<li>字符串类型的元素会按照首字符的编号排序</li>
<li>对于自定义的引用数据类型，TreeSet 默认无法排序，执行的时候报错，因为不知道排序规则</li>
</ol>
<p>自定义的引用数据类型，TreeSet 默认无法排序，需要定制排序的规则，方案有 2 种：</p>
<ul>
<li>
<p>直接为<strong>对象的类</strong>实现比较器规则接口 Comparable，重写比较方法：</p>
<p>方法：<code>public int compareTo(Employee o): this 是比较者, o 是被比较者</code></p>
<ul>
<li>比较者大于被比较者，返回正数</li>
<li>比较者小于被比较者，返回负数</li>
<li>比较者等于被比较者，返回 0</li>
</ul>
</li>
<li>
<p>直接为<strong>集合</strong>设置比较器 Comparator 对象，重写比较方法：</p>
<p>方法：<code>public int compare(Employee o1, Employee o2): o1 比较者, o2 被比较者</code></p>
<ul>
<li>比较者大于被比较者，返回正数</li>
<li>比较者小于被比较者，返回负数</li>
<li>比较者等于被比较者，返回 0</li>
</ul>
</li>
</ul>
<p>注意：如果类和集合都带有比较规则，优先使用集合自带的比较规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比较器原理：底层是以第一个元素为基准，加一个新元素，就会和第一个元素比，如果大于，就继续和大于的元素进行比较，直到遇到比新元素大的元素为止，放在该位置的左边（红黑树）</p>
<hr>
<h4> Queue</h4>
<p>Queue：队列，先进先出的特性</p>
<p>PriorityQueue 是优先级队列，底层存储结构为 Object[]，默认实现为小顶堆，每次出队最小的元素</p>
<p>构造方法：</p>
<ul>
<li>
<p><code>public PriorityQueue()</code>：构造默认长度为 11 的队列（数组）</p>
</li>
<li>
<p><code>public PriorityQueue(Comparator&lt;? super E&gt; comparator)</code>：利用比较器自定义堆排序的规则</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<p>常用 API：</p>
<ul>
<li><code>public boolean offer(E e)</code>：将指定的元素插入到此优先级队列的<strong>尾部</strong></li>
<li><code>public E poll() </code>：检索并删除此队列的<strong>头元素</strong>，如果此队列为空，则返回 null</li>
<li><code>public E peek()</code>：检索但不删除此队列的头，如果此队列为空，则返回 null</li>
<li><code>public boolean remove(Object o)</code>：从该队列中删除指定元素（如果存在），删除元素 e 使用 o.equals(e) 比较，如果队列包含多个这样的元素，删除第一个</li>
</ul>
<hr>
<h4> Collections</h4>
<p>java.utils.Collections：集合<strong>工具类</strong>，Collections 并不属于集合，是用来操作集合的工具类</p>
<p>Collections 有几个常用的API：</p>
<ul>
<li><code>public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... e)</code>：给集合对象批量添加元素</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code>：打乱集合顺序</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list)</code>：将集合中元素按照默认规则排序</li>
<li><code>public static &lt;T&gt; void sort(List&lt;T&gt; list,Comparator&lt;? super T&gt; )</code>：集合中元素按照指定规则排序</li>
<li><code>public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code>：返回由指定 list 支持的线程安全 list</li>
<li><code>public static &lt;T&gt; Set&lt;T&gt; singleton(T o)</code>：返回一个只包含指定对象的不可变组</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Map</h3>
<h4> 概述</h4>
<p>Collection 是单值集合体系，Map集合是一种双列集合，每个元素包含两个值。</p>
<p>Map集合的每个元素的格式：key=value（键值对元素），Map集合也被称为键值对集合</p>
<p>Map集合的完整格式：<code>{key1=value1, key2=value2, key3=value3, ...}</code></p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Map 集合的特点：</p>
<ol>
<li>Map 集合的特点都是由键决定的</li>
<li>Map 集合的键是无序，不重复的，无索引的（Set）</li>
<li>Map 集合的值无要求（List）</li>
<li>Map 集合的键值对都可以为 null</li>
<li>Map 集合后面重复的键对应元素会覆盖前面的元素</li>
</ol>
<p>HashMap：元素按照键是无序，不重复，无索引，值不做要求</p>
<p>LinkedHashMap：元素按照键是有序，不重复，无索引，值不做要求</p>
<hr>
<h4> 常用API</h4>
<p>Map 集合的常用 API</p>
<ul>
<li><code>public V put(K key, V value)</code>：把指定的键与值添加到 Map 集合中，<strong>重复的键会覆盖前面的值元素</strong></li>
<li><code>public V remove(Object key)</code>：把指定的键对应的键值对元素在集合中删除，返回被删除元素的值</li>
<li><code>public V get(Object key)</code>：根据指定的键，在 Map 集合中获取对应的值</li>
<li><code>public Set&lt;K&gt; keySet()</code>：获取 Map 集合中所有的键，存储到 <strong>Set 集合</strong>中</li>
<li><code>public Collection&lt;V&gt; values()</code>：获取全部值的集合，存储到 <strong>Collection 集合</strong></li>
<li><code>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>：获取Map集合中所有的键值对对象的集合</li>
<li><code>public boolean containsKey(Object key)</code>：判断该集合中是否有此键</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 遍历方式</h4>
<p>Map集合的遍历方式有：3种。</p>
<ol>
<li>“键找值”的方式遍历：先获取 Map 集合全部的键，再根据遍历键找值。</li>
<li>“键值对”的方式遍历：难度较大，采用增强 for 或者迭代器</li>
<li>JDK 1.8 开始之后的新技术：foreach，采用 Lambda 表达式</li>
</ol>
<p>集合可以直接输出内容，因为底层重写了 toString() 方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> HashMap</h4>
<h5> 基本介绍</h5>
<p>HashMap 基于哈希表的 Map 接口实现，是以 key-value 存储形式存在，主要用来存放键值对</p>
<p>特点：</p>
<ul>
<li>HashMap 的实现不是同步的，这意味着它不是线程安全的</li>
<li>key 是唯一不重复的，底层的哈希表结构，依赖 hashCode 方法和 equals 方法保证键的唯一</li>
<li>key、value 都可以为null，但是 key 位置只能是一个null</li>
<li>HashMap 中的映射不是有序的，即存取是无序的</li>
<li><strong>key 要存储的是自定义对象，需要重写 hashCode 和 equals 方法，防止出现地址不同内容相同的 key</strong></li>
</ul>
<p>JDK7 对比 JDK8：</p>
<ul>
<li>7 = 数组 + 链表，8 = 数组 + 链表 + 红黑树</li>
<li>7 中是头插法，多线程容易造成环，8 中是尾插法</li>
<li>7 的扩容是全部数据重新定位，8 中是位置不变或者当前位置 + 旧 size 大小来实现</li>
<li>7 是先判断是否要扩容再插入，8 中是先插入再看是否要扩容</li>
</ul>
<p>底层数据结构：</p>
<ul>
<li>
<p>哈希表（Hash table，也叫散列表），根据关键码值而直接访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度，这个映射函数叫做散列函数，存放记录的数组叫做散列表</p>
</li>
<li>
<p>JDK1.8 之前 HashMap 由数组+链表组成</p>
<ul>
<li>数组是 HashMap 的主体</li>
<li>链表则是为了解决哈希冲突而存在的（<strong>拉链法解决冲突</strong>），拉链法就是头插法，两个对象调用的 hashCode 方法计算的哈希码值（键的哈希）一致导致计算的数组索引值相同</li>
</ul>
</li>
<li>
<p>JDK1.8 以后 HashMap 由<strong>数组+链表 +红黑树</strong>数据结构组成</p>
<ul>
<li>解决哈希冲突时有了较大的变化</li>
<li>当链表长度<strong>超过（大于）阈值</strong>（或者红黑树的边界值，默认为 8）并且当前数组的<strong>长度大于等于 64 时</strong>，此索引位置上的所有数据改为红黑树存储</li>
<li>即使哈希函数取得再好，也很难达到元素百分百均匀分布。当 HashMap 中有大量的元素都存放到同一个桶中时，就相当于一个长的单链表，假如单链表有 n 个元素，遍历的<strong>时间复杂度是 O(n)</strong>，所以 JDK1.8 中引入了 红黑树（查找<strong>时间复杂度为 O(logn)</strong>）来优化这个问题，使得查找效率更高</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap底层结构.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1nJ411J7AA" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1nJ411J7AA</a></p>
<hr>
<h5> 继承关系</h5>
<p>HashMap 继承关系如下图所示：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap继承关系.bmp" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>说明：</p>
<ul>
<li>Cloneable 空接口，表示可以克隆， 创建并返回 HashMap 对象的一个副本。</li>
<li>Serializable 序列化接口，属于标记性接口，HashMap 对象可以被序列化和反序列化。</li>
<li>AbstractMap 父类提供了 Map 实现接口，以最大限度地减少实现此接口所需的工作</li>
</ul>
<hr>
<h5> 成员属性</h5>
<ol>
<li>
<p>序列化版本号</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>集合的初始化容量（<strong>必须是二的 n 次幂</strong> ）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>HashMap 构造方法指定集合的初始化容量大小：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>
<p>为什么必须是 2 的 n 次幂？用位运算替代取余计算，减少 rehash 的代价（移动的节点少）</p>
<p>HashMap 中添加元素时，需要根据 key 的 hash 值确定在数组中的具体位置。为了减少碰撞，把数据分配均匀，每个链表长度大致相同，实现该方法就是取模 <code>hash%length</code>，计算机中直接求余效率不如位移运算， <strong><code>hash % length == hash &amp; (length-1)</code> 的前提是 length 是 2 的 n 次幂</strong></p>
<p>散列平均分布：2 的 n 次方是 1 后面 n 个 0，2 的 n 次方 -1 是 n 个 1，可以<strong>保证散列的均匀性</strong>，减少碰撞</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>如果输入值不是 2 的幂会怎么样？</p>
<p>创建 HashMap 对象时，HashMap 通过位移运算和或运算得到的肯定是 2 的幂次数，并且是大于那个数的最近的数字，底层采用 tableSizeFor() 方法</p>
</li>
</ul>
</li>
<li>
<p>默认的负载因子，默认值是 0.75</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>集合最大容量</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>当链表的值超过 8 则会转红黑树（JDK1.8 新增）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么 Map 桶中节点个数大于 8 才转为红黑树？</p>
<ul>
<li>
<p>在 HashMap 中有一段注释说明：<strong>空间和时间的权衡</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>其他说法<br>
红黑树的平均查找长度是 log(n)，如果长度为 8，平均查找长度为 log(8)=3，链表的平均查找长度为 n/2，当长度为 8 时，平均查找长度为 8/2=4，这才有转换成树的必要；链表长度如果是小于等于 6，6/2=3，而 log(6)=2.6，虽然速度也很快的，但转化为树结构和生成树的时间并不短</p>
</li>
</ul>
</li>
<li>
<p>当链表的值小于 6 则会从红黑树转回链表</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>当 Map 里面的数量<strong>大于等于</strong>这个阈值时，表中的桶才能进行树形化 ，否则桶内元素超过 8 时会扩容，而不是树形化。为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD (8)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>原因：数组比较小的情况下变为红黑树结构，反而会降低效率，红黑树需要进行左旋，右旋，变色这些操作来保持平衡</p>
</li>
<li>
<p>table 用来初始化（必须是二的 n 次幂）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>HashMap 中<strong>存放元素的个数</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>记录 HashMap 的修改次数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>调整大小下一个容量的值计算方式为：容量 * 负载因子，容量是数组的长度</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>哈希表的加载因子</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>
<p>加载因子的概述</p>
<p>loadFactor 加载因子，是用来衡量 HashMap 满的程度，表示 HashMap 的疏密程度，影响 hash 操作到同一个数组位置的概率，计算 HashMap 的实时加载因子的方法为 <strong>size/capacity</strong>，而不是占用桶的数量去除以 capacity，capacity 是桶的数量，也就是 table 的长度 length</p>
<p>当 HashMap 容纳的元素已经达到数组长度的 75% 时，表示 HashMap 拥挤需要扩容，而扩容这个过程涉及到 rehash、复制数据等操作，非常消耗性能，所以开发中尽量减少扩容的次数，通过创建 HashMap 集合对象时指定初始容量来避免</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>为什么加载因子设置为 0.75，初始化临界值是 12？</p>
<p>loadFactor 太大导致查找元素效率低，存放的数据拥挤，太小导致数组的利用率低，存放的数据会很分散。loadFactor 的默认值为 <strong>0.75f 是官方给出的一个比较好的临界值</strong></p>
</li>
<li>
<p>threshold 计算公式：capacity（数组长度默认16） * loadFactor（默认 0.75）。当 size &gt;= threshold 的时候，那么就要考虑对数组的 resize（扩容），这就是衡量数组是否需要扩增的一个标准， 扩容后的 HashMap 容量是之前容量的<strong>两倍</strong></p>
</li>
</ul>
</li>
</ol>
<hr>
<h5> 构造方法</h5>
<ul>
<li>
<p>构造一个空的 HashMap ，<strong>默认初始容量（16）和默认负载因子（0.75）</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>构造一个具有指定的初始容量和默认负载因子（0.75）HashMap</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>构造一个具有指定的初始容量和负载因子的 HashMap</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>对于 <code>this.threshold = tableSizeFor(initialCapacity)</code></p>
<p>JDK8 以后的构造方法中，并没有对 table 这个成员变量进行初始化，table 的初始化被推迟到了 put 方法中，在 put 方法中会对 threshold 重新计算</p>
</li>
</ul>
</li>
<li>
<p>包含另一个 <code>Map</code> 的构造函数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>putMapEntries 源码分析：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>float ft = ((float)s / loadFactor) + 1.0F</code> 这一行代码中为什么要加 1.0F ？</p>
<p>s / loadFactor 的结果是小数，加 1.0F 相当于是对小数做一个向上取整以尽可能的保证更大容量，更大的容量能够减少 resize 的调用次数，这样可以减少数组的扩容</p>
</li>
</ul>
<hr>
<h5> 成员方法</h5>
<ul>
<li>
<p>hash()：HashMap 是支持 Key 为空的；HashTable 是直接用 Key 来获取 HashCode，key 为空会抛异常</p>
<ul>
<li>
<p>&amp;（按位与运算）：相同的二进制数位上，都是 1 的时候，结果为 1，否则为零</p>
</li>
<li>
<p>^（按位异或运算）：相同的二进制数位上，数字相同，结果为 0，不同为 1，<strong>不进位加法</strong></p>
<p>0 1 相互做 &amp; | ^ 运算，结果出现 0 和 1 的数量分别是 3:1、1:3、1:1，所以异或是最平均的</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>计算 hash 的方法：将 hashCode 无符号右移 16 位，高 16bit 和低 16bit 做异或，扰动运算</p>
<p>原因：当数组长度很小，假设是 16，那么 n-1 即为 1111 ，这样的值和 hashCode() 直接做按位与操作，实际上只使用了哈希值的后 4 位。如果当哈希值的高位变化很大，低位变化很小，就很容易造成哈希冲突了，所以这里<strong>把高低位都利用起来，让高16 位也参与运算</strong>，从而解决了这个问题</p>
<p>哈希冲突的处理方式：</p>
<ul>
<li>开放定址法：线性探查法（ThreadLocalMap 使用），平方探查法（i + 1^2、i - 1^2、i + 2^2……）、双重散列（多个哈希函数）</li>
<li>链地址法：拉链法</li>
</ul>
</li>
<li>
<p>put()：jdk1.8 前是头插法 (链地址法)，多线程下扩容出现循环链表，jdk1.8 以后引入红黑树，插入方法变成尾插法</p>
<p>第一次调用 put 方法时创建数组 Node[] table，因为散列表耗费内存，为了防止内存浪费，所以<strong>延迟初始化</strong></p>
<p>存储数据步骤（存储过程）：</p>
<ol>
<li>先通过 hash 值计算出 key 映射到哪个桶，哈希寻址</li>
<li>如果桶上没有碰撞冲突，则直接插入</li>
<li>如果出现碰撞冲突：如果该桶使用红黑树处理冲突，则调用红黑树的方法插入数据；否则采用传统的链式方法插入，如果链的长度达到临界值，则把链转变为红黑树</li>
<li>如果数组位置相同，通过 equals 比较内容是否相同：相同则新的 value 覆盖旧 value，不相同则将新的键值对添加到哈希表中</li>
<li>最后判断 size 是否大于阈值 threshold，则进行扩容</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>putVal() 方法中 key 在这里执行了一下 hash()，在 putVal 函数中使用到了上述 hash 函数计算的哈希值：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li><code>(n - 1) &amp; hash</code>：计算下标位置</li>
</ul>
  <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-putVal哈希运算.png" style="zoom: 67%;">
<ul>
<li>余数本质是不断做除法，把剩余的数减去，运算效率要比位运算低</li>
</ul>
</li>
<li>
<p>treeifyBin()</p>
<p>节点添加完成之后判断此时节点个数是否大于 TREEIFY_THRESHOLD 临界值 8，如果大于则将链表转换为红黑树，转换红黑树的方法 treeifyBin，整体代码如下：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol>
<li>如果当前数组为空或者数组的长度小于进行树形化的阈 MIN_TREEIFY_CAPACITY = 64 就去扩容，而不是将节点变为红黑树</li>
<li>如果是树形化遍历桶中的元素，创建相同个数的树形节点，复制内容，建立起联系，类似单向链表转换为双向链表</li>
<li>让桶中的第一个元素即数组中的元素指向新建的红黑树的节点，以后这个桶里的元素就是红黑树而不是链表数据结构了</li>
</ol>
</li>
<li>
<p>tableSizeFor()：创建 HashMap 指定容量时，HashMap 通过位移运算和或运算得到比指定初始化容量大的最小的 2 的 n 次幂</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>分析算法：</p>
<ol>
<li><code>int n = cap - 1</code>：防止 cap 已经是 2 的幂。如果 cap 已经是 2 的幂， 不执行减 1 操作，则执行完后面的无符号右移操作之后，返回的 capacity 将是这个 cap 的 2 倍</li>
<li>n=0 （cap-1 之后），则经过后面的几次无符号右移依然是 0，返回的 capacity 是 1，最后有 n+1</li>
<li>|（按位或运算）：相同的二进制数位上，都是 0 的时候，结果为 0，否则为 1</li>
<li>核心思想：<strong>把最高位是 1 的位以及右边的位全部置 1</strong>，结果加 1 后就是大于指定容量的最小的 2 的 n 次幂</li>
</ol>
<p>例如初始化的值为 10：</p>
<ul>
<li>
<p>第一次右移</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>第二次右移</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注意：容量最大是 32bit 的正数，因此最后 <code>n |= n &gt;&gt;&gt; 16</code>，最多是 32 个 1（但是这已经是负数了）。在执行 tableSizeFor 之前，对 initialCapacity 做了判断，如果大于 MAXIMUM_CAPACITY(2 ^ 30)，则取 MAXIMUM_CAPACITY；如果小于 MAXIMUM_CAPACITY(2 ^ 30)，会执行移位操作，所以移位操作之后，最大 30 个 1，加 1 之后得 2 ^ 30</p>
</li>
<li>
<p>得到的 capacity 被赋值给了 threshold</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>JDK 11</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>resize()：</p>
<p>当 HashMap 中的<strong>元素个数</strong>超过 <code>(数组长度)*loadFactor(负载因子)</code> 或者链表过长时（链表长度 &gt; 8，数组长度 &lt; 64），就会进行数组扩容，创建新的数组，伴随一次重新 hash 分配，并且遍历 hash 表中所有的元素非常耗时，所以要尽量避免 resize</p>
<p>扩容机制为扩容为原来容量的 2 倍：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>HashMap 在进行扩容后，节点<strong>要么就在原来的位置，要么就被分配到"原位置+旧容量"的位置</strong></p>
<p>判断：e.hash 与 oldCap 对应的有效高位上的值是 1，即当前数组长度 n 二进制为 1 的位为 x 位，如果 key 的哈希值 x 位也为 1，则扩容后的索引为 now + n</p>
<p>注意：这里要求<strong>数组长度 2 的幂</strong></p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/HashMap-resize扩容.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>普通节点：把所有节点分成高低位两个链表，转移到数组</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>红黑树节点：扩容时 split 方法会将树<strong>拆成高位和低位两个链表</strong>，判断长度是否小于等于 6</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>​</p>
<ul>
<li>
<p>remove()：删除是首先先找到元素的位置，如果是链表就遍历链表找到元素之后删除。如果是用红黑树就遍历树然后找到之后做删除，树小于 6 的时候退化为链表</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>get()</p>
<ol>
<li>
<p>通过 hash 值获取该 key 映射到的桶</p>
</li>
<li>
<p>桶上的 key 就是要查找的 key，则直接找到并返回</p>
</li>
<li>
<p>桶上的 key 不是要找的 key，则查看后续的节点：</p>
<ul>
<li>
<p>如果后续节点是红黑树节点，通过调用红黑树的方法根据 key 获取 value</p>
</li>
<li>
<p>如果后续节点是链表节点，则通过循环遍历链表根据 key 获取 value</p>
</li>
</ul>
</li>
<li>
<p>红黑树节点调用的是 getTreeNode 方法通过树形节点的 find 方法进行查</p>
<ul>
<li>查找红黑树，之前添加时已经保证这个树是有序的，因此查找时就是折半查找，效率更高。</li>
<li>这里和插入时一样，如果对比节点的哈希值相等并且通过 equals 判断值也相等，就会判断 key 相等，直接返回，不相等就从子树中递归查找</li>
</ul>
</li>
<li>
<p>时间复杂度 O(1)</p>
<ul>
<li>若为树，则在树中通过 key.equals(k) 查找，<strong>O(logn)</strong></li>
<li>若为链表，则在链表中通过 key.equals(k) 查找，<strong>O(n)</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h5> 并发异常</h5>
<p>HashMap 和 ArrayList 一样，内部采用 modCount 用来记录集合结构发生变化的次数，结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果<strong>其他线程此时修改了集合内部的结构</strong>，就会直接抛出 ConcurrentModificationException 异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> LinkedMap</h4>
<h5> 原理分析</h5>
<p>LinkedHashMap 是 HashMap 的子类</p>
<ul>
<li>
<p>优点：添加的元素按照键有序不重复的，有序的原因是底层维护了一个双向链表</p>
</li>
<li>
<p>缺点：会占用一些内存空间</p>
</li>
</ul>
<p>对比 Set：</p>
<ul>
<li>HashSet 集合相当于是 HashMap 集合的键，不带值</li>
<li>LinkedHashSet 集合相当于是 LinkedHashMap 集合的键，不带值</li>
<li>底层原理完全一样，都是基于哈希表按照键存储数据的，只是 Map 多了一个键的值</li>
</ul>
<p>源码解析：</p>
<ul>
<li>
<p><strong>内部维护了一个双向链表</strong>，用来维护插入顺序或者 LRU 顺序</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>accessOrder 决定了顺序，默认为 false 维护的是插入顺序（先进先出），true 为访问顺序（<strong>LRU 顺序</strong>）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>维护顺序的函数</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>put()</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>afterNodeInsertion方法，当 removeEldestEntry() 方法返回 true 时会移除最近最久未使用的节点，也就是链表首部节点 first</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>get()</p>
<p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时会将这个节点移到链表尾部，那么链表首部就是最近最久未使用的节点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>remove()</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 HashMap 删除一个键值对时调用，会把在 HashMap 中删除的那个键值对一并从链表中删除</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h5> LRU</h5>
<p>使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES 为 3</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> TreeMap</h4>
<p>TreeMap 实现了 SotredMap 接口，是有序不可重复的键值对集合，基于红黑树（Red-Black tree）实现，每个 key-value 都作为一个红黑树的节点，如果构造 TreeMap 没有指定比较器，则根据 key 执行自然排序（默认升序），如果指定了比较器则按照比较器来进行排序</p>
<p>TreeMap 集合指定大小规则有 2 种方式：</p>
<ul>
<li>直接为对象的类实现比较器规则接口 Comparable，重写比较方法</li>
<li>直接为集合设置比较器 Comparator 对象，重写比较方法</li>
</ul>
<p>说明：TreeSet 集合的底层是基于 TreeMap，只是键的附属值为空对象而已</p>
<p>成员属性：</p>
<ul>
<li>
<p>Entry 节点</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>compare()</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>参考文章：<a href="https://blog.csdn.net/weixin_33991727/article/details/91518677" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_33991727/article/details/91518677</a></p>
<hr>
<h4> WeakMap</h4>
<p>WeakHashMap 是基于弱引用的，内部的 Entry 继承 WeakReference，被弱引用关联的对象在<strong>下一次垃圾回收时会被回收</strong>，并且构造方法传入引用队列，用来在清理对象完成以后清理引用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WeakHashMap 主要用来实现缓存，使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收</p>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能，ConcurrentCache 采取分代缓存：</p>
<ul>
<li>
<p>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）</p>
</li>
<li>
<p>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收</p>
</li>
<li>
<p>当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收</p>
</li>
<li>
<p>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 泛型</h3>
<h4> 概述</h4>
<p>泛型（Generic）：</p>
<ul>
<li>泛型就是一个标签：&lt;数据类型&gt;</li>
<li>泛型可以在编译阶段约束只能操作某种数据类型。</li>
</ul>
<p>注意：</p>
<ul>
<li>JDK 1.7 开始之后，泛型后面的申明可以省略不写</li>
<li><strong>泛型和集合都只能支持引用数据类型，不支持基本数据类型</strong></li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>优点：泛型在编译阶段约束了操作的数据类型，从而不会出现类型转换异常，体现的是 Java 的严谨性和规范性</p>
<hr>
<h4> 自定义</h4>
<h5> 泛型类</h5>
<p>泛型类：使用了泛型定义的类就是泛型类</p>
<p>泛型类格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 泛型方法</h5>
<p>泛型方法：定义了泛型的方法就是泛型方法</p>
<p>泛型方法的定义格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>方法定义了是什么泛型变量，后面就只能用什么泛型变量。</p>
<p>泛型类的核心思想：把出现泛型变量的地方全部替换成传输的真实数据类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自定义泛型接口</p>
<p>泛型接口：使用了泛型定义的接口就是泛型接口。</p>
<p>泛型接口的格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 通配符</h4>
<p>通配符：？</p>
<ul>
<li>? 可以用在使用泛型的时候代表一切类型</li>
<li>E、T、K、V 是在定义泛型的时候使用代表一切类型</li>
</ul>
<p>泛型的上下限：</p>
<ul>
<li>? extends Car：那么 ? 必须是 Car 或者其子类（泛型的上限）</li>
<li>? super  Car：那么 ? 必须是 Car 或者其父类（泛型的下限，不是很常见）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 异常</h2>
<h3> 基本介绍</h3>
<p>异常：程序在编译或者执行的过程中可能出现的问题，Java 为常见的代码异常都设计一个类来代表</p>
<p>错误：Error ，程序员无法处理的错误，只能重启系统，比如内存奔溃，JVM 本身的奔溃</p>
<p>Java 中异常继承的根类是：Throwable</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Exception 异常的分类:</p>
<ul>
<li>编译时异常：继承自 Exception 的异常或者其子类，编译阶段就会报错</li>
<li>运行时异常：继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，在运行阶段出错</li>
</ul>
<hr>
<h3> 处理过程</h3>
<p>异常的产生默认的处理过程解析：（自动处理的过程）</p>
<ol>
<li>默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException（算术异常）</li>
<li>异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给 JVM 虚拟机</li>
<li>虚拟机接收到异常对象后，先在控制台直接输出<strong>异常栈</strong>信息数据</li>
<li>直接从当前执行的异常点终止当前程序</li>
<li>后续代码没有机会执行了，因为程序已经死亡</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 编译异常</h3>
<h4> 基本介绍</h4>
<p>编译时异常：继承自 Exception 的异常或者其子类，没有继承 RuntimeException，编译时异常是编译阶段就会报错</p>
<p>编译时异常的作用是什么：在编译阶段就爆出一个错误，目的在于提醒，请检查并注意不要出 BUG</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 处理机制</h4>
<h5> throws</h5>
<p>在出现编译时异常的地方层层把异常抛出去给调用者，调用者最终抛出给 JVM 虚拟机，JVM 虚拟机输出异常信息，直接终止掉程序，这种方式与默认方式是一样的</p>
<p><strong>Exception 是异常最高类型可以抛出一切异常</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> try/catch</h5>
<p>可以处理异常，并且出现异常后代码也不会死亡</p>
<ul>
<li>
<p>捕获异常和处理异常的格式：<strong>捕获处理</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>监视捕获处理异常写法：Exception 可以捕获处理一切异常类型</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p><strong>Throwable成员方法:</strong></p>
<ul>
<li><code>public String getMessage()</code>：返回此 throwable 的详细消息字符串</li>
<li><code>public String toString()</code>：返回此可抛出的简短描述</li>
<li><code>public void printStackTrace()</code>：把异常的错误信息输出在控制台</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 规范做法</h5>
<p>在出现异常的地方把异常一层一层的抛出给最外层调用者，最外层调用者集中捕获处理</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 运行异常</h3>
<h4> 基本介绍</h4>
<p>继承自 RuntimeException 的异常或者其子类，编译阶段是不会出错的，是在运行时阶段可能出现的错误，运行时异常编译阶段可以处理也可以不处理，代码编译都能通过</p>
<p><strong>常见的运行时异常</strong>：</p>
<ol>
<li>数组索引越界异常：ArrayIndexOutOfBoundsException</li>
<li>空指针异常：NullPointerException，直接输出没问题，调用空指针的变量的功能就会报错</li>
<li>类型转换异常：ClassCastException</li>
<li>迭代器遍历没有此元素异常：NoSuchElementException</li>
<li>算术异常（数学操作异常）：ArithmeticException</li>
<li>数字转换异常：NumberFormatException</li>
</ol>
<hr>
<h4> 处理机制</h4>
<p>运行时异常在编译阶段是不会报错，在运行阶段才会出错，运行时出错了程序还是会停止，运行时异常也建议要处理，运行时异常是自动往外抛出的，不需要手工抛出</p>
<p><strong>运行时异常的处理规范</strong>：直接在最外层捕获处理即可，底层会自动抛出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Finally</h3>
<p>用在捕获处理的异常格式中的，放在最后面</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>finally 的作用</strong>：可以在代码执行完毕以后进行资源的释放操作</p>
<p>资源：资源都是实现了 Closeable 接口的，都自带 close() 关闭方法</p>
<p>注意：如果在 finally 中出现了 return，会吞掉异常</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 自定义</h3>
<p>自定义异常:</p>
<ul>
<li>自定义编译时异常：定义一个异常类继承 Exception，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li>
<li>自定义运行时异常：定义一个异常类继承 RuntimeException，重写构造器，在出现异常的地方用 throw new 自定义对象抛出</li>
</ul>
<p>throws：用在方法上，用于抛出方法中的异常</p>
<p>throw:  用在出现异常的地方，创建异常对象且立即从此处抛出</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 处理规范</h3>
<p>异常的语法注意：</p>
<ol>
<li>运行时异常被抛出可以不处理，可以自动抛出；<strong>编译时异常必须处理</strong>；按照规范都应该处理</li>
<li><strong>重写方法申明抛出的异常，子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型</strong></li>
<li>方法默认都可以自动抛出运行时异常， throws RuntimeException 可以省略不写</li>
<li>当多异常处理时，捕获处理，前面的异常类不能是后面异常类的父类</li>
<li>在 try/catch 后可以追加 finally 代码块，其中的代码一定会被执行，通常用于资源回收操作</li>
</ol>
<p>异常的作用：</p>
<ol>
<li>
<p>可以处理代码问题，防止程序出现异常后的死亡</p>
</li>
<li>
<p>提高了程序的健壮性和安全性</p>
</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> λ</h2>
<h3> lambda</h3>
<h4> 基本介绍</h4>
<p>Lambda 表达式是 JDK1.8 开始之后的新技术，是一种代码的新语法，一种特殊写法</p>
<p>作用：为了简化匿名内部类的代码写法</p>
<p>Lambda 表达式的格式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Lambda 表达式并不能简化所有匿名内部类的写法，只能简化<strong>函数式接口的匿名内部类</strong></p>
<p>简化条件：首先必须是接口，接口中只能有一个抽象方法</p>
<p>@FunctionalInterface 函数式接口注解：一旦某个接口加上了这个注解，这个接口只能有且仅有一个抽象方法</p>
<hr>
<h4> 简化方法</h4>
<p>Lambda 表达式的省略写法（进一步在 Lambda 表达式的基础上继续简化）</p>
<ul>
<li>如果 Lambda 表达式的方法体代码只有一行代码，可以省略大括号不写，同时要省略分号；如果这行代码是 return 语句，必须省略 return 不写</li>
<li>参数类型可以省略不写</li>
<li>如果只有一个参数，参数类型可以省略，同时 <code>()</code> 也可以省略</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 常用简化</h4>
<p>Comparator</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 方法引用</h3>
<h4> 基本介绍</h4>
<p>方法引用：方法引用是为了进一步简化 Lambda 表达式的写法</p>
<p>方法引用的格式：类型或者对象::引用的方法</p>
<p>关键语法是：<code>::</code></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 静态方法</h4>
<p>引用格式：<code>类名::静态方法</code></p>
<p>简化步骤：定义一个静态方法，把需要简化的代码放到一个静态方法中去</p>
<p>静态方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致,才能引用简化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 实例方法</h4>
<p>引用格式：<code>对象::实例方法</code></p>
<p>简化步骤：定义一个实例方法，把需要的代码放到实例方法中去</p>
<p>实例方法引用的注意事项：被引用的方法的参数列表要和函数式接口中的抽象方法的参数列表一致。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 特定类型</h4>
<p>特定类型：String，任何类型</p>
<p>引用格式：<code>特定类型::方法</code></p>
<p>注意事项：如果第一个参数列表中的形参中的第一个参数作为了后面的方法的调用者，并且其余参数作为后面方法的形参，那么就可以用特定类型方法引用了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 构造器</h4>
<p>格式：<code>类名::new</code></p>
<p>注意事项：前后参数一致的情况下，又在创建对象，就可以使用构造器引用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> I/O</h2>
<h3> Stream</h3>
<h4> 概述</h4>
<p>Stream 流其实就是一根传送带，元素在上面可以被 Stream 流操作</p>
<ul>
<li>可以解决已有集合类库或者数组 API 的弊端</li>
<li>Stream 流简化集合和数组的操作</li>
<li>链式编程</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 获取流</h4>
<p>集合获取 Stream 流用：<code>default Stream&lt;E&gt; stream()</code></p>
<p>数组：Arrays.stream(数组)   /  Stream.of(数组);</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 常用API</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void forEach(Consumer&lt;? super T&gt; action)</td>
<td>逐一处理（遍历）</td>
</tr>
<tr>
<td>long count</td>
<td>返回流中的元素数</td>
</tr>
<tr>
<td>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</td>
<td>用于对流中的数据进行过滤</td>
</tr>
<tr>
<td>Stream&lt;T&gt; limit(long maxSize)</td>
<td>返回此流中的元素组成的流，截取前指定参数个数的数据</td>
</tr>
<tr>
<td>Stream&lt;T&gt; skip(long n)</td>
<td>跳过指定参数个数的数据，返回由该流的剩余元素组成的流</td>
</tr>
<tr>
<td>&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T,? extends R&gt; mapper)</td>
<td>加工方法，将当前流中的 T 类型数据转换为另一种 R 类型的流</td>
</tr>
<tr>
<td>static &lt;T&gt; Stream&lt;T&gt; concat(Stream a, Stream b)</td>
<td>合并 a 和 b 两个流为一个，调用 <code>Stream.concat(s1,s2)</code></td>
</tr>
<tr>
<td>Stream&lt;T&gt; distinct()</td>
<td>返回由该流的不同元素组成的流</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 终结方法</h4>
<p>终结方法：Stream 调用了终结方法，流的操作就全部终结，不能继续使用，如 foreach，count 方法等</p>
<p>非终结方法：每次调用完成以后返回一个新的流对象，可以继续使用，支持<strong>链式编程</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 收集流</h4>
<p>收集 Stream：把 Stream 流的数据转回到集合中去</p>
<ul>
<li>Stream 流：工具</li>
<li>集合：目的</li>
</ul>
<p>Stream 收集方法：<code>R collect(Collector collector)</code> 把结果收集到集合中</p>
<p>Collectors 方法：</p>
<ul>
<li><code>public static &lt;T&gt; Collector toList()</code>：把元素收集到 List 集合中</li>
<li><code>public static &lt;T&gt; Collector toSet()</code>：把元素收集到 Set 集合中</li>
<li><code>public static  Collector toMap(Function keyMapper,Function valueMapper)</code>：把元素收集到 Map 集合中</li>
<li><code>Object[] toArray()</code>：把元素收集数组中</li>
<li><code>public static Collector groupingBy(Function&lt;? super T, ? extends K&gt; classifier)</code>：分组</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> File</h3>
<h4> 文件类</h4>
<p>File 类：代表操作系统的文件对象，是用来操作操作系统的文件对象的，删除文件，获取文件信息，创建文件（文件夹），广义来说操作系统认为文件包含（文件和文件夹）</p>
<p>File 类构造器：</p>
<ul>
<li><code>public File(String pathname)</code>：根据路径获取文件对象</li>
<li><code>public File(String parent , String child)</code>：根据父路径和文件名称获取文件对象</li>
</ul>
<p>File 类创建文件对象的格式：</p>
<ul>
<li>
<p><code>File f = new File("绝对路径/相对路径");</code></p>
<ul>
<li>绝对路径：从磁盘的的盘符一路走到目的位置的路径
<ul>
<li>绝对路径依赖具体的环境，一旦脱离环境，代码可能出错</li>
<li>一般是定位某个操作系统中的某个文件对象</li>
</ul>
</li>
<li><strong>相对路径</strong>：不带盘符的（重点）
<ul>
<li>默认是直接相对到工程目录下寻找文件的。</li>
<li>相对路径只能用于寻找工程下的文件，可以跨平台</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>File f = new File("文件对象/文件夹对象")</code> 广义来说：文件是包含文件和文件夹的</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 常用API</h4>
<h5> 常用方法</h5>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getAbsolutePath()</td>
<td>返回此 File 的绝对路径名字符串</td>
</tr>
<tr>
<td>String getPath()</td>
<td>获取创建文件对象的时候用的路径</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回由此 File 表示的文件或目录的名称</td>
</tr>
<tr>
<td>long length()</td>
<td>返回由此 File 表示的文件的长度（大小）</td>
</tr>
<tr>
<td>long length(FileFilter filter)</td>
<td>文件过滤器</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 判断方法</h5>
<p>方法列表：</p>
<ul>
<li><code>boolean exists()</code>：此 File 表示的文件或目录是否实际存在</li>
<li><code>boolean isDirectory()</code>：此 File 表示的是否为目录</li>
<li><code>boolean isFile()</code>：此 File 表示的是否为文件</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 创建删除</h5>
<p>方法列表：</p>
<ul>
<li><code>boolean createNewFile()</code>：当且仅当具有该名称的文件尚不存在时， 创建一个新的空文件</li>
<li><code>boolean delete()</code>：删除由此 File 表示的文件或目录（只能删除空目录）</li>
<li><code>boolean mkdir()</code>：创建由此 File 表示的目录（只能创建一级目录）</li>
<li><code>boolean mkdirs()</code>：可以创建多级目录（建议使用）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 遍历目录</h4>
<ul>
<li><code>public String[] list()</code>：获取当前目录下所有的一级文件名称到一个字符串数组中去返回</li>
<li><code>public File[] listFiles()</code>：获取当前目录下所有的一级文件对象到一个<strong>文件对象数组</strong>中去返回（<strong>重点</strong>）</li>
<li><code>public long lastModified</code>：返回此抽象路径名表示的文件上次修改的时间</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 文件搜索</h4>
<p>递归实现文件搜索（非规律递归）</p>
<ul>
<li>定义一个方法用于做搜索</li>
<li>进入方法中进行业务搜索分析</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Character</h3>
<p>字符集：为字符编制的一套编号规则</p>
<p>计算机的底层是不能直接存储字符的，只能存储二进制 010101</p>
<p>ASCII 编码：8 个开关一组就可以编码字符，1 个字节 2^8 = 256， 一个字节存储一个字符完全够用，英文和数字在底层存储都是采用 1 个字节存储的</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>中国人：中国人有 9 万左右字符，2 个字节编码一个中文字符，1 个字节编码一个英文字符，这套编码叫：GBK 编码，兼容 ASCII 编码表</p>
<p>美国人：收集全球所有的字符，统一编号，这套编码叫 Unicode 编码（万国码），一个英文等于两个字节，一个中文（含繁体）等于两个字节，中文标点占两个字节，英文标点占两个字节</p>
<ul>
<li>UTF-8 是变种形式，也必须兼容 ASCII 编码表</li>
<li>UTF-8 一个中文一般占 3 个字节，中文标点占 3 个，英文字母和数字 1 个字节</li>
</ul>
<p>编码前与编码后的编码集必须一致才不会乱码</p>
<hr>
<h3> IOStream</h3>
<h4> 概述</h4>
<p>IO 输入输出流：输入/输出流</p>
<ul>
<li>Input：输入</li>
<li>Output：输出</li>
</ul>
<p>引入：File 类只能操作文件对象本身，不能读写文件对象的内容，读写数据内容，应该使用 IO 流</p>
<p>IO 流是一个水流模型：IO 理解成水管，把数据理解成水流</p>
<p>IO 流的分类：</p>
<ul>
<li>按照流的方向分为：输入流，输出流。
<ul>
<li>输出流：以内存为基准，把内存中的数据<strong>写出到磁盘文件</strong>或者网络介质中去的流称为输出流</li>
<li>输入流：以内存为基准，把磁盘文件中的数据或者网络中的数据<strong>读入到内存</strong>中的流称为输入流</li>
</ul>
</li>
<li>按照流的内容分为：字节流，字符流
<ul>
<li>字节流：流中的数据的最小单位是一个一个的字节，这个流就是字节流</li>
<li>字符流：流中的数据的最小单位是一个一个的字符，这个流就是字符流（<strong>针对于文本内容</strong>）</li>
</ul>
</li>
</ul>
<p>流大体分为四大类：字节输入流、字节输出流、字符输入流、字符输出流</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 字节流</h4>
<h5> 字节输入</h5>
<p>FileInputStream 文件字节输入流：以内存为基准，把磁盘文件中的数据按照字节的形式读入到内存中的流</p>
<p>构造方法：</p>
<ul>
<li><code>public FileInputStream(File path)</code>：创建一个字节输入流管道与源文件对象接通</li>
<li><code>public FileInputStream(String pathName)</code>：创建一个字节输入流管道与文件路径对接，底层实质上创建 File 对象</li>
</ul>
<p>方法：</p>
<ul>
<li><code>public int read()</code>：每次读取一个字节返回，读取完毕会返回 -1</li>
<li><code>public int read(byte[] buffer)</code>：从字节输入流中读取字节到字节数组中去，返回读取的字节数量，没有字节可读返回 -1，<strong>byte 中新读取的数据默认是覆盖原数据</strong>，构造 String 需要设定长度</li>
<li><code>public String(byte[] bytes,int offset,int length)</code>：构造新的 String</li>
<li><code>public long transferTo(OutputStream out) </code>：从输入流中读取所有字节，并按读取的顺序，将字节写入给定的输出流</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一个一个字节读取英文和数字没有问题，但是读取中文输出无法避免乱码，因为会截断中文的字节。一个一个字节的读取数据，性能也较差，所以<strong>禁止使用上面的方案</strong></p>
<p>采取下面的方案：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 字节输出</h5>
<p>FileOutputStream 文件字节输出流：以内存为基准，把内存中的数据，按照字节的形式写出到磁盘文件中去</p>
<p>构造方法：</p>
<ul>
<li><code>public FileOutputStream(File file)</code>：创建一个字节输出流管道通向目标文件对象</li>
<li><code>public FileOutputStream(String file) </code>：创建一个字节输出流管道通向目标文件路径</li>
<li><code>public FileOutputStream(File file, boolean append)</code> : 创建一个追加数据的字节输出流管道到目标文件对象</li>
<li><code>public FileOutputStream(String file, boolean append)</code> : 创建一个追加数据的字节输出流管道通向目标文件路径</li>
</ul>
<p>API：</p>
<ul>
<li>
<p><code>public void write(int a)</code>：写一个字节出去</p>
</li>
<li>
<p><code>public void write(byte[] buffer)</code>：写一个字节数组出去</p>
</li>
<li>
<p><code>public void write(byte[] buffer , int pos , int len)</code>：写一个字节数组的一部分出去，从 pos 位置，写出 len 长度</p>
</li>
<li>
<p>FileOutputStream 字节输出流每次启动写数据的时候都会先清空之前的全部数据，重新写入：</p>
<ul>
<li><code>OutputStream os = new FileOutputStream("Demo/out05")</code>：覆盖数据管道</li>
<li><code>OutputStream os = new FileOutputStream("Demo/out05" , true)</code>：追加数据的管道</li>
</ul>
</li>
</ul>
<p>说明：</p>
<ul>
<li>字节输出流只能写字节出去，字节输出流默认是<strong>覆盖</strong>数据管道</li>
<li>换行用：<strong>os.write("\r\n".getBytes())</strong></li>
<li>关闭和刷新：刷新流可以继续使用，关闭包含刷新数据但是流就不能使用了</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 文件复制</h5>
<p>字节是计算机中一切文件的组成，所以字节流适合做一切文件的复制</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 字符流</h4>
<h5> 字符输入</h5>
<p>FileReader：文件字符输入流，以内存为基准，把磁盘文件的数据以字符的形式读入到内存，读取文本文件内容到内存中去</p>
<p>构造器：</p>
<ul>
<li><code>public FileReader(File file)</code>：创建一个字符输入流与源文件对象接通。</li>
<li><code>public FileReader(String filePath)</code>：创建一个字符输入流与源文件路径接通。</li>
</ul>
<p>方法：</p>
<ul>
<li><code>public int read()</code>：读取一个字符的编号返回，读取完毕返回 -1</li>
<li><code>public int read(char[] buffer)</code>：读取一个字符数组，读取多少个就返回多少个，读取完毕返回 -1</li>
</ul>
<p>结论：</p>
<ul>
<li>字符流一个一个字符的读取文本内容输出，可以解决中文读取输出乱码的问题，适合操作文本文件，但是一个一个字符的读取文本内容性能较差</li>
<li>字符流按照<strong>字符数组循环读取数据</strong>，可以解决中文读取输出乱码的问题，而且性能也较好</li>
</ul>
<p><strong>字符流不能复制图片，视频等类型的文件</strong>。字符流在读取完了字节数据后并没有直接往目的地写，而是先查编码表，查到对应的数据就将该数据写入目的地。如果查不到，则码表会将一些未知区域中的数据去 map 这些字节数据，然后写到目的地，这样的话就造成了源数据和目的数据的不一致。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 字符输出</h5>
<p>FileWriter：文件字符输出流，以内存为基准，把内存中的数据按照字符的形式写出到磁盘文件中去</p>
<p>构造器：</p>
<ul>
<li><code>public FileWriter(File file)</code>：创建一个字符输出流管道通向目标文件对象（覆盖数据管道）</li>
<li><code>public FileWriter(String filePath)</code>：创建一个字符输出流管道通向目标文件路径</li>
<li><code>public FileWriter(File file, boolean append)</code>：创建一个追加数据的字符输出流管道通向文件对象（追加数据管道）</li>
<li><code>public FileWriter(String filePath, boolean append)</code>：创建一个追加数据的字符输出流管道通向目标文件路径</li>
</ul>
<p>方法：</p>
<ul>
<li><code>public void write(int c)</code>：写一个字符出去</li>
<li><code>public void write(char[] buffer)</code>：写一个字符数组出去</li>
<li><code>public void write(String c, int pos, int len)</code>：写字符串的一部分出去</li>
<li><code>public void write(char[] buffer, int pos, int len)</code>：写字符数组的一部分出去</li>
<li><code>fw.write("\r\n")</code>：换行</li>
</ul>
<p>读写字符文件数据建议使用字符流</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 缓冲流</h4>
<h5> 基本介绍</h5>
<p>缓冲流可以提高字节流和字符流的读写数据的性能</p>
<p>缓冲流分为四类：</p>
<ul>
<li>BufferedInputStream：字节缓冲输入流，可以提高字节输入流读数据的性能</li>
<li>BufferedOutStream：字节缓冲输出流，可以提高字节输出流写数据的性能</li>
<li>BufferedReader：字符缓冲输入流，可以提高字符输入流读数据的性能</li>
<li>BufferedWriter：字符缓冲输出流，可以提高字符输出流写数据的性能</li>
</ul>
<hr>
<h5> 字节缓冲输入</h5>
<p>字节缓冲输入流：BufferedInputStream</p>
<p>作用：可以把低级的字节输入流包装成一个高级的缓冲字节输入流管道，提高字节输入流读数据的性能</p>
<p>构造器：<code>public BufferedInputStream(InputStream in)</code></p>
<p>原理：缓冲字节输入流管道自带了一个 8KB 的缓冲池，每次可以直接借用操作系统的功能最多提取 8KB 的数据到缓冲池中去，以后我们直接从缓冲池读取数据，所以性能较好</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 字节缓冲输出</h5>
<p>字节缓冲输出流：BufferedOutputStream</p>
<p>作用：可以把低级的字节输出流包装成一个高级的缓冲字节输出流，从而提高写数据的性能</p>
<p>构造器：<code>public BufferedOutputStream(OutputStream os)</code></p>
<p>原理：缓冲字节输出流自带了 8KB 缓冲池,数据就直接写入到缓冲池中去，性能提高了</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5> 字节流性能</h5>
<p>利用字节流的复制统计各种写法形式下缓冲流的性能执行情况</p>
<p>复制流：</p>
<ul>
<li>使用低级的字节流按照一个一个字节的形式复制文件</li>
<li>使用低级的字节流按照一个一个字节数组的形式复制文件</li>
<li>使用高级的缓冲字节流按照一个一个字节的形式复制文件</li>
<li>使用高级的缓冲字节流按照一个一个字节数组的形式复制文件</li>
</ul>
<p>高级的缓冲字节流按照一个一个字节数组的形式复制文件，性能最高，建议使用</p>
<hr>
<h5> 字符缓冲输入</h5>
<p>字符缓冲输入流：BufferedReader</p>
<p>作用：字符缓冲输入流把字符输入流包装成高级的缓冲字符输入流，可以提高字符输入流读数据的性能。</p>
<p>构造器：<code>public BufferedReader(Reader reader)</code></p>
<p>原理：缓冲字符输入流默认会有一个 8K 的字符缓冲池,可以提高读字符的性能</p>
<p>按照行读取数据的功能：<code>public String readLine()</code>  读取一行数据返回，读取完毕返回 null</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 字符缓冲输出</h5>
<p>符缓冲输出流：BufferedWriter</p>
<p>作用：把低级的字符输出流包装成一个高级的缓冲字符输出流，提高写字符数据的性能。</p>
<p>构造器：<code>public BufferedWriter(Writer writer)</code></p>
<p>原理：高级的字符缓冲输出流多了一个 8K 的字符缓冲池，写数据性能极大提高了</p>
<p>字符缓冲输出流多了一个换行的特有功能：<code>public void newLine()</code>  <strong>新建一行</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 高效原因</h5>
<p>字符型缓冲流高效的原因：（空间换时间）</p>
<ul>
<li>BufferedReader：每次调用 read 方法，只有第一次从磁盘中读取了 8192（<strong>8k</strong>）个字符，存储到该类型对象的缓冲区数组中，将其中一个返回给调用者，再次调用 read 方法时，就不需要访问磁盘，直接从缓冲区中拿出一个数据即可，提升了效率</li>
<li>BufferedWriter：每次调用 write 方法，不会直接将字符刷新到文件中，而是存储到字符数组中，等字符数组写满了，才一次性刷新到文件中，减少了和磁盘交互的次数，提升了效率</li>
</ul>
<p>字节型缓冲流高效的原因：</p>
<ul>
<li>BufferedInputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 read() 方法想获取一个字节的时候，该对象从文件中一次性读取了 8192 个字节到数组中，只返回了第一个字节给调用者。将来调用者再次调用 read 方法时，当前对象就不需要再次访问磁盘，只需要从数组中取出一个字节返回给调用者即可，由于读取的是数组，所以速度非常快。当 8192 个字节全都读取完成之后，再需要读取一个字节，就得让该对象到文件中读取下一个 8192 个字节</li>
<li>BufferedOutputStream：在该类型中准备了一个数组，存储字节信息，当外界调用 write 方法想写出一个字节的时候，该对象直接将这个字节存储到了自己的数组中，而不刷新到文件中。一直到该数组所有 8192 个位置全都占满，该对象才把这个数组中的所有数据一次性写出到目标文件中。如果最后一次循环没有将数组写满，最终在关闭流对象的时候，也会将该数组中的数据刷新到文件中。</li>
</ul>
<p>注意：<strong>字节流和字符流，都是装满时自动写出，或者没满时手动 flush 写出，或 close 时刷新写出</strong></p>
<hr>
<h4> 转换流</h4>
<h5> 乱码问题</h5>
<p>字符流读取：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>如果代码编码和读取的文件编码一致，字符流读取的时候不会乱码</li>
<li>如果代码编码和读取的文件编码不一致，字符流读取的时候会乱码</li>
</ul>
<hr>
<h5> 字符输入</h5>
<p>字符输入转换流：InputStreamReader</p>
<p>作用：解决字符流读取不同编码的乱码问题，把原始的<strong>字节流</strong>按照默认的编码或指定的编码<strong>转换成字符输入流</strong></p>
<p>构造器：</p>
<ul>
<li><code>public InputStreamReader(InputStream is)</code>：使用当前代码默认编码 UTF-8 转换成字符流</li>
<li><code>public InputStreamReader(InputStream is, String charset)</code>：指定编码把字节流转换成字符流</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 字符输出</h5>
<p>字符输出转换流：OutputStreamWriter</p>
<p>作用：可以指定编码<strong>把字节输出流转换成字符输出流</strong>，可以指定写出去的字符的编码</p>
<p>构造器：</p>
<ul>
<li><code>public OutputStreamWriter(OutputStream os)</code>：用默认编码 UTF-8 把字节输出流转换成字符输出流</li>
<li><code>public OutputStreamWriter(OutputStream os, String charset)</code>：指定编码把字节输出流转换成</li>
</ul>
<div class="language-Java line-numbers-mode" data-ext="Java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 序列化</h4>
<h5> 基本介绍</h5>
<p>对象序列化：把 Java 对象转换成字节序列的过程，将对象写入到 IO 流中，对象 =&gt; 文件中</p>
<p>对象反序列化：把字节序列恢复为 Java 对象的过程，从 IO 流中恢复对象，文件中 =&gt; 对象</p>
<p>transient 关键字修饰的成员变量，将不参与序列化</p>
<hr>
<h5> 序列化</h5>
<p>对象序列化流（对象字节输出流）：ObjectOutputStream</p>
<p>作用：把内存中的 Java 对象数据保存到文件中去</p>
<p>构造器：<code>public ObjectOutputStream(OutputStream out)</code></p>
<p>序列化方法：<code>public final void writeObject(Object obj)</code></p>
<p>注意：对象如果想参与序列化，对象必须实现序列化接口 <strong>implements Serializable</strong> ，否则序列化失败</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 反序列</h5>
<p>对象反序列化（对象字节输入流）：ObjectInputStream</p>
<p>作用：读取序列化的对象文件恢复到 Java 对象中</p>
<p>构造器：<code>public ObjectInputStream(InputStream is)</code></p>
<p>方法：<code>public final Object readObject()</code></p>
<p>序列化版本号：<code>private static final long serialVersionUID = 2L</code></p>
<p>注意：序列化使用的版本号和反序列化使用的版本号一致才可以正常反序列化，否则报错</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 打印流</h4>
<p>打印流 PrintStream / PrintWriter</p>
<p>打印流的作用：</p>
<ul>
<li>可以方便，快速的写数据出去，可以实现打印什么类型，就是什么类型</li>
<li>PrintStream/PrintWriter 不光可以打印数据，还可以写字节数据和字符数据出去</li>
<li><strong>System.out.print() 底层基于打印流实现的</strong></li>
</ul>
<p>构造器：</p>
<ul>
<li><code>public PrintStream(OutputStream os)</code></li>
<li><code>public PrintStream(String filepath)</code></li>
</ul>
<p>System 类：</p>
<ul>
<li><code>public static void setOut(PrintStream out)</code>：让系统的输出流向打印流</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Close</h3>
<p>try-with-resources：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>资源类一定是实现了 Closeable 接口，实现这个接口的类就是资源</p>
<p>有 close() 方法，try-with-resources 会自动调用它的 close() 关闭资源</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Properties</h3>
<p>Properties：属性集对象。就是一个 Map 集合，一个键值对集合</p>
<p>核心作用：Properties 代表的是一个属性文件，可以把键值对数据存入到一个属性文件</p>
<p>属性文件：后缀是 <code>.properties</code> 结尾的文件，里面的内容都是 key=value</p>
<p>Properties 方法：</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object setProperty(String key, String value)</td>
<td>设置集合的键和值，底层调用 Hashtable 方法 put</td>
</tr>
<tr>
<td>String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性</td>
</tr>
<tr>
<td>Set&lt;String&gt;   stringPropertyNames()</td>
<td>所有键的名称的集合</td>
</tr>
<tr>
<td>synchronized void load(Reader r)</td>
<td>从输入字符流读取属性列表（键和元素对）</td>
</tr>
<tr>
<td>synchronized void load(InputStream in)</td>
<td>加载属性文件的数据到属性集对象中去</td>
</tr>
<tr>
<td>void store(Writer w, String comments)</td>
<td>将此属性列表(键和元素对)写入 Properties 表</td>
</tr>
<tr>
<td>void store(OutputStream os, String comments)</td>
<td>保存数据到属性文件中去</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> RandomIO</h3>
<p>RandomAccessFile 类：该类的实例支持读取和写入随机访问文件</p>
<p>构造器：</p>
<ul>
<li><code>RandomAccessFile(File file, String mode)</code>：创建随机访问文件流，从 File 参数指定的文件读取，可选择写入</li>
<li><code>RandomAccessFile(String name, String mode)</code>：创建随机访问文件流，从指定名称文件读取，可选择写入文件</li>
</ul>
<p>常用方法：</p>
<ul>
<li><code>public void seek(long pos)</code>：设置文件指针偏移，从该文件开头测量，发生下一次读取或写入(插入+覆盖)</li>
<li><code>public void write(byte[] b)</code>：从指定的字节数组写入 b.length 个字节到该文件</li>
<li><code>public int read(byte[] b)</code>：从该文件读取最多 b.length 个字节的数据到字节数组</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Commons</h3>
<p>commons-io 是 apache 提供的一组有关 IO 操作的类库，可以提高 IO 功能开发的效率</p>
<p>commons-io 工具包提供了很多有关 IO 操作的类：</p>
<table>
<thead>
<tr>
<th>包</th>
<th style="text-align:left">功能描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://org.apache.commons.io" target="_blank" rel="noopener noreferrer">org.apache.commons.io</a></td>
<td style="text-align:left">有关 Streams、Readers、Writers、Files 的工具类</td>
</tr>
<tr>
<td>org.apache.commons.io.input</td>
<td style="text-align:left">输入流相关的实现类，包含 Reader 和 InputStream</td>
</tr>
<tr>
<td>org.apache.commons.io.output</td>
<td style="text-align:left">输出流相关的实现类，包含 Writer 和 OutputStream</td>
</tr>
<tr>
<td>org.apache.commons.io.serialization</td>
<td style="text-align:left">序列化相关的类</td>
</tr>
</tbody>
</table>
<p>IOUtils 和 FileUtils 可以方便的复制文件和文件夹</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 反射</h2>
<h3> 测试框架</h3>
<p>单元测试的经典框架：Junit，是 Java 语言编写的第三方单元测试框架</p>
<p>单元测试：</p>
<ul>
<li>单元：在 Java 中，一个类就是一个单元</li>
<li>单元测试：Junit 编写的一小段代码，用来对某个类中的某个方法进行功能测试或业务逻辑测试</li>
</ul>
<p>Junit 单元测试框架的作用：</p>
<ul>
<li>用来对类中的方法功能进行有目的的测试，以保证程序的正确性和稳定性</li>
<li>能够<strong>独立的</strong>测试某个方法或者所有方法的预期正确性</li>
</ul>
<p>测试方法注意事项：<strong>必须是 public 修饰的，没有返回值，没有参数，使用注解@Test修饰</strong></p>
<p>Junit常用注解（Junit 4.xxxx 版本），@Test 测试方法：</p>
<ul>
<li>@Before：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li>
<li>@After：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li>
<li>@BeforeClass：用来静态修饰方法，该方法会在所有测试方法之前<strong>只</strong>执行一次</li>
<li>@AfterClass：用来静态修饰方法，该方法会在所有测试方法之后<strong>只</strong>执行一次</li>
</ul>
<p>Junit 常用注解（Junit5.xxxx 版本），@Test 测试方法：</p>
<ul>
<li>@BeforeEach：用来修饰实例方法，该方法会在每一个测试方法执行之前执行一次</li>
<li>@AfterEach：用来修饰实例方法，该方法会在每一个测试方法执行之后执行一次</li>
<li>@BeforeAll：用来静态修饰方法，该方法会在所有测试方法之前只执行一次</li>
<li>@AfterAll：用来静态修饰方法，该方法会在所有测试方法之后只执行一次</li>
</ul>
<p>作用：</p>
<ul>
<li>开始执行的方法：初始化资源</li>
<li>执行完之后的方法：释放资源</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 介绍反射</h3>
<p>反射是指对于任何一个类，在"运行的时候"都可以直接得到这个类全部成分</p>
<ul>
<li>
<p>构造器对象：Constructor</p>
</li>
<li>
<p>成员变量对象：Field</p>
</li>
<li>
<p>成员方法对象：Method</p>
</li>
</ul>
<p>核心思想：在运行时获取类编译后的字节码文件对象，然后解析类中的全部成分</p>
<p>反射提供了一个 Class 类型：HelloWorld.java → javac → HelloWorld.class</p>
<ul>
<li><code>Class c = HelloWorld.class</code></li>
</ul>
<p>注意：反射是工作在<strong>运行时</strong>的技术，只有运行之后才会有 class 类对象</p>
<p>作用：可以在运行时得到一个类的全部成分然后操作，破坏封装性，也可以破坏泛型的约束性。</p>
<p>反射的优点：</p>
<ul>
<li>可扩展性：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类</li>
<li>类浏览器和可视化开发环境：一个类浏览器需要可以枚举类的成员，可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码</li>
<li>调试器和测试工具： 调试器需要能够检查一个类里的私有成员，测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率</li>
</ul>
<p>反射的缺点：</p>
<ul>
<li><strong>性能开销</strong>：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化，反射操作的效率要比那些非射操作低得多，应该避免在经常被执行的代码或对性能要求很高的程序中使用反射</li>
<li>安全限制：使用反射技术要求程序必须在一个没有安全限制的环境中运行，如果一个程序必须在有安全限制的环境中运行</li>
<li>内部暴露：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化</li>
</ul>
<hr>
<h3> 获取元素</h3>
<h4> 获取类</h4>
<p>反射技术的第一步是先得到 Class 类对象，有三种方式获取：</p>
<ul>
<li>类名.class</li>
<li>类的对象.getClass()</li>
<li>Class.forName("类的全限名")：<code>public static Class&lt;?&gt; forName(String className) </code></li>
</ul>
<p>Class 类下的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getSimpleName()</td>
<td>获得类名字符串：类名</td>
</tr>
<tr>
<td>String getName()</td>
<td>获得类全名：包名+类名</td>
</tr>
<tr>
<td>T newInstance()</td>
<td>创建 Class 对象关联类的对象，底层是调用无参数构造器，已经被淘汰</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 获取构造</h4>
<p>获取构造器的 API：</p>
<ul>
<li>Constructor getConstructor(Class... parameterTypes)：根据参数匹配获取某个构造器，只能拿 public 修饰的构造器</li>
<li>Constructor getDeclaredConstructor(Class... parameterTypes)：根据参数匹配获取某个构造器，只要申明就可以定位，不关心权限修饰符</li>
<li>Constructor[] getConstructors()：获取所有的构造器，只能拿 public 修饰的构造器</li>
<li>Constructor[] getDeclaredConstructors()：获取所有构造器，只要申明就可以定位，不关心权限修饰符</li>
</ul>
<p>Constructor 的常用 API：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>T newInstance(Object... initargs)</td>
<td>创建对象，注入构造器需要的数据</td>
</tr>
<tr>
<td>void setAccessible(true)</td>
<td>修改访问权限，true 攻破权限（暴力反射）</td>
</tr>
<tr>
<td>String getName()</td>
<td>以字符串形式返回此构造函数的名称</td>
</tr>
<tr>
<td>int getParameterCount()</td>
<td>返回参数数量</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes</td>
<td>返回参数类型数组</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 获取变量</h4>
<p>获取 Field 成员变量 API：</p>
<ul>
<li>Field getField(String name)：根据成员变量名获得对应 Field 对象，只能获得 public 修饰</li>
<li>Field getDeclaredField(String name)：根据成员变量名获得对应 Field 对象，所有申明的变量</li>
<li>Field[] getFields()：获得所有的成员变量对应的 Field 对象，只能获得 public 的</li>
<li>Field[] getDeclaredFields()：获得所有的成员变量对应的 Field 对象，只要申明了就可以得到</li>
</ul>
<p>Field 的方法：给成员变量赋值和取值</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void set(Object obj, Object value)</td>
<td>给对象注入某个成员变量数据，<strong>obj 是对象</strong>，value 是值</td>
</tr>
<tr>
<td>Object get(Object obj)</td>
<td>获取指定对象的成员变量的值，<strong>obj 是对象</strong>，没有对象为 null</td>
</tr>
<tr>
<td>void setAccessible(true)</td>
<td>暴力反射，设置为可以直接访问私有类型的属性</td>
</tr>
<tr>
<td>Class getType()</td>
<td>获取属性的类型，返回 Class 对象</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取属性的名称</td>
</tr>
</tbody>
</table>
<div class="language-Java line-numbers-mode" data-ext="Java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 获取方法</h4>
<p>获取 Method 方法 API：</p>
<ul>
<li>Method getMethod(String name,Class...args)：根据方法名和参数类型获得方法对象，public 修饰</li>
<li>Method getDeclaredMethod(String name,Class...args)：根据方法名和参数类型获得方法对象，包括 private</li>
<li>Method[] getMethods()：获得类中的所有成员方法对象返回数组，只能获得 public 修饰且包含父类的</li>
<li>Method[] getDeclaredMethods()：获得类中的所有成员方法对象，返回数组，只获得本类申明的方法</li>
</ul>
<p>Method 常用 API：</p>
<ul>
<li>public Object invoke(Object obj, Object... args)：使用指定的参数调用由此方法对象，obj 对象名</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 暴力攻击</h3>
<p>泛型只能工作在编译阶段，运行阶段泛型就消失了，反射工作在运行时阶段</p>
<ol>
<li>反射可以破坏面向对象的封装性（暴力反射）</li>
<li>同时可以破坏泛型的约束性</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 注解</h2>
<h3> 概念</h3>
<p>注解：类的组成部分，可以给类携带一些额外的信息，提供一种安全的类似注释标记的机制，用来将任何信息或元数据（metadata）与程序元素（类、方法、成员变量等）进行关联</p>
<ul>
<li>注解是给编译器或 JVM 看的，编译器或 JVM 可以根据注解来完成对应的功能</li>
<li>注解类似修饰符，应用于包、类型、构造方法、方法、成员变量、参数及本地变量的声明语句中</li>
<li><strong>父类中的注解是不能被子类继承的</strong></li>
</ul>
<p>注解作用：</p>
<ul>
<li>标记</li>
<li>框架技术多半都是在使用注解和反射，都是属于框架的底层基础技术</li>
<li>在编译时进行格式检查，比如方法重写约束 @Override、函数式接口约束 @FunctionalInterface.</li>
</ul>
<hr>
<h3> 注解格式</h3>
<p>定义格式：自定义注解用 @interface 关键字，注解默认可以标记很多地方</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用注解的格式：@注解名</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 注解属性</h3>
<h4> 普通属性</h4>
<p>注解可以有属性，<strong>属性名必须带 ()</strong>，在用注解的时候，属性必须赋值，除非属性有默认值</p>
<p>属性的格式：</p>
<ul>
<li>格式 1：数据类型 属性名()</li>
<li>格式 2：数据类型 属性名() default 默认值</li>
</ul>
<p>属性适用的数据类型:</p>
<ul>
<li>八种数据数据类型（int，short，long，double，byte，char，boolean，float）和 String、Class</li>
<li>以上类型的数组形式都支持</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 特殊属性</h4>
<p>注解的特殊属性名称：value</p>
<ul>
<li>如果只有一个 value 属性的情况下，使用 value 属性的时候可以省略 value 名称不写</li>
<li>如果有多个属性，且多个属性没有默认值，那么 value 是不能省略的</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 元注解</h3>
<p>元注解是 sun 公司提供的，用来注解自定义注解</p>
<p>元注解有四个：</p>
<ul>
<li>
<p>@Target：约束自定义注解可以标记的范围，默认值为任何元素，表示该注解用于什么地方，可用值定义在 ElementType 类中：</p>
<ul>
<li><code>ElementType.CONSTRUCTOR</code>：用于描述构造器</li>
<li><code>ElementType.FIELD</code>：成员变量、对象、属性（包括 enum 实例）</li>
<li><code>ElementType.LOCAL_VARIABLE</code>：用于描述局部变量</li>
<li><code>ElementType.METHOD</code>：用于描述方法</li>
<li><code>ElementType.PACKAGE</code>：用于描述包</li>
<li><code>ElementType.PARAMETER</code>：用于描述参数</li>
<li><code>ElementType.TYPE</code>：用于描述类、接口（包括注解类型）或 enum 声明</li>
</ul>
</li>
<li>
<p>@Retention：定义该注解的生命周期，申明注解的作用范围：编译时，运行时，可使用的值定义在 RetentionPolicy 枚举类中：</p>
<ul>
<li><code>RetentionPolicy.SOURCE</code>：在编译阶段丢弃，这些注解在编译结束之后就不再有任何意义，只作用在源码阶段，生成的字节码文件中不存在，<code>@Override</code>、<code>@SuppressWarnings</code> 都属于这类注解</li>
<li><code>RetentionPolicy.CLASS</code>：在类加载时丢弃，在字节码文件的处理中有用，运行阶段不存在，默认值</li>
<li><code>RetentionPolicy.RUNTIME</code> : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息，自定义的注解通常使用这种方式</li>
</ul>
</li>
<li>
<p>@Inherited：表示修饰的自定义注解可以被子类继承</p>
</li>
<li>
<p>@Documented：表示是否将自定义的注解信息添加在 Java 文档中</p>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 注解解析</h3>
<p>开发中经常要知道一个类的成分上面到底有哪些注解，注解有哪些属性数据，这都需要进行注解的解析</p>
<p>注解解析相关的接口：</p>
<ul>
<li>Annotation：注解类型，该类是所有注解的父类，注解都是一个 Annotation 的对象</li>
<li>AnnotatedElement：该接口定义了与注解解析相关的方法</li>
<li>Class、Method、Field、Constructor 类成分：实现 AnnotatedElement 接口，拥有解析注解的能力</li>
</ul>
<p>Class 类 API ：</p>
<ul>
<li><code>Annotation[] getDeclaredAnnotations()</code>：获得当前对象上使用的所有注解，返回注解数组</li>
<li><code>T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li>
<li><code>T getAnnotation(Class&lt;T&gt; annotationClass)</code>：根据注解类型获得对应注解对象</li>
<li><code>boolean isAnnotationPresent(Class&lt;Annotation&gt; class)</code>：判断对象是否使用了指定的注解</li>
<li><code>boolean isAnnotation()</code>：此 Class 对象是否表示注释类型</li>
</ul>
<p>注解原理：注解本质是<strong>特殊接口</strong>，继承了 <code>Annotation</code> ，其具体实现类是 Java 运行时生成的<strong>动态代理类</strong>，通过反射获取注解时，返回的是运行时生成的动态代理对象 <code>$Proxy1</code>，通过代理对象调用自定义注解（接口）的方法，回调 <code>AnnotationInvocationHandler</code> 的 <code>invoke</code> 方法，该方法会从 <code>memberValues</code>  这个 Map 中找出对应的值，而 <code>memberValues</code> 的来源是 Java 常量池</p>
<p>解析注解数据的原理：注解在哪个成分上，就先拿哪个成分对象，比如注解作用在类上，则要该类的 Class 对象，再来拿上面的注解</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> XML</h2>
<h3> 概述</h3>
<p>XML介绍：</p>
<ul>
<li>XML 指可扩展标记语言（EXtensible&nbsp;Markup&nbsp;Language）</li>
<li>XML 是一种<strong>标记语言</strong>，很类似 HTML，HTML文件也是XML文档</li>
<li>XML 的设计宗旨是<strong>传输数据</strong>，而非显示数据</li>
<li>XML 标签没有被预定义，需要自行定义标签</li>
<li>XML 被设计为具有自我描述性，易于阅读</li>
<li>XML 是&nbsp;W3C 的推荐标准</li>
</ul>
<p><strong>XML 与 HTML 的区别</strong>：</p>
<ul>
<li>XML 不是 HTML 的替代，XML 和 HTML 为不同的目的而设计</li>
<li>XML 被设计为传输和存储数据，其焦点是数据的内容；XMl标签可自定义，便于阅读</li>
<li>HTML 被设计用来显示数据，其焦点是数据的外观；HTML标签被预设好，便于浏览器识别</li>
<li>HTML 旨在显示信息，而 XML 旨在传输信息</li>
</ul>
<hr>
<h3> 创建</h3>
<p>person.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 组成</h3>
<p>XML 文件中常见的组成元素有:文档声明、元素、属性、注释、转义字符、字符区。文件后缀名为 xml</p>
<ul>
<li>
<p><strong>文档声明</strong><br>
<code>&lt;?xml version="1.0" encoding="utf-8" standalone="yes" ?&gt;</code>，文档声明必须在第一行，以 <code>&lt;?xml</code> 开头，以 <code>?&gt;</code> 结束，</p>
<ul>
<li>version：指定 XML 文档版本。必须属性，这里一般选择 1.0</li>
<li>enconding：指定当前文档的编码，可选属性，默认值是 utf-8</li>
<li>standalone：该属性不是必须的，描述 XML 文件是否依赖其他的 xml 文件，取值为 yes/no</li>
</ul>
</li>
<li>
<p><strong>元素</strong></p>
<ul>
<li>格式 1：<code>&lt;person&gt;&lt;/person&gt; </code></li>
<li>格式 2：<code>&lt;person/&gt;</code></li>
<li>普通元素的结构由开始标签、元素体、结束标签组成</li>
<li>标签由一对尖括号和合法标识符组成，标签必须成对出现。特殊的标签可以不成对，必须有结束标记 &lt;/&gt;</li>
</ul>
</li>
<li>
<p>元素体：可以是元素，也可以是文本，例如：<code>&lt;person&gt;&lt;name&gt;张三&lt;/name&gt;&lt;/person&gt;</code></p>
<ul>
<li>空元素：空元素只有标签，而没有结束标签，但<strong>元素必须自己闭合</strong>，例如：<code>&lt;sex/&gt;</code></li>
<li>元素命名：区分大小写、不能使用空格冒号、不建议用 XML、xml、Xml 等开头</li>
<li>必须存在一个根标签，有且只能有一个</li>
</ul>
</li>
<li>
<p><strong>属性</strong>：<code>&lt;name id="1" desc="高富帅"&gt;</code></p>
<ul>
<li>属性是元素的一部分，它必须出现在元素的开始标签中</li>
<li>属性的定义格式：<code>属性名=“属性值”</code>，其中属性值必须使用单引或双引号括起来</li>
<li>一个元素可以有 0~N 个属性，但一个元素中不能出现同名属性</li>
<li>属性名不能使用空格 , 不要使用冒号等特殊字符，且必须以字母开头</li>
</ul>
</li>
<li>
<p><strong>注释</strong>：<!--注释内容--><br>
XML的注释与HTML相同，既以 <code>&lt;!--</code> 开始，<code>--&gt;</code> 结束。</p>
</li>
<li>
<p><strong>转义字符</strong><br>
XML 中的转义字符与 HTML 一样。因为很多符号已经被文档结构所使用，所以在元素体或属性值中想使用这些符号就必须使用转义字符（也叫实体字符），例如："&gt;"、"&lt;"、"'"、"""、"&amp;"<br>
XML 中仅有字符 &lt; 和 &amp; 是非法的。省略号、引号和大于号是合法的，把它们替换为实体引用</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">预定义的转义字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center"><code>&amp;lt;</code></td>
<td style="text-align:center">小于</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center"><code> &amp;gt;</code></td>
<td style="text-align:center">大于</td>
</tr>
<tr>
<td style="text-align:center">"</td>
<td style="text-align:center"><code> &amp;quot;</code></td>
<td style="text-align:center">双引号</td>
</tr>
<tr>
<td style="text-align:center">'</td>
<td style="text-align:center"><code> &amp;apos;</code></td>
<td style="text-align:center">单引号</td>
</tr>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center"><code> &amp;amp;</code></td>
<td style="text-align:center">和号</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>字符区</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）</li>
</ul>
</li>
<li>
<p>CDATA 部分由 "&lt;![CDATA[" 开始，由 "]]&gt;" 结束；</p>
<ul>
<li>
<p>大量的转义字符在xml文档中时，会使XML文档的可读性大幅度降低。这时使用CDATA段就会好一些</p>
</li>
<li>
<p>规则：</p>
<ul>
<li>CDATA 部分不能包含字符串 ]]&gt;，也不允许嵌套的 CDATA 部分</li>
<li>标记 CDATA 部分结尾的 ]]&gt; 不能包含空格或折行</li>
</ul>
</li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 约束</h3>
<h4> DTD</h4>
<p>DTD 是文档类型定义（Document Type Definition）。DTD 可以定义在 XML 文档中出现的元素、这些元素出现的次序、它们如何相互嵌套以及 XML 文档结构的其它详细信息。</p>
<p>DTD 规则：</p>
<ul>
<li>
<p>约束元素的嵌套层级</p>
<div class="language-dtd line-numbers-mode" data-ext="dtd"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>约束元素体里面的数据</p>
</li>
<li>
<p>语法</p>
<div class="language-dtd line-numbers-mode" data-ext="dtd"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>判断元素<br>
简单元素：没有子元素。<br>
复杂元素：有子元素的元素；</p>
<ul>
<li>标签类型</li>
</ul>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>代码写法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>PCDATA</td>
<td>(#PCDATA)</td>
<td>被解释的字符串数据</td>
</tr>
<tr>
<td>EMPTY</td>
<td>EMPTY</td>
<td>即空元素，例如&lt;hr/&gt;</td>
</tr>
<tr>
<td>ANY</td>
<td>ANY</td>
<td>即任意类型</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>代码</p>
<div class="language-dtd line-numbers-mode" data-ext="dtd"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>数量词</p>
<table>
<thead>
<tr>
<th>数量词符号</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>空</td>
<td>表示元素出现一次</td>
</tr>
<tr>
<td>*</td>
<td>表示元素可以出现0到多个</td>
</tr>
<tr>
<td>+</td>
<td>表示元素可以出现至少1个</td>
</tr>
<tr>
<td>?</td>
<td>表示元素可以是0或1个</td>
</tr>
<tr>
<td>,</td>
<td>表示元素需要按照顺序显示</td>
</tr>
<tr>
<td>|</td>
<td>表示元素需要选择其中的某一个</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>属性声明</p>
<ul>
<li>
<p>语法</p>
<div class="language-dtd line-numbers-mode" data-ext="dtd"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>属性类型</p>
<table>
<thead>
<tr>
<th>属性类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>CDATA</td>
<td>代表属性是文本字符串， eg:&lt;!ATTLIST 属性名 CDATA 属性说明&gt;</td>
</tr>
<tr>
<td>ID</td>
<td>代码该属性值唯一，不能以数字开头， eg:&lt;!ATTLIST 属性名 ID 属性说明&gt;</td>
</tr>
<tr>
<td>ENUMERATED</td>
<td>代表属性值在指定范围内进行枚举 Eg:&lt;!ATTLIST属性名 (社科类|工程类|教育类) "社科类"&gt; "社科类"是默认值，属性如果不设置默认值就是"社科类"</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>属性说明</p>
<table>
<thead>
<tr>
<th>属性说明</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>#REQUIRED</td>
<td>代表属性是必须有的</td>
</tr>
<tr>
<td>#IMPLIED</td>
<td>代表属性可有可无</td>
</tr>
<tr>
<td>#FIXED</td>
<td>代表属性为固定值，实现方式：book_info CDATA #FIXED "固定值"</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>代码</p>
<div class="language-dtd line-numbers-mode" data-ext="dtd"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
<hr>
<h4> Schema</h4>
<p>XSD 定义：</p>
<ol>
<li>Schema 语言也可作为 XSD（XML Schema Definition）</li>
<li>Schema 约束文件本身也是一个 XML 文件，符合 XML 的语法，这个文件的后缀名 .xsd</li>
<li>一个 XML 中可以引用多个 Schema 约束文件，多个 Schema 使用名称空间区分（名称空间类似于 Java 包名）</li>
<li>dtd 里面元素类型的取值比较单一常见的是 PCDATA 类型，但是在 Schema 里面可以支持很多个数据类型</li>
<li><strong>Schema 文件约束 XML 文件的同时也被别的文件约束着</strong></li>
</ol>
<p>XSD 规则：</p>
<ol>
<li>创建一个文件，这个文件的后缀名为 .xsd</li>
<li>定义文档声明</li>
<li>schema 文件的根标签为： &lt;schema&gt;</li>
<li>在 <code>&lt;schema&gt; </code>中定义属性：
<ul>
<li>xmlns=<a href="http://www.w3.org/2001/XMLSchema" target="_blank" rel="noopener noreferrer">http://www.w3.org/2001/XMLSchema</a></li>
<li>代表当前文件时约束别人的，同时这个文件也对该 Schema 进行约束</li>
</ul>
</li>
<li>在&lt;schema&gt;中定义属性 ：
<ul>
<li>targetNamespace = 唯一的 url 地址，指定当前这个 schema 文件的名称空间。</li>
<li><strong>名称空间</strong>：当其他 xml 使用该 schema 文件，需要引入此空间</li>
</ul>
</li>
<li>在&lt;schema&gt;中定义属性 ：
<ul>
<li>elementFormDefault="qualified“，表示当前 schema 文件是一个质量良好的文件。</li>
</ul>
</li>
<li>通过 element 定义元素</li>
<li><strong>判断当前元素是简单元素还是复杂元素</strong></li>
</ol>
<p>person.xsd</p>
<div class="language-scheme line-numbers-mode" data-ext="scheme"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Dom4J</h3>
<h4> 解析</h4>
<p>XML 解析就是从 XML 中获取到数据，DOM 是解析思想</p>
<p>DOM（Document Object Model）：文档对象模型，把文档的各个组成部分看做成对应的对象，把 XML 文件全部加载到内存，在内存中形成一个树形结构，再获取对应的值</p>
<p>Dom4J 实现：</p>
<ul>
<li>
<p>Dom4J 解析器构造方法：<code>SAXReader saxReader = new SAXReader()</code></p>
</li>
<li>
<p>SAXReader 常用 API：</p>
<ul>
<li><code>public Document read(File file)</code>：Reads a Document from the given File</li>
<li><code>public Document read(InputStream in)</code>：Reads a Document from the given stream using SAX</li>
</ul>
</li>
<li>
<p>Java Class 类 API：</p>
<ul>
<li><code>public InputStream getResourceAsStream(String path)</code>：加载文件成为一个字节输入流返回</li>
</ul>
</li>
</ul>
<hr>
<h4> 根元素</h4>
<p>Document 方法：<code>Element getRootElement()</code> 获取根元素</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 子元素</h4>
<p>Element 元素的 API:</p>
<ul>
<li>String getName()：取元素的名称。</li>
<li>List&lt;Element&gt; elements()：获取当前元素下的全部子元素（一级）</li>
<li>List&lt;Element&gt; elements(String name)：获取当前元素下的指定名称的全部子元素（一级）</li>
<li>Element element(String name)：获取当前元素下的指定名称的某个子元素，默认取第一个（一级）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 属性</h4>
<p>Element 元素的 API：</p>
<ul>
<li>List&lt;Attribute&gt; attributes()：获取元素的全部属性对象</li>
<li>Attribute attribute(String name)：根据名称获取某个元素的属性对象</li>
<li>String attributeValue(String var)：直接获取某个元素的某个属性名称的值</li>
</ul>
<p>Attribute 对象的 API：</p>
<ul>
<li>String getName()：获取属性名称</li>
<li>String getValue()：获取属性值</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 文本</h4>
<p>Element：</p>
<ul>
<li>String elementText(String name)：可以直接获取当前元素的子元素的文本内容</li>
<li>String elementTextTrim(String name)：去前后空格,直接获取当前元素的子元素的文本内容</li>
<li>String getText()：直接获取当前元素的文本内容</li>
<li>String getTextTrim()：去前后空格,直接获取当前元素的文本内容</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> XPath</h3>
<p>Dom4J 可以用于解析整个 XML 的数据，但是如果要检索 XML 中的某些信息，建议使用 XPath</p>
<p>XPath 常用API：</p>
<ul>
<li>List&lt;Node&gt; selectNodes(String var1) : 检索出一批节点集合</li>
<li>Node selectSingleNode(String var1) : 检索出一个节点返回</li>
</ul>
<p>XPath 提供的四种检索数据的写法：</p>
<ol>
<li>绝对路径：/根元素/子元素/子元素</li>
<li>相对路径：./子元素/子元素 (.代表了当前元素)</li>
<li>全文搜索：
<ul>
<li>//元素：在全文找这个元素</li>
<li>//元素1/元素2：在全文找元素1下面的一级元素 2</li>
<li>//元素1//元素2：在全文找元素1下面的全部元素 2</li>
</ul>
</li>
<li>属性查找：
<ul>
<li>//@属性名称：在全文检索属性对象</li>
<li>//元素[@属性名称]：在全文检索包含该属性的元素对象</li>
<li>//元素[@属性名称=值]：在全文检索包含该属性的元素且属性值为该值的元素对象</li>
</ul>
</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> SDP</h2>
<h3> 单例模式</h3>
<h4> 基本介绍</h4>
<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一，提供了一种创建对象的最佳方式</p>
<p>单例设计模式分类两种：</p>
<ul>
<li>
<p>饿汉式：类加载就会导致该单实例对象被创建</p>
</li>
<li>
<p>懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>
</li>
</ul>
<hr>
<h4> 饿汉式</h4>
<p>饿汉式在类加载的过程导致该单实例对象被创建，<strong>虚拟机会保证类加载的线程安全</strong>，但是如果只是为了加载该类不需要实例，则会造成内存的浪费</p>
<ul>
<li>
<p>静态变量的方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>加 final 修饰，所以不会被子类继承，防止子类中不适当的行为覆盖父类的方法，破坏了单例</p>
</li>
<li>
<p>防止反序列化破坏单例的方式：</p>
<ul>
<li>
<p>对单例声明 transient，然后实现 readObject(ObjectInputStream in) 方法，复用原来的单例</p>
<p>条件：访问权限为 private/protected、返回值必须是 Object、异常可以不抛</p>
</li>
<li>
<p>实现 readResolve() 方法，当 JVM 从内存中反序列化地组装一个新对象，就会自动调用 readResolve 方法返回原来单例</p>
</li>
</ul>
</li>
<li>
<p>构造方法设置为私有，防止其他类无限创建对象，但是不能防止反射破坏</p>
</li>
<li>
<p>静态变量初始化在类加载时完成，<strong>由 JVM 保证线程安全</strong>，能保证单例对象创建时的安全</p>
</li>
<li>
<p>提供静态方法而不是直接将 INSTANCE 设置为 public，体现了更好的封装性、提供泛型支持、可以改进成懒汉单例设计</p>
</li>
</ul>
</li>
<li>
<p>静态代码块的方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>枚举方式：枚举类型是所用单例实现中<strong>唯一一种不会被破坏</strong>的单例实现模式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>问题1：枚举单例是如何限制实例个数的？每个枚举项都是一个实例，是一个静态成员变量</li>
<li>问题2：枚举单例在创建时是否有并发问题？否</li>
<li>问题3：枚举单例能否被反射破坏单例？否，反射创建对象时判断是枚举类型就直接抛出异常</li>
<li>问题4：枚举单例能否被反序列化破坏单例？否</li>
<li>问题5：枚举单例属于懒汉式还是饿汉式？<strong>饿汉式</strong></li>
<li>问题6：枚举单例如果希望加入一些单例创建时的初始化逻辑该如何做？添加构造方法</li>
</ul>
<p>反编译结果：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 懒汉式</h4>
<ul>
<li>
<p>线程不安全</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>双端检锁机制</p>
<p>在多线程的情况下，可能会出现空指针问题，出现问题的原因是 JVM 在实例化对象的时候会进行优化和指令重排序操作，所以需要使用 <code>volatile</code> 关键字</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>静态内部类方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>内部类属于懒汉式，类加载本身就是懒惰的，首次调用时加载，然后对单例进行初始化</p>
<p>类加载的时候方法不会被调用，所以不会触发 getInstance 方法调用 invokestatic 指令对内部类进行加载；加载的时候字节码常量池会被加入类的运行时常量池，解析工作是将常量池中的符号引用解析成直接引用，但是解析过程不一定非得在类加载时完成，可以延迟到运行时进行，所以静态内部类实现单例会<strong>延迟加载</strong></p>
</li>
<li>
<p>没有线程安全问题，静态变量初始化在类加载时完成，由 JVM 保证线程安全</p>
</li>
</ul>
</li>
</ul>
<hr>
<h4> 破坏单例</h4>
<h5> 反序列化</h5>
<p>将单例对象序列化再反序列化，对象从内存反序列化到程序中会重新创建一个对象，通过反序列化得到的对象是不同的对象，而且得到的对象不是通过构造器得到的，<strong>反序列化得到的对象不执行构造器</strong></p>
<ul>
<li>
<p>Singleton</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>序列化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>解决方法：</p>
<p>在 Singleton 类中添加 <code>readResolve()</code> 方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新创建的对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>ObjectInputStream 类源码分析：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h5> 反射破解</h5>
<ul>
<li>
<p>反射</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>反射方式破解单例的解决方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> Runtime</h4>
<p>Runtime 类就是使用的单例设计模式中的饿汉式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 Runtime</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 代理模式</h3>
<h4> 静态代理</h4>
<p>代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问，访问对象不适合或者不能直接引用为目标对象，代理对象作为访问对象和目标对象之间的中介</p>
<p>Java 中的代理按照代理类生成时机不同又分为静态代理和动态代理，静态代理代理类在编译期就生成，而动态代理代理类则是在 Java 运行时动态生成，动态代理又有 JDK 代理和 CGLib 代理两种</p>
<p>代理（Proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法</li>
<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，可以访问、控制或扩展真实主题的功能</li>
</ul>
<p>买票案例，火车站是目标对象，代售点是代理对象</p>
<ul>
<li>
<p>卖票接口：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>火车站，具有卖票功能，需要实现SellTickets接口</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>代售点：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>测试类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>测试类直接访问的是 ProxyPoint 类对象，也就是 ProxyPoint 作为访问对象和目标对象的中介</p>
</li>
</ul>
<hr>
<h4> JDK</h4>
<h5> 使用方式</h5>
<p>Java 中提供了一个动态代理类 Proxy，Proxy 并不是代理对象的类，而是提供了一个创建代理对象的静态方法 newProxyInstance() 来获取代理对象</p>
<p><code>static Object newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h) </code></p>
<ul>
<li>
<p>参数一：类加载器，负责加载代理类。传入类加载器，代理和被代理对象要用一个类加载器才是父子关系，不同类加载器加载相同的类在 JVM 中都不是同一个类对象</p>
</li>
<li>
<p>参数二：被代理业务对象的<strong>全部实现的接口</strong>，代理对象与真实对象实现相同接口，知道为哪些方法做代理</p>
</li>
<li>
<p>参数三：代理真正的执行方法，也就是代理的处理逻辑</p>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li>
<p>代理工厂：创建代理对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>测试类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h5> 实现原理</h5>
<p>JDK 动态代理方式的优缺点：</p>
<ul>
<li>优点：可以为任意的接口实现类对象做代理，也可以为被代理对象的所有接口的所有方法做代理，动态代理可以在不改变方法源码的情况下，实现对方法功能的增强，提高了软件的可扩展性，Java 反射机制可以生成任意类型的动态代理类</li>
<li>缺点：<strong>只能针对接口或者接口的实现类对象做代理对象</strong>，普通类是不能做代理对象的</li>
<li>原因：<strong>生成的代理类继承了 Proxy</strong>，Java 是单继承的，所以 JDK 动态代理只能代理接口</li>
</ul>
<p>ProxyFactory 不是代理模式中的代理类，而代理类是程序在运行过程中动态的在内存中生成的类，可以通过 Arthas 工具查看代理类结构：</p>
<ul>
<li>代理类（$Proxy0）实现了 SellTickets 接口，真实类和代理类实现同样的接口</li>
<li>代理类（$Proxy0）将提供了的匿名内部类对象传递给了父类</li>
<li>代理类（$Proxy0）的修饰符是 public final</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行流程如下：</p>
<ol>
<li>在测试类中通过代理对象调用 sell() 方法</li>
<li>根据多态的特性，执行的是代理类（$Proxy0）中的 sell() 方法</li>
<li>代理类（$Proxy0）中的 sell() 方法中又调用了 InvocationHandler 接口的子实现类对象的 invoke 方法</li>
<li>invoke 方法通过反射执行了真实对象所属类（TrainStation）中的 sell() 方法</li>
</ol>
<hr>
<h5> 源码解析</h5>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Proxy 的静态内部类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> CGLIB</h4>
<p>CGLIB 是一个功能强大，高性能的代码生成包，为没有实现接口的类提供代理，为 JDK 动态代理提供了补充（$$Proxy）</p>
<ul>
<li>
<p>CGLIB 是第三方提供的包，所以需要引入 jar 包的坐标：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>代理工厂类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>CGLIB 的优缺点</p>
<ul>
<li>优点：
<ul>
<li>CGLIB 动态代理<strong>不限定</strong>是否具有接口，可以对任意操作进行增强</li>
<li>CGLIB 动态代理无需要原始被代理对象，动态创建出新的代理对象</li>
<li><strong>JDKProxy 仅对接口方法做增强，CGLIB 对所有方法做增强</strong>，包括 Object 类中的方法，toString、hashCode 等</li>
</ul>
</li>
<li>缺点：CGLIB 不能对声明为 final 的类或者方法进行代理，因为 CGLIB 原理是<strong>动态生成被代理类的子类，继承被代理类</strong></li>
</ul>
<hr>
<h4> 方式对比</h4>
<p>三种方式对比：</p>
<ul>
<li>
<p>动态代理和静态代理：</p>
<ul>
<li>
<p>动态代理将接口中声明的所有方法都被转移到一个集中的方法中处理（InvocationHandler.invoke），在接口方法数量比较多的时候，可以进行灵活处理，不需要像静态代理那样每一个方法进行中转</p>
</li>
<li>
<p>静态代理是在编译时就已经将接口、代理类、被代理类的字节码文件确定下来</p>
</li>
<li>
<p>动态代理是程序<strong>在运行后通过反射创建字节码文件</strong>交由 JVM 加载</p>
</li>
</ul>
</li>
<li>
<p>JDK 代理和 CGLIB 代理：</p>
<p>JDK 动态代理采用 <code>ProxyGenerator.generateProxyClass()</code> 方法在运行时生成字节码；CGLIB 底层采用 ASM 字节码生成框架，使用字节码技术生成代理类。在 JDK1.6之前比使用 Java 反射效率要高，到 JDK1.8 的时候，JDK 代理效率高于 CGLIB 代理。所以如果有接口或者当前类就是接口使用 JDK 动态代理，如果没有接口使用 CGLIB 代理</p>
</li>
</ul>
<p>代理模式的优缺点：</p>
<ul>
<li>
<p>优点：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用</li>
<li><strong>代理对象可以增强目标对象的功能，被用来间接访问底层对象，与原始对象具有相同的 hashCode</strong></li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度</li>
</ul>
</li>
<li>
<p>缺点：增加了系统的复杂度</p>
</li>
</ul>
<p>代理模式的使用场景：</p>
<ul>
<li>
<p>远程（Remote）代理：本地服务通过网络请求远程服务，需要实现网络通信，处理其中可能的异常。为了良好的代码设计和可维护性，将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能</p>
</li>
<li>
<p>防火墙（Firewall）代理：当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网，当互联网返回响应时，代理服务器再把它转给你的浏览器</p>
</li>
<li>
<p>保护（Protect or Access）代理：控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限</p>
</li>
</ul>
<hr>
]]></content:encoded>
      <enclosure url="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/数组内存分配-一个数组内存图.png" type="image/png"/>
    </item>
    <item>
      <title>算法</title>
      <link>https://newzone.top/Java/%E7%AE%97%E6%B3%95.html</link>
      <guid>https://newzone.top/Java/%E7%AE%97%E6%B3%95.html</guid>
      <source url="https://newzone.top/rss.xml">算法</source>
      <description>算法 递归 概述 算法：解题方案的准确而完整的描述，是一系列解决问题的清晰指令，代表着用系统的方法解决问题的策略机制 递归：程序调用自身的编程技巧 递归： 直接递归：自己的方法调用自己 间接递归：自己的方法调用别的方法，别的方法又调用自己 递归如果控制的不恰当，会形成递归的死循环，从而导致栈内存溢出错误 参考书籍：https://book.douban.com/subject/35263893/</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> 算法</h1>
<h2> 递归</h2>
<h3> 概述</h3>
<p>算法：解题方案的准确而完整的描述，是一系列解决问题的清晰指令，代表着用系统的方法解决问题的策略机制</p>
<p>递归：程序调用自身的编程技巧</p>
<p>递归：</p>
<ul>
<li>直接递归：自己的方法调用自己</li>
<li>间接递归：自己的方法调用别的方法，别的方法又调用自己</li>
</ul>
<p>递归如果控制的不恰当，会形成递归的死循环，从而导致栈内存溢出错误</p>
<p>参考书籍：<a href="https://book.douban.com/subject/35263893/" target="_blank" rel="noopener noreferrer">https://book.douban.com/subject/35263893/</a></p>
<hr>
<h3> 算法</h3>
<h4> 核心思想</h4>
<p>递归的三要素（理论）：</p>
<ol>
<li>递归的终结点</li>
<li>递归的公式</li>
<li>递归的方向：必须走向终结点</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 公式转换</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 注意事项</h4>
<p>以上理论只能针对于<strong>规律化递归</strong>，如果是非规律化是不能套用以上公式的！<br>
非规律化递归的问题：文件搜索，啤酒问题。</p>
<hr>
<h3> 应用</h3>
<h4> 猴子吃桃</h4>
<p>猴子第一天摘了若干个桃子，当即吃了一半，觉得好不过瘾，然后又多吃了一个。第二天又吃了前一天剩下的一半，觉得好不过瘾，然后又多吃了一个。以后每天都是如此。等到第十天再吃的时候发现只有1个桃子，问猴子第一天总共摘了多少个桃子？</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 递归求和</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 汉诺塔</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>时间复杂度 O(2^n)</p>
<hr>
<h4> 啤酒问题</h4>
<p>非规律化递归问题，啤酒 2 元 1 瓶，4 个盖子可以换 1 瓶，2 个空瓶可以换 1 瓶</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 排序</h2>
<h3> 冒泡排序</h3>
<p>冒泡排序（Bubble Sort）：两个数比较大小，较大的数下沉，较小的数冒起来</p>
<p>算法描述：每次从数组的第一个位置开始两两比较，把较大的元素与较小的元素进行层层交换，最终把当前最大的一个元素存入到数组当前的末尾</p>
<p>实现思路：</p>
<ol>
<li>确定总共需要冒几轮：数组的长度-1</li>
<li>每轮两两比较几次</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-冒泡排序.gif" style="zoom: 80%;">
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>冒泡排序时间复杂度：最坏情况</p>
<ul>
<li>元素比较的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li>
<li>元素交换的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li>
<li>总执行次数为：<code>(N^2/2-N/2)+(N^2/2-N/2)=N^2-N</code></li>
</ul>
<p>按照大 O 推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为 O(N^2)</p>
<hr>
<h3> 选择排序</h3>
<h4> 简单选择</h4>
<p>选择排序（Selection-sort）：一种简单直观的排序算法</p>
<p>算法描述：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕</p>
<p>实现思路：</p>
<ol>
<li>控制选择几轮：数组的长度 - 1</li>
<li>控制每轮从当前位置开始比较几次</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-选择排序.gif" style="zoom: 80%;">
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>选择排序时间复杂度：</p>
<ul>
<li>数据比较次数：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li>
<li>数据交换次数：<code>N-1</code></li>
<li>时间复杂度：<code>N^2/2-N/2+（N-1）=N^2/2+N/2-1</code></li>
</ul>
<p>根据大 O 推导法则，保留最高阶项，去除常数因子，时间复杂度为 O(N^2)</p>
<hr>
<h4> 堆排序</h4>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法，堆结构是一个近似完全二叉树的结构，并同时满足子结点的键值或索引总是小于（或者大于）父节点</p>
<p>优先队列：堆排序每次上浮过程都会将最大或者最小值放在堆顶，应用于优先队列可以将优先级最高的元素浮到堆顶</p>
<p>实现思路：</p>
<ol>
<li>
<p>将初始待排序关键字序列（R1,R2….Rn）构建成大顶堆，并通过上浮对堆进行调整，此堆为初始的无序区，<strong>堆顶为最大数</strong></p>
</li>
<li>
<p>将堆顶元素 R[1] 与最后一个元素 R[n] 交换，此时得到新的无序区（R1,R2,……Rn-1）和新的有序区 Rn，且满足 R[1,2…n-1]&lt;=R[n]</p>
</li>
<li>
<p>交换后新的堆顶 R[1] 可能违反堆的性质，因此需要对当前无序区（R1,R2,……Rn-1）调整为新堆，然后再次将 R[1] 与无序区最后一个元素交换，得到新的无序区（R1,R2….Rn-2）和新的有序区（Rn-1,Rn），不断重复此过程直到有序区的元素个数为 n-1，则整个排序过程完成</p>
</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-堆排序.jpg" style="zoom:67%;">
<p>floor：向下取整</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>堆排序的时间复杂度是 O(nlogn)</p>
<hr>
<h3> 插入排序</h3>
<h4> 直接插入</h4>
<p>插入排序（Insertion Sort）：在要排序的一组数中，假定前 n-1 个数已经排好序，现在将第 n 个数插到这个有序数列中，使得这 n 个数也是排好顺序的，如此反复循环，直到全部排好顺序</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-插入排序.png" style="zoom: 67%;">
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入排序时间复杂度：</p>
<ul>
<li>比较的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2</code></li>
<li>交换的次数为：<code>(N-1)+(N-2)+(N-3)+...+2+1=((N-1)+1)(N-1)/2=N^2/2-N/2</code></li>
<li>总执行次数为：<code>(N^2/2-N/2)+(N^2/2-N/2)=N^2-N</code></li>
</ul>
<p>按照大 O 推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为 O(N^2)</p>
<hr>
<h4> 希尔排序</h4>
<p>希尔排序（Shell Sort）：也是一种插入排序，也称为缩小增量排序</p>
<p>实现思路：</p>
<ol>
<li>选定一个增长量 h，按照增长量 h 作为数据分组的依据，对数据进行分组</li>
<li>对分好组的每一组数据完成插入排序</li>
<li>减小增长量，最小减为 1，重复第二步操作</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-希尔排序.png" style="zoom:67%;">
<p>希尔排序的核心在于间隔序列的设定，既可以提前设定好间隔序列，也可以动态的定义间隔序列，希尔排序就是插入排序增加了间隔</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在希尔排序中，增长量 h 并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最好的，所以对于希尔排序的时间复杂度分析就认为 O(nlogn)</p>
<hr>
<h3> 归并排序</h3>
<h4> 实现方式</h4>
<p>归并排序（Merge Sort）：建立在归并操作上的一种有效的排序算法，该算法是采用分治法的典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>
<p>实现思路：</p>
<ol>
<li>一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止</li>
<li>将相邻的两个子组进行合并成一个有序的大组</li>
<li>不断的重复步骤2，直到最终只有一个组为止</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并排序.png" style="zoom:50%;">
<p>归并步骤：每次比较两端最小的值，把最小的值放在辅助数组的左边</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并步骤1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并步骤2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并步骤3.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 实现代码</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并排序时间复杂度.png" style="zoom: 67%;">
<p>用树状图来描述归并，假设元素的个数为 n，那么使用归并排序拆分的次数为 <code>log2(n)</code>，即层数，每次归并需要做 n 次对比，最终得出的归并排序的时间复杂度为 <code>log2(n)*n</code>，根据大O推导法则，忽略底数，最终归并排序的时间复杂度为 O(nlogn)</p>
<p>归并排序的缺点：需要申请额外的数组空间，导致空间复杂度提升，是典型的<strong>以空间换时间</strong>的操作</p>
<hr>
<h3> 快速排序</h3>
<p>快速排序（Quick Sort）：通过<strong>分治思想</strong>对冒泡排序的改进，基本过程是通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，以此达到整个数据变成有序序列</p>
<p>实现思路：</p>
<ol>
<li>从数列中挑出一个元素，称为基准（pivot）</li>
<li>重新排序数列，所有比基准值小的摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边），在这个分区退出之后，该基准就处于数列的中间位置，这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>
</ol>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-快速排序.gif" style="zoom:80%;">
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>快速排序和归并排序的区别：</p>
<ul>
<li>快速排序是另外一种分治的排序算法，将一个数组分成两个子数组，将两部分独立的排序</li>
<li>归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题</li>
<li>快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了</li>
<li>在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后</li>
</ul>
<p>时间复杂度：</p>
<ul>
<li>
<p>最优情况：每一次切分选择的基准数字刚好将当前序列等分。把数组的切分看做是一个树，共切分了 logn 次，所以，最优情况下快速排序的时间复杂度为 O(nlogn)</p>
</li>
<li>
<p>最坏情况：每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总共就得切分n次，所以最坏情况下，快速排序的时间复杂度为 O(n^2)</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-快排时间复杂度.png" style="zoom: 50%;">
</li>
<li>
<p>平均情况：每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况用数学归纳法证明，快速排序的时间复杂度为 O(nlogn)</p>
</li>
</ul>
<p>推荐视频：<a href="https://www.bilibili.com/video/BV1b7411N798?t=1001&amp;p=81" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1b7411N798?t=1001&amp;p=81</a></p>
<p>参考文章：<a href="https://blog.csdn.net/nrsc272420199/article/details/82587933" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/nrsc272420199/article/details/82587933</a></p>
<hr>
<h3> 基数排序</h3>
<p>基数排序（Radix Sort）：又叫桶排序和箱排序，借助多关键字排序的思想对单逻辑关键字进行排序的方法</p>
<p>计数排序其实是桶排序的一种特殊情况，当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶，每个桶内的数据值都是相同的，省掉了桶内排序的时间</p>
<p>按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前</p>
<p>解释：先排低位再排高位，可以说明在高位相等的情况下低位是递增的，如果高位也是递增，则数据有序</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-基数排序.gif" style="zoom:67%;">
<p>实现思路：</p>
<ul>
<li>获得最大数的位数，可以通过将最大数变为 String 类型，再求长度</li>
<li>将所有待比较数值（正整数）统一为同样的数位长度，<strong>位数较短的数前面补零</strong></li>
<li>从最低位开始，依次进行一次排序</li>
<li>从最低位排序一直到最高位（个位 → 十位 → 百位 → … →最高位）排序完成以后，数列就变成一个有序序列</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>空间换时间</p>
<p>推荐视频：<a href="https://www.bilibili.com/video/BV1b7411N798?p=86" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1b7411N798?p=86</a></p>
<p>参考文章：<a href="https://www.toutiao.com/a6593273307280179715/?iid=6593273307280179715" target="_blank" rel="noopener noreferrer">https://www.toutiao.com/a6593273307280179715/?iid=6593273307280179715</a></p>
<hr>
<h3> 算法总结</h3>
<h4> 稳定性</h4>
<p>稳定性：在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中 <code>r[i]=r[j]</code>，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的，否则称为不稳定的</p>
<p>如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-稳定性.png" style="zoom:50%;">
<ul>
<li>冒泡排序：只有当 <code>arr[i]&gt;arr[i+1]</code> 的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种稳定排序算法</li>
<li>选择排序：是给每个位置选择当前元素最小的，例如有数据{5(1)，8 ，5(2)， 3， 9 }，第一遍选择到的最小元素为3，所以5(1)会和3进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以是不稳定的排序算法</li>
<li>插入排序：比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等元素的后面。相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的</li>
<li>希尔排序：按照不同步长对元素进行插入排序，虽然一次插入排序是稳定的，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不稳定的</li>
<li>归并排序在归并的过程中，只有 <code>arr[i]&lt;arr[i+1]</code> 的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是稳定的</li>
<li>快速排序：快排需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素，然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种不稳定的算法</li>
</ul>
<p>记忆口诀：</p>
<ul>
<li>
<p>情绪不稳定，快些选一堆好友来聊天</p>
</li>
<li>
<p>快：快速排序、些：希尔排序、选：选择排序、堆：堆排序</p>
</li>
</ul>
<hr>
<h4> 算法对比</h4>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-排序算法对比.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 补充问题</h4>
<p>海量数据问题：</p>
<ul>
<li>海量数据排序：
<ul>
<li>外部排序：归并 + 败者树</li>
<li>基数排序：<a href="https://time.geekbang.org/column/article/42038" target="_blank" rel="noopener noreferrer">https://time.geekbang.org/column/article/42038</a></li>
</ul>
</li>
<li>海量数据查询：
<ul>
<li>布隆过滤器判断是否存在</li>
<li>构建索引：B+ 树、跳表</li>
</ul>
</li>
</ul>
<hr>
<h2> 查找</h2>
<p>正常查找：从第一个元素开始遍历，一个一个的往后找，综合查找比较耗时</p>
<p>二分查找也称折半查找（Binary Search）是一种效率较高的查找方法，数组必须是有序数组</p>
<p>过程：每次先与中间的元素进行比较，如果大于往右边找，如果小于往左边找，如果等于就返回该元素索引位置，如果没有该元素，返回 -1</p>
<p>时间复杂度：O(logn)</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/二分查找.gif" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>查找第一个匹配的元素：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 匹配</h2>
<h3> BF</h3>
<p>Brute Force 暴力匹配算法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>平均时间复杂度：O(m+n)，最坏时间复杂度：O(m*n)</p>
<hr>
<h3> RK</h3>
<p>把主串得长度记为 n，模式串得长度记为 m，通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小，如果某个子串的哈希值与模式串相等，再去对比值是否相等（防止哈希冲突），那就说明对应的子串和模式串匹配了</p>
<p>因为哈希值是一个数字，数字之间比较是否相等是非常快速的</p>
<p>第一部分计算哈希值的时间复杂度为 O(n)，第二部分对比的时间复杂度为 O(1)，整体平均时间复杂度为 O(n)，最坏为 O(n*m)</p>
<hr>
<h3> KMP</h3>
<p>KMP 匹配：</p>
<ul>
<li>next 数组的核心就是自己匹配自己，主串代表后缀，模式串代表前缀</li>
<li>nextVal 数组的核心就是回退失配</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>平均和最坏时间复杂度都是 O(m+n)</p>
<p>参考文章：<a href="https://www.cnblogs.com/tangzhengyue/p/4315393.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/tangzhengyue/p/4315393.html</a></p>
<hr>
<h2> 树</h2>
<h3> 二叉树</h3>
<p>二叉树中，任意一个节点的度要小于等于 2</p>
<ul>
<li>节点：在树结构中,每一个元素称之为节点</li>
<li>度：每一个节点的子节点数量称之为度</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/二叉树结构图.png" alt="二叉树结构图" style="zoom:80%;">
<hr>
<h3> 排序树</h3>
<h4> 存储结构</h4>
<p>二叉排序树（BST），又称二叉查找树或者二叉搜索树</p>
<ul>
<li>每一个节点上最多有两个子节点</li>
<li>左子树上所有节点的值都小于根节点的值</li>
<li>右子树上所有节点的值都大于根节点的值</li>
<li>不存在重复的节点</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/二叉查找树结构图.png" alt="二叉查找树" style="zoom: 80%;">
<hr>
<h4> 代码实现</h4>
<ul>
<li>
<p>节点类：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>查找节点：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>插入节点：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>构造函数：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>删除节点：要删除节点12，先找到节点19，然后移动并替换节点12<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-二叉查找树删除节点.png" style="zoom: 50%;"></p>
<p>代码链接：<a href="https://leetcode-cn.com/submissions/detail/190232548/" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/submissions/detail/190232548/</a></p>
</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1iJ411E7xW?t=756&amp;p=86" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1iJ411E7xW?t=756&amp;p=86</a></p>
<p>图片来源：<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/tu-jie-yi-dong-jie-dian-er-bu-shi-xiu-ga-edtn/" target="_blank" rel="noopener noreferrer">https://leetcode-cn.com/problems/delete-node-in-a-bst/solution/tu-jie-yi-dong-jie-dian-er-bu-shi-xiu-ga-edtn/</a></p>
<hr>
<h3> 平衡树</h3>
<p>平衡二叉树（AVL）的特点：</p>
<ul>
<li>二叉树左右两个子树的高度差不超过 1</li>
<li>任意节点的左右两个子树都是一颗平衡二叉树</li>
</ul>
<p>平衡二叉树旋转：</p>
<ul>
<li>
<p>旋转触发时机：当添加一个节点之后，该树不再是一颗平衡二叉树</p>
</li>
<li>
<p>平衡二叉树和二叉查找树对比结构图</p>
</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/平衡二叉树和二叉查找树对比结构图.png" alt="平衡二叉树和二叉查找树对比" tabindex="0" loading="lazy"><figcaption>平衡二叉树和二叉查找树对比</figcaption></figure>
<ul>
<li>
<p>左旋：将根节点的右侧往左拉，原先的右子节点变成新的父节点，并把多余的左子节点出让，给已经降级的根节点当右子节点</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/平衡二叉树左旋01.png" alt="平衡二叉树左旋" tabindex="0" loading="lazy"><figcaption>平衡二叉树左旋</figcaption></figure>
</li>
</ul>
<ul>
<li>
<p>右旋：将根节点的左侧往右拉，左子节点变成了新的父节点，并把多余的右子节点出让，给已经降级根节点当左子节点</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/平衡二叉树右旋01.png" alt="平衡二叉树右旋" tabindex="0" loading="lazy"><figcaption>平衡二叉树右旋</figcaption></figure>
</li>
</ul>
<p>推荐文章：<a href="https://pdai.tech/md/algorithm/alg-basic-tree-balance.html" target="_blank" rel="noopener noreferrer">https://pdai.tech/md/algorithm/alg-basic-tree-balance.html</a></p>
<hr>
<h3> 红黑树</h3>
<p>红黑树的特点：</p>
<ul>
<li>每一个节点可以是红或者黑</li>
</ul>
<ul>
<li>红黑树不是高度平衡的，它的平衡是通过自己的红黑规则进行实现的</li>
</ul>
<p>红黑树的红黑规则有哪些：</p>
<ol>
<li>每一个节点或是红色的，或者是黑色的</li>
<li>根节点必须是黑色</li>
<li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为 Nil，这些 Nil 视为叶节点，每个叶节点 (Nil) 是黑色的</li>
<li>如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）</li>
<li>对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点</li>
</ol>
<p>红黑树与 AVL 树的比较：</p>
<ul>
<li>AVL 树是更加严格的平衡，可以提供更快的查找速度，适用于读取<strong>查找密集型任务</strong></li>
<li>红黑树只是做到近似平衡，并不是严格的平衡，红黑树的插入删除比 AVL 树更便于控制，红黑树更适合于<strong>插入修改密集型任务</strong></li>
</ul>
<ul>
<li>红黑树整体性能略优于 AVL 树，AVL 树的旋转比红黑树的旋转多，更加难以平衡和调试，插入和删除的效率比红黑树慢</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/红黑树结构图.png" alt="红黑树" tabindex="0" loading="lazy"><figcaption>红黑树</figcaption></figure>
<p>红黑树添加节点的默认颜色为红色，效率高<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/红黑树添加节点颜色.png" alt="" loading="lazy"></p>
<p><strong>红黑树添加节点后如何保持红黑规则：</strong></p>
<ul>
<li>根节点位置
<ul>
<li>直接变为黑色</li>
</ul>
</li>
<li>非根节点位置
<ul>
<li>父节点为黑色
<ul>
<li>不需要任何操作,默认红色即可</li>
</ul>
</li>
<li>父节点为红色
<ul>
<li>叔叔节点为红色
<ol>
<li>将"父节点"设为黑色,将"叔叔节点"设为黑色</li>
<li>将"祖父节点"设为红色</li>
<li>如果"祖父节点"为根节点,则将根节点再次变成黑色</li>
</ol>
</li>
<li>叔叔节点为黑色
<ol>
<li>将"父节点"设为黑色</li>
<li>将"祖父节点"设为红色</li>
<li>以"祖父节点"为支点进行旋转</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3> 并查集</h3>
<h4> 基本实现</h4>
<p>并查集是一种树型的数据结构，有以下特点：</p>
<ul>
<li>每个元素都唯一的对应一个结点</li>
<li>每一组数据中的多个元素都在同一颗树中</li>
<li>一个组中的数据对应的树和另外一个组中的数据对应的树之间没有任何联系</li>
<li>元素在树中并没有子父级关系的硬性要求</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集.png" style="zoom:50%;">
<p>可以高效地进行如下操作：</p>
<ul>
<li>查询元素 p 和元素 q 是否属于同一组</li>
<li>合并元素 p 和元素 q 所在的组</li>
</ul>
<p>存储结构：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集存储结构.png" style="zoom:67%;">
<p>合并方式：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集合并.png" style="zoom:67%;">
<p>代码实现：</p>
<ul>
<li>
<p>类实现：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>测试代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>最坏情况下 union 算法的时间复杂度也是 O(N^2)</p>
<hr>
<h4> 优化实现</h4>
<p>让每个索引处的节点都指向它的父节点，当 eleGroup[i] = i 时，说明 i 是根节点</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集优化.png" style="zoom: 67%;">
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>平均时间复杂度为 O(N)，最坏时间复杂度是 O(N^2)</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-并查集时间复杂度.png" style="zoom:67%;">
<p>继续优化：路径压缩，保证每次把小树合并到大树</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 应用场景</h4>
<p>并查集存储的每一个整数表示的是一个大型计算机网络中的计算机：</p>
<ul>
<li>可以通过 connected(int p, int q) 来检测该网络中的某两台计算机之间是否连通</li>
<li>可以调用 union(int p,int q) 使得 p 和 q 之间连通，这样两台计算机之间就可以通信</li>
</ul>
<p>畅通工程：某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府畅通工程的目标是使全省任何两个城镇间都可以实现交通，但不一定有直接的道路相连，只要互相间接通过道路可达即可，问最少还需要建设多少条道路？</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-应用场景.png" style="zoom:67%;">
<p>解题思路：</p>
<ol>
<li>创建一个并查集 UF_Tree_Weighted(20)</li>
<li>分别调用 union(0,1)、union(6,9)、union(3,8)、union(5,11)、union(2,12)、union(6,10)、union(4,8)，表示已经修建好的道路把对应的城市连接起来</li>
<li>如果城市全部连接起来，那么并查集中剩余的分组数目为 1，所有的城市都在一个树中，只需要获取当前并查集中剩余的数目减去 1，就是还需要修建的道路数目</li>
</ol>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参考视频：<a href="https://www.bilibili.com/video/BV1iJ411E7xW?p=142" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1iJ411E7xW?p=142</a></p>
<hr>
<h3> 字典树</h3>
<h4> 基本介绍</h4>
<p>Trie 树，也叫字典树，是一种专门处理字符串匹配的树形结构，用来解决在一组字符串集合中快速查找某个字符串的问题，Trie 树的本质就是利用字符串之间的公共前缀，将重复的前缀合并在一起</p>
<ul>
<li>根节点不包含任何信息</li>
<li>每个节点表示一个字符串中的字符，从<strong>根节点到红色节点的一条路径表示一个字符串</strong></li>
<li>红色节点并不都是叶子节点</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树构造过程1.png" style="zoom: 50%;">
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树构造过程2.png" style="zoom:50%;">
<p>注意：要查找的是字符串“he”，从根节点开始，沿着某条路径来匹配，可以匹配成功。但是路径的最后一个节点“e”并不是红色的，也就是说，“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串</p>
<hr>
<h4> 实现Trie</h4>
<p>通过一个下标与字符一一映射的数组，来存储子节点的指针</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树存储结构.png" style="zoom:50%;">
<p>时间复杂度是 O(n)（n 表示要查找字符串的长度）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 优化Trie</h4>
<p>Trie 树是非常耗内存，采取空间换时间的思路。Trie 树的变体有很多，可以在一定程度上解决内存消耗的问题。比如缩点优化，对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Tree-字典树缩点优化.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>参考文章：<a href="https://time.geekbang.org/column/article/72414" target="_blank" rel="noopener noreferrer">https://time.geekbang.org/column/article/72414</a></p>
<hr>
<h2> 图</h2>
<p>图的邻接表形式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>图的邻接矩阵形式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>图相关的算法需要很多的流程图，此处不再一一列举，推荐参考书籍《数据结构高分笔记》</p>
<hr>
<h2> 位图</h2>
<h3> 基本介绍</h3>
<p>布隆过滤器：一种数据结构，是一个很长的二进制向量（位数组）和一系列随机映射函数（哈希函数），既然是二进制，每个空间存放的不是 0 就是 1，但是初始默认值都是 0，所以布隆过滤器不存数据只存状态</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-Bitmaps数据结构.png" style="zoom: 80%;">
<p>这种数据结构是高效且性能很好的，但缺点是具有一定的错误识别率和删除难度。并且理论情况下，添加到集合中的元素越多，误报的可能性就越大</p>
<hr>
<h3> 工作流程</h3>
<p>向布隆过滤器中添加一个元素 key 时，会通过多个 hash 函数得到多个哈希值，在位数组中把对应下标的值置为 1</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/DB/Redis-布隆过滤器添加数据.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>布隆过滤器查询一个数据，是否在二进制的集合中，查询过程如下：</p>
<ul>
<li>通过 K 个哈希函数计算该数据，对应计算出的 K 个 hash 值</li>
<li>通过 hash 值找到对应的二进制的数组下标</li>
<li>判断方法：如果存在一处位置的二进制数据是 0，那么该数据一定不存在。如果都是 1，则认为数据存在集合中（会误判）</li>
</ul>
<p>布隆过滤器优缺点：</p>
<ul>
<li>
<p>优点：</p>
<ul>
<li>二进制组成的数组，占用内存极少，并且插入和查询速度都足够快</li>
<li>去重方便：当字符串第一次存储时对应的位数组下标设置为 1，当第二次存储相同字符串时，因为对应位置已设置为 1，所以很容易知道此值已经存在</li>
</ul>
</li>
<li>
<p>缺点：</p>
<ul>
<li>随着数据的增加，误判率会增加：添加数据是通过计算数据的 hash 值，不同的字符串可能哈希出来的位置相同，导致无法确定到底是哪个数据存在，<strong>这种情况可以适当增加位数组大小或者调整哈希函数</strong></li>
<li>无法删除数据：可能存在几个数据占据相同的位置，所以删除一位会导致很多数据失效</li>
</ul>
</li>
<li>
<p>总结：<strong>布隆过滤器判断某个元素存在，小概率会误判。如果判断某个元素不在，那这个元素一定不在</strong></p>
</li>
</ul>
<p>参考文章：<a href="https://www.cnblogs.com/ysocean/p/12594982.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/ysocean/p/12594982.html</a></p>
<hr>
<h3> Guava</h3>
<p>引入 Guava 的依赖：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>指定误判率为（0.01）：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 实现布隆</h3>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://seazean.oss-cn-beijing.aliyuncs.com/img/Java/Sort-归并步骤1.png" type="image/png"/>
    </item>
    <item>
      <title>AJAX</title>
      <link>https://newzone.top/JavaWeb/AJAX.html</link>
      <guid>https://newzone.top/JavaWeb/AJAX.html</guid>
      <source url="https://newzone.top/rss.xml">AJAX</source>
      <description>AJAX 概述 AJAX(Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。 不是一种新技术，而是多个技术综合，用于快速创建动态网页的技术。 一般的网页如果需要更新内容，必需重新加载个页面。而 AJAX 通过浏览器与服务器进行少量数据交换，就可以使网页实现异步更新。也就是在不重新加载整个页 面的情况下，对网页的部分内容进行局部更新。</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> AJAX</h1>
<h2> 概述</h2>
<ul>
<li>
<p>AJAX(Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。</p>
</li>
<li>
<p>不是一种新技术，而是多个技术综合，用于快速创建动态网页的技术。</p>
</li>
<li>
<p>一般的网页如果需要更新内容，必需重新加载个页面。而 AJAX 通过浏览器与服务器进行少量数据交换，就可以使网页实现异步更新。也就是在不重新加载整个页 面的情况下，对网页的部分内容进行<strong>局部更新</strong>。</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/AJAX网页局部更新.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<hr>
<h2> 实现AJAX</h2>
<h3> JS方式</h3>
<ul>
<li>
<p>核心对象：XMLHttpRequest</p>
<ul>
<li>用于在后台与服务器交换数据。可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</li>
</ul>
</li>
<li>
<p>打开链接：open(method,url,async)</p>
<ul>
<li>method：请求的类型 GET 或 POST</li>
<li>url：请求资源的路径</li>
</ul>
<ul>
<li>async：true(异步) 或 false(同步)。</li>
</ul>
</li>
<li>
<p>发送请求：send(String params)</p>
<ul>
<li>params：请求的参数(POST 专用)</li>
</ul>
</li>
<li>
<p>处理响应：onreadystatechange</p>
<ul>
<li>readyState：0-请求未初始化，1-服务器连接已建立，2-请求已接收，3-请求处理中，4-请求已完成，且响应已就绪。</li>
</ul>
<ul>
<li>status：200-响应已全部 OK。</li>
</ul>
</li>
<li>
<p>获得响应数据形式</p>
<ul>
<li>
<p>responseText：获得字符串形式的响应数据。</p>
</li>
<li>
<p>responseXML：获得 XML 形式的响应数据。</p>
</li>
</ul>
</li>
</ul>
<p>鼠标移出输入框，判断用户名是否被注册：</p>
<ul>
<li>
<p>Servlet</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>html文件</p>
</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> JQ方式</h3>
<p><strong>核心语法：</strong><code>$.ajax({name:value,name:value,…}); </code></p>
<ul>
<li>url：请求的资源路径。</li>
<li>async：是否异步请求，true-是，false-否 (默认是 true)。</li>
<li>data：发送到服务器的数据，可以是<strong>键值对或者 js 对象</strong>形式。</li>
<li>type：请求方式，POST 或 GET (默认是 GET)。</li>
<li>dataType：预期的返回数据的类型，取值可以是 xml, html, js, json, text等。</li>
<li>success：请求成功时调用的回调函数。</li>
<li>error：请求失败时调用的回调函数。</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 分页知识</h2>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/分页知识.png" alt="分页知识" tabindex="0" loading="lazy"><figcaption>分页知识</figcaption></figure>
<hr>
]]></content:encoded>
      <enclosure url="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/AJAX网页局部更新.png" type="image/png"/>
    </item>
    <item>
      <title>CSS</title>
      <link>https://newzone.top/JavaWeb/CSS.html</link>
      <guid>https://newzone.top/JavaWeb/CSS.html</guid>
      <source url="https://newzone.top/rss.xml">CSS</source>
      <description>CSS CSS入门 概述 CSS (层叠样式表——Cascading Style Sheets，缩写为 CSS），简单的说，它是用于设置和布局网页的计算机语言。会告知浏览器如何渲染页面元素。例如，调整内容的字体，颜色，大小等样式，设置边框的样式，调整模块的间距等。 层叠：是指样式表允许以多种方式规定样式信息。可以规定在单个元素中，可以在页面头元素中，也可以在另一个CSS文件中，规定的方式会有次序的差别。 样式：是指丰富的样式外观。拿边框距离来说，允许任何设置边框，允许设置边框与框内元素的距离，允许设置边框与边框的距离等等。</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> CSS</h1>
<h2> CSS入门</h2>
<h3> 概述</h3>
<p>CSS (层叠样式表——Cascading Style Sheets，缩写为 <strong>CSS</strong>），简单的说，它是用于设置和布局网页的计算机语言。会告知浏览器如何渲染页面元素。例如，调整内容的字体，颜色，大小等样式，设置边框的样式，调整模块的间距等。</p>
<p>层叠：是指样式表允许以多种方式规定样式信息。可以规定在单个元素中，可以在页面头元素中，也可以在另一个CSS文件中，规定的方式会有次序的差别。</p>
<p>样式：是指丰富的样式外观。拿边框距离来说，允许任何设置边框，允许设置边框与框内元素的距离，允许设置边框与边框的距离等等。</p>
<hr>
<h3> 组成</h3>
<p>CSS是一门基于规则的语言—你能定义用于你的网页中<strong>特定元素</strong>的一组<strong>样式规则</strong>。这里面提到了两个概念，一是特定元素，二是样式规则。对应CSS的语法，也就是<strong>选择器（<em>selects</em>）<strong>和</strong>声明（<em>eclarations</em>）</strong>。</p>
<ul>
<li>选择器：指定要添加样式的 HTML元素的方式。可以使用标签名，class值，id值等多种方式。</li>
<li>声明：形式为<strong>属性(property):值(value)</strong>，用于设置特定元素的属性信息。
<ul>
<li>属性：指示文体特征，例如<code>font-size</code>，<code>width</code>，<code>background-color</code>。</li>
<li>值：每个指定的属性都有一个值，该值指示您如何更改这些样式。</li>
</ul>
</li>
</ul>
<p>格式：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS的组成.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 实现</h3>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> CSS语法</h2>
<h3> 注释方式</h3>
<p>CSS中的注释以<code>/*</code>和开头<code>*/</code>。</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 引入方式</h3>
<h4> 内联样式</h4>
<p>内联样式是CSS声明在元素的<code>style</code>属性中，仅影响一个元素：</p>
<ul>
<li>
<p>格式：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>例如：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>效果：</p>
<h1 style="color: blue;background-color: yellow;border: 1px solid black;">
    Hello World!
</h1>
</li>
<li>
<p>特点：格式简单，但是样式作用无法复用到多个元素上，不利于维护</p>
</li>
</ul>
<h4> 内部样式表</h4>
<p>内部样式表是将CSS样式放在<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/style" target="_blank" rel="noopener noreferrer">style</a>标签中，通常style标签编写在HTML 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/head" target="_blank" rel="noopener noreferrer">head</a>标签内部。</p>
<ul>
<li>
<p>格式：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>例如：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>特点：内部样式只能作用在当前页面上，如果是多个页面，就无法复用了</p>
</li>
</ul>
<h4> 外部样式表</h4>
<p>外部样式表是CSS附加到文档中的最常见和最有用的方法，因为您可以将CSS文件链接到多个页面，从而允许您使用相同的样式表设置所有页面的样式。</p>
<p>外部样式表是指将CSS编写在扩展名为<code>.css</code> 的单独文件中，并从HTML<code>&lt;link&gt;</code> 元素引用它，通常link标签`编写在HTML 的[head]标签内部。</p>
<ul>
<li>
<p>格式</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul>
<li>rel：表示“关系 (relationship) ”，属性值指链接方式与包含它的文档之间的关系，引入css文件固定值为stylesheet。</li>
<li>href：属性需要引用某文件系统中的一个文件。</li>
</ul>
</li>
<li>
<p>举例</p>
<ul>
<li>
<p>创建styles.css文件</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>link标签引入文件</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果同上</p>
</li>
</ul>
</li>
<li>
<p>为了CSS文件的管理，在项目中创建一个<code>css文件夹</code>，专门保存样式文件，并调整指定的路径以匹配</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h4> 优先级</h4>
<p>规则层叠于一个样式表中，其中数字 4 拥有最高的优先权：</p>
<ol>
<li>浏览器缺省设置</li>
<li>外部样式表</li>
<li>内部样式表（位于 &lt;head&gt; 标签内部）</li>
<li>内联样式（在 HTML 元素内部）</li>
</ol>
<hr>
<h3> 选择器</h3>
<h4> 介绍选择器</h4>
<p>为了样式化某些元素，我们会通过选择器来选中HTML文档中的这些元素，每个CSS规则都以一个选择器或一组选择器为开始，去告诉浏览器这些规则应该应用到哪些元素上。</p>
<p>选择器的分类：</p>
<table>
<thead>
<tr>
<th>分类</th>
<th>名称</th>
<th>符号</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本选择器</td>
<td>元素选择器</td>
<td>标签名</td>
<td>基于标签名匹配元素</td>
<td>div</td>
</tr>
<tr>
<td></td>
<td>类选择器</td>
<td><code>.</code></td>
<td>基于class属性值匹配元素</td>
<td>.center</td>
</tr>
<tr>
<td></td>
<td>ID选择器</td>
<td><code>#</code></td>
<td>基于id属性值匹配元素</td>
<td>#username</td>
</tr>
<tr>
<td></td>
<td>通用选择器</td>
<td><code>*</code></td>
<td>匹配文档中的所有内容</td>
<td>*</td>
</tr>
<tr>
<td>属性选择器</td>
<td>属性选择器</td>
<td><code>[]</code></td>
<td>基于某属性匹配元素</td>
<td>[type]</td>
</tr>
<tr>
<td>伪类选择器</td>
<td>伪类选择器</td>
<td><code>:</code></td>
<td>用于向某些选择器添加特殊的效果</td>
<td>a:hover</td>
</tr>
<tr>
<td>组合选择器</td>
<td>分组选择器</td>
<td>,</td>
<td>使用 , 号结合两个选择器，匹配两个选择器的元素</td>
<td>span,p{}</td>
</tr>
<tr>
<td></td>
<td>后代选择器</td>
<td>空格</td>
<td>使用空格符号结合两个选择器，基于<br>第一个选择器，匹配第二个选择器的所有后代元素</td>
<td>.top li</td>
</tr>
</tbody>
</table>
<h4> 基本选择器</h4>
<ul>
<li>
<p>页面元素：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>元素选择器</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>类选择器</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>ID选择器</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>通用选择器</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 属性选择器</h4>
<ul>
<li>
<p>页面：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>选择器：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 伪类选择器</h4>
<ul>
<li>
<p>页面元素</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>伪类选择器</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>注意：伪类顺序 link ，visited，hover，active，否则有可能失效。</p>
</li>
</ul>
<hr>
<h4> 组合选择器</h4>
<ul>
<li>
<p>页面：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>分组选择器</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>后代选择器</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 优先级</h4>
<p>选择器优先级</p>
<ul>
<li>ID选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通用选择器</li>
<li>如果优先级相同，那么就满足就近原则</li>
</ul>
<hr>
<h3> 边框样式</h3>
<h4> 单个边框</h4>
<ul>
<li>
<p>单个边框<br>
border：边框<br>
border-top: 上边框<br>
border-left: 左边框<br>
border-bottom: 底边框<br>
border-right:  右边框</p>
</li>
<li>
<p>无边框，当border值为none时，可以让边框不显示</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>圆角</p>
<p>通过使用[<code>border-radius</code>]属性设置盒子的圆角，虽然能分别设置四个角，但是通常我们使用一个值，来设置整体效果</p>
</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS-边框样式效果图.png" style="zoom:80%;">
<hr>
<h4> 边框轮廓</h4>
<p>轮廓<strong>outline</strong>：是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用</p>
<ul>
<li>属性值：double：双实线   dotted：圆点   dashed：虚线   none：无</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS边框轮廓效果图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 盒子模型</h4>
<h5> 模型介绍</h5>
<p>盒子模型是通过设置<strong>元素框</strong>与<strong>元素内容</strong>和<strong>外部元素</strong>的边距，而进行布局的方式。</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS盒子模型.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>element : 元素。</li>
<li>padding : 内边距，也有资料将其翻译为填充。</li>
<li>border : 边框。</li>
<li>margin : 外边距，也有资料将其翻译为空白或空白边。</li>
</ul>
<h5> 边距</h5>
<p>内边距、边框和外边距都是可选的，默认值是零。在 CSS 中，width 和 height 指的是内容区域的宽度和高度。</p>
<ul>
<li>
<p>外边距<br>
单独设置边框的外边距，设置上、右、下、左方向：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>一个值</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>两个值</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>三个值</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>四个值</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>内边距<br>
与外边距类似，单独设置边框的内边距，设置上、右、下、左方向：</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h5> 布局</h5>
<ul>
<li>
<p>基本布局</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS盒子模式-效果图1.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>增加内边距会增加元素框的总尺寸</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS盒子模式-效果图2.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<hr>
<h3> 文本样式</h3>
<h4> 基本属性</h4>
<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
<th>属性取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>width</td>
<td>宽度</td>
<td></td>
</tr>
<tr>
<td>height</td>
<td>高度</td>
<td></td>
</tr>
<tr>
<td>color</td>
<td>颜色</td>
<td></td>
</tr>
<tr>
<td>font-family</td>
<td>字体样式</td>
<td>宋体、楷体</td>
</tr>
<tr>
<td>font-size</td>
<td>字体大小</td>
<td>px : 像素，文本高度像素绝对数值。<br>em : 1em等于当前元素的父元素设置的字体大小，是相对数值</td>
</tr>
<tr>
<td>text-decoration</td>
<td>下划线</td>
<td>underline : 下划线  <br>overline : 上划线 <br>line-through : 删除线 <br>none : 不要线条</td>
</tr>
<tr>
<td>text-align</td>
<td>文本水平对齐</td>
<td>lef : 左对齐文本<br>right : 右对齐文本<br>center : 使文本居中 <br>justify : 使文本散布，改变单词间的间距，使文本所有行具有相同宽度。</td>
</tr>
<tr>
<td>line-height</td>
<td>行高，行间距</td>
<td></td>
</tr>
<tr>
<td>vertical-align</td>
<td>文本垂直对齐</td>
<td>top：居上   bottom：居下  middle：居中   或者百分比</td>
</tr>
<tr>
<td>display</td>
<td>元素如何显示</td>
<td>可以设置块级和行内元素的切换，也可以设置元素隐藏<br>inline：内联元素(无换行、无长宽)   <br>block：块级元素(有换行)  <br>inline-block：内联元素(有长宽)  <br>none：隐藏元素</td>
</tr>
</tbody>
</table>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS-文本样式效果图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 文本显示</h4>
<ul>
<li>
<p>元素显示</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>元素隐藏</p>
<p>当设置为none时，可以隐藏元素。</p>
</li>
</ul>
<hr>
<h2> CSS案例</h2>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
]]></content:encoded>
      <enclosure url="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/CSS的组成.png" type="image/png"/>
    </item>
    <item>
      <title>HTML</title>
      <link>https://newzone.top/JavaWeb/HTML.html</link>
      <guid>https://newzone.top/JavaWeb/HTML.html</guid>
      <source url="https://newzone.top/rss.xml">HTML</source>
      <description>HTML HTML入门 概述 HTML（超文本标记语言—HyperText Markup Language）是构成 Web 世界的基础，是一种用来告知浏览器如何组织页面的标记语言 超文本 Hypertext，是指连接单个或者多个网站间的网页的链接。通过链接，就能访问互联网中的内容 标记 Markup ，是用来注明文本，图片等内容，以便于在浏览器中显示，例如 &amp;lt;head&amp;gt;，&amp;lt;body&amp;gt; 等</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> HTML</h1>
<h2> HTML入门</h2>
<h3> 概述</h3>
<p>HTML（超文本标记语言—HyperText Markup Language）是构成 Web 世界的基础，是一种用来告知浏览器如何组织页面的标记语言</p>
<ul>
<li>
<p>超文本 Hypertext，是指连接单个或者多个网站间的网页的链接。通过链接，就能访问互联网中的内容</p>
</li>
<li>
<p>标记 Markup ，是用来注明文本，图片等内容，以便于在浏览器中显示，例如 <code>&lt;head&gt;</code>，<code>&lt;body&gt;</code> 等</p>
</li>
</ul>
<p><strong>网页的构成</strong></p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML" target="_blank" rel="noopener noreferrer">HTML</a>：通常用来定义网页内容的含义和基本结构</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener noreferrer">CSS</a>：通常用来描述网页的表现与展示效果</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="noopener noreferrer">JavaScript</a>：通常用来执行网页的功能与行为</li>
</ul>
<p>参考视频：<a href="https://www.bilibili.com/video/BV1Qf4y1T7Hx" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1Qf4y1T7Hx</a></p>
<hr>
<h3> 组成</h3>
<h4> 标签</h4>
<p>HTML 页面由一系列的<strong>元素（elements）</strong> 组成，而元素是使用<strong>标签</strong>创建的</p>
<p>一对标签（tags）可以设置一段文字样式，添加一张图片或者添加超链接等等</p>
<p>在 HTML 中，<code>&lt;h1&gt;</code> 标签表示<strong>标题</strong>，我们可以使用<strong>开始标签</strong>和<strong>结束标签</strong>包围文本内容，这样其中的内容就以标题的形式显示</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 属性</h4>
<p>HTML 标签可以拥有属性</p>
<ul>
<li>属性是属于标签的，修饰标签，让标签有更多的效果</li>
<li>属性一般定义在起始标签里面</li>
<li>属性一般以<strong>属性=属性值</strong>的形式出现</li>
<li>属性值一般用 <code>''</code> 或者 <code>""</code> 括起来。 不加引号也是可以的(不建议使用)。比如：name='value'</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在 HTML 标签中，<code>align</code>  属性表示<strong>水平对齐方式</strong>，我们可以赋值为 <code>center</code>  表示 <strong>居中</strong> 。</p>
<hr>
<h3> 结构</h3>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML结构.png" alt="HTML结构" tabindex="0" loading="lazy"><figcaption>HTML结构</figcaption></figure>
<p>文档结构介绍：</p>
<ul>
<li>文档声明：用于声明当前 HTML 的版本，这里的<code>&lt;!DOCTYPE html&gt;</code>是 HTML5 的声明</li>
<li>html 根标签：除文档声明以外，其它内容全部要放在根标签 html 内部</li>
<li>文档头部配置：head 标签，是当前页面的配置信息，外部引入文件, 例如网页标签、字符集等
<ul>
<li><code>&lt;meta charset="utf-8"&gt;</code>：这个标签是页面的元数据信息，设置文档使用 utf-8 字符集编码</li>
<li><code>&lt;title&gt;</code>：这个标签定义文档标题，位置出现在浏览器标签。在收藏页面时，它可用来描述页面</li>
</ul>
</li>
<li>文档显示内容：body 标签，里边的内容会显示到浏览器页面上</li>
</ul>
<hr>
<h2> HTML语法</h2>
<h3> 注释方式</h3>
<p>将一段 HTML 中的内容置为注释，你需要将其用特殊的记号 <!----> 包括起来</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 基本元素</h3>
<h4> 空元素</h4>
<p>一些元素只有一个标签，叫做空元素。它是在开始标签中进行关闭的。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4> 嵌套元素</h4>
<p>把元素放到其它元素之中——这被称作嵌套。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4> 块元素</h4>
<p>在HTML中有两种重要元素类别，块级元素和内联元素</p>
<ul>
<li>
<p>块级元素：</p>
<p><strong>独占一行</strong>。块级元素（block）在页面中以块的形式展现。相对于其前面的内容它会出现在新的一行，其后的内容也会被挤到下一行展现。比如<code>&lt;p&gt;</code> ，<code>&lt;hr&gt;</code>，<code>&lt;li&gt;</code> ，<code>&lt;div&gt;</code>等。</p>
</li>
<li>
<p>行内元素</p>
<p><strong>行内显示</strong>。行内元素不会导致换行。通常出现在块级元素中并环绕文档内容的一小部分，而不是一整个段落或者一组内容。比如<code>&lt;b&gt;</code>，<code>&lt;a&gt;</code>，<code>&lt;i&gt;</code>，<code>&lt;span&gt;</code> 等。</p>
</li>
</ul>
<p>注意：一个块级元素不会被嵌套进行内元素中，但可以嵌套在其它块级元素中。</p>
<p>常用的两个标签：（<strong>重要</strong>）</p>
<ul>
<li><code>&lt;div&gt;</code> 是一个通用的内容容器，并没有任何特殊语义。它可以被用来对其它元素进行分组，一般用于样式化相关的需求。它是一个<strong>块级元素</strong>。</li>
<li>属性：id、style、class</li>
<li><code> &lt;span&gt;</code> 是短语内容的通用行内容器，并没有任何特殊语义。它可以被用来编组元素以达到某种样式。它是一个<strong>行内元素</strong></li>
</ul>
<hr>
<h3> 基本属性</h3>
<p>标签属性，主要用于拓展标签。属性包含元素的额外信息，这些信息不会出现在实际的内容中。但是可以改变标签的一些行为或者提供数据，属性总是以<code>name = value"</code>的格式展现。</p>
<ul>
<li>
<p>属性名：同一个标签中，属性名不得重复。</p>
</li>
<li>
<p>大小写：属性和属性值对大小写不敏感。不过W3C标准中，推荐使用小写的属性/属性值。</p>
</li>
<li>
<p>引号：双引号是最常用的，不过使用单引号也没有问题。</p>
</li>
<li>
<p>常用属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>定义元素类名，用来选择和访问特定的元素</td>
</tr>
<tr>
<td>id</td>
<td>定义元素<strong>唯一</strong>标识符，在整个文档中必须是唯一的</td>
</tr>
<tr>
<td>name</td>
<td>定义元素名称，可以用于提交服务器的表单字段</td>
</tr>
<tr>
<td>value</td>
<td>定义在元素内显示的默认值</td>
</tr>
<tr>
<td>style</td>
<td>定义CSS样式，这些样式会覆盖之前设置的样式</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h3> 特殊字符</h3>
<p>在HTML中，字符 <code>&lt;</code>, <code>&gt;</code>,<code>"</code>,<code>'</code> 和 <code>&amp;</code> 是特殊字符</p>
<table>
<thead>
<tr>
<th>原义字符</th>
<th>等价字符引用</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;</td>
<td><code>&amp;lt;</code></td>
</tr>
<tr>
<td>&gt;</td>
<td><code>&amp;gt;</code></td>
</tr>
<tr>
<td>"</td>
<td><code>&amp;quot;</code></td>
</tr>
<tr>
<td>'</td>
<td><code>&amp;apos;</code></td>
</tr>
<tr>
<td>&amp;</td>
<td><code>&amp;amp;</code></td>
</tr>
<tr>
<td>空格</td>
<td><code>&amp;nbsp;</code></td>
</tr>
</tbody>
</table>
<hr>
<h3> 文本标签</h3>
<p>使用文本内容标签设置文字基本样式</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>p</td>
<td>表示文本的一个段落</td>
</tr>
<tr>
<td>h</td>
<td>表示文档标题，<code>&lt;h1&gt;–&lt;h6&gt;</code> ，呈现了六个不同的级别的标题，<code>&lt;h1&gt;</code> 级别最高，而 <code>&lt;h6&gt;</code> 级别最低</td>
</tr>
<tr>
<td>hr</td>
<td>表示段落级元素之间的主题转换，一般显示为水平线</td>
</tr>
<tr>
<td>li</td>
<td>表示列表里的条目。（常用在ul ol 中）</td>
</tr>
<tr>
<td>ul</td>
<td>表示一个无序列表，可含多个元素，无编号显示。</td>
</tr>
<tr>
<td>ol</td>
<td>表示一个有序列表，通常渲染为有带编号的列表</td>
</tr>
<tr>
<td>em</td>
<td>表示文本着重，一般用斜体显示</td>
</tr>
<tr>
<td>strong</td>
<td>表示文本重要，一般用粗体显示</td>
</tr>
<tr>
<td>font</td>
<td>表示字体，可以设置样式（已过时）</td>
</tr>
<tr>
<td>i</td>
<td>表示斜体</td>
</tr>
<tr>
<td>b</td>
<td>表示加粗文本</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>效果如下</strong>：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML文本标签效果图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 图片标签</h3>
<p>img标签中的img其实是英文image的缩写, img标签的作用, 就是告诉浏览器我们需要显示一张图片</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>src</strong></td>
<td>图片路径</td>
</tr>
<tr>
<td><strong>title</strong></td>
<td>鼠标悬停（hover）时显示文本。</td>
</tr>
<tr>
<td><strong>alt</strong></td>
<td>图片描述，图形不显示时的替换文本。</td>
</tr>
<tr>
<td><strong>height</strong></td>
<td>图像的高度。</td>
</tr>
<tr>
<td><strong>width</strong></td>
<td>图像的宽度。</td>
</tr>
</tbody>
</table>
<hr>
<h3> 超链接</h3>
<p>超链接标签的作用: 就是用于控制页面与页面(服务器资源)之间跳转的</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果图：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML超链接效果图.png" style="zoom: 67%;">
<hr>
<h3> 表单标签</h3>
<h4> 基本介绍</h4>
<p><strong>form</strong>  表示表单，是用来<strong>收集用户输入信息并向 Web 服务器提交</strong>的一个容器</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>action</td>
<td>处理此表单信息的Web服务器的URL地址</td>
</tr>
<tr>
<td>method</td>
<td>提交此表单信息到Web服务器的方式，可能的值有get和post，默认为get</td>
</tr>
<tr>
<td>autocomplete</td>
<td>自动补全，指示表单元素是否能够拥有一个默认值，配合input标签使用</td>
</tr>
</tbody>
</table>
<p>get与post区别：</p>
<ul>
<li>
<p>post：指的是 HTTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5" target="_blank" rel="noopener noreferrer">POST 方法</a>；表单数据会包含在表单体内然后发送给服务器。</p>
</li>
<li>
<p>get：指的是 HTTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.3" target="_blank" rel="noopener noreferrer">GET 方法</a>；表单数据会附加在 <code>action</code> 属性的URI中，并以 '?' 作为分隔符，然后这样得到的 URI 再发送给服务器。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>地址栏可见</th>
<th>数据安全</th>
<th>数据大小</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>可见</td>
<td>不安全</td>
<td>有限制（取决于浏览器）</td>
</tr>
<tr>
<td>POST</td>
<td>不可见</td>
<td>相对安全</td>
<td>无限制</td>
</tr>
</tbody>
</table>
<h4> 表单元素</h4>
<table>
<thead>
<tr>
<th>标签名</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>label</td>
<td>表单元素的说明，配合表单元素使用</td>
<td>for属性值为相关表单元素id属性值</td>
</tr>
<tr>
<td>input</td>
<td>表单中输入控件，多种输入类型，用于接受来自用户数据</td>
<td>type属性值决定输入类型</td>
</tr>
<tr>
<td>button</td>
<td>页面中可点击的按钮，可以配合表单进行提交</td>
<td>type属性值决定按钮类型</td>
</tr>
<tr>
<td>select</td>
<td>表单的控件，下拉选项菜单</td>
<td>与option配合实用</td>
</tr>
<tr>
<td>optgroup</td>
<td>option的分组标签</td>
<td>与option配合实用</td>
</tr>
<tr>
<td>option</td>
<td>select的子标签，表示一个选项</td>
<td></td>
</tr>
<tr>
<td>textarea</td>
<td>表示多行纯文本编辑控件</td>
<td></td>
</tr>
<tr>
<td>fieldset</td>
<td>用来对表单中的控制元素进行分组(也包括 label 元素)</td>
<td></td>
</tr>
<tr>
<td>legend</td>
<td>用于表示它的fieldset内容的标题。</td>
<td>fieldset 的子元素</td>
</tr>
</tbody>
</table>
<h4> 按键控件</h4>
<p>button标签：表示按钮</p>
<ul>
<li>type属性：表示按钮类型，submit值为提交按钮。</li>
</ul>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>button</td>
<td>无行为按钮，用于结合JavaScript实现自定义动态效果</td>
<td>同 <code>&lt;input type="submit"/&gt; </code></td>
</tr>
<tr>
<td>submit</td>
<td>提交按钮，用于提交表单数据到服务器。</td>
<td>同 <code>&lt;input type="submit"/&gt; </code></td>
</tr>
<tr>
<td>reset</td>
<td>重置按钮，用于将表单中内容恢复为默认值。</td>
<td>同<code>&lt;input type="reset"</code>/&gt;</td>
</tr>
</tbody>
</table>
<hr>
<h4> 输入控件</h4>
<h5> 基本介绍</h5>
<ul>
<li>
<p>label标签：表单的说明。</p>
<ul>
<li>for属性值：匹配input标签的id属性值</li>
</ul>
</li>
<li>
<p>input标签：输入控件。</p>
<p>属性：</p>
<ul>
<li>type：表示输入类型，text值为普通文本框</li>
<li>id：表示标签唯一标识</li>
<li>name：表示标签名称，提交服务器的标识</li>
<li>value：表示标签的默认数据值</li>
<li>placeholder：默认的提示信息，仅适用于当type 属性为text, search, tel, url or email时;</li>
<li>required：是否必须为该元素填充值，当type属性是hidden,image或者button类型时不可使用</li>
<li>readonly：是否只读,可以让用户不修改这个输入框的值,就使用value属性设置默认值</li>
<li>disabled：是否可用,如果某个输入框有disabled那么它的数据不能提交到服务器通常是使用在有的页面中，让一些按钮不能点击</li>
<li>autocomplete：自动补全，规定表单或输入字段是否应该自动完成。当自动完成开启，浏览器会基于用户之前的输入值自动填写值。可以设置指定的字段为off，关闭自动补全</li>
</ul>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果图：</p>



    <meta charset="UTF-8">
    <title>表单项标签</title>


    <form action="#" method="get" autocomplete="off">
        <label for="username">用户名：</label>
        <input type="text" id="username" name="username" value="" placeholder=" 请在此处输入用户名" required="">
        <button type="submit">提交</button>
        <button type="reset">重置</button>
        <button type="button">按钮</button>
    </form>


<h5> n-v属性</h5>
<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>name</strong></td>
<td><code>&lt;input&gt;</code>的名字，在提交整个表单数据时，可以用于区分属于不同<code>&lt;input&gt;</code>的值</td>
</tr>
<tr>
<td><strong>value</strong></td>
<td>这个<code>&lt;input&gt;</code>元素当前的值，允许用户通过页面输入</td>
</tr>
</tbody>
</table>
<p>使用方式：以name属性值作为键，value属性值作为值，构成键值对提交到服务器，多个键值对浏览器使用<code>&amp;</code>进行分隔。</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML标签input属性-name-value.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<h5> type属性</h5>
<table>
<thead>
<tr>
<th>属性值</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>text</td>
<td>单行文本字段</td>
<td></td>
</tr>
<tr>
<td>password</td>
<td>单行文本字段，值被遮盖</td>
<td></td>
</tr>
<tr>
<td>email</td>
<td>用于编辑 e-mail 的字段，可以对e-mail地址进行简单校验</td>
<td></td>
</tr>
<tr>
<td>radio</td>
<td>单选按钮。 1. 在同一个”单选按钮组“中，所有单选按钮的 name 属性使用同一个值；一个单选按钮组中是，同一时间只有一个单选按钮可以被选择。 2. 必须使用 value 属性定义此控件被提交时的值。 3. 使用checked 必须指示控件是否缺省被选择。</td>
<td></td>
</tr>
<tr>
<td>checkbox</td>
<td>复选框。 1. 必须使用 value 属性定义此控件被提交时的值。 2. 使用 checked 属性指示控件是否被选择。 3. 选中多个值时，所有的值会构成一个数组而提交到Web服务器</td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>HTML5 用于输入日期的控件</td>
<td>年，月，日，不包括时间</td>
</tr>
<tr>
<td>time</td>
<td>HTML5 用于输入时间的控件</td>
<td>不含时区</td>
</tr>
<tr>
<td>datetime-local</td>
<td>HTML5 用于输入日期时间的控件</td>
<td>不包含时区</td>
</tr>
<tr>
<td>number</td>
<td>HTML5 用于输入浮点数的控件</td>
<td></td>
</tr>
<tr>
<td>range</td>
<td>HTML5 用于输入不精确值控件</td>
<td>max-规定最大值min-规定最小值 step-规定步进值 value-规定默认值</td>
</tr>
<tr>
<td>search</td>
<td>HTML5 用于输入搜索字符串的单行文本字段</td>
<td>可以点击<code>x</code>清除内容</td>
</tr>
<tr>
<td>tel</td>
<td>HTML5 用于输入电话号码的控件</td>
<td></td>
</tr>
<tr>
<td>url</td>
<td>HTML5 用于编辑URL的字段</td>
<td>可以校验URL地址格式</td>
</tr>
<tr>
<td>file</td>
<td>此控件可以让用户选择文件，用于文件上传。</td>
<td>使用 accept 属性可以定义控件可以选择的文件类型。</td>
</tr>
<tr>
<td>hidden</td>
<td>此控件用户在页面上不可见，但它的值会被提交到服务器，用于传递隐藏值</td>
<td></td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML标签input属性-type.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 选择控件</h4>
<p>下拉列表标签&lt;select&gt;：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>option：选择菜单的选项</p>
</li>
<li>
<p>optgroup：列表项分组标签<br>
属性：label设置分组名称</p>
</li>
</ul>
<h4> 文本域控件</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>属性：</p>
<ul>
<li>
<p>name-标签名称</p>
</li>
<li>
<p>rows-行数</p>
</li>
<li>
<p>cols-列数</p>
</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML标签select和文本域属性.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 分组控件</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><form action="#" method="post">
  <fieldset>
    	<legend>是否同意</legend>
        <input type="radio" id="radio_y" name="agree" value="y"> 
      	<label for="radio_y">同意</label>
        <input type="radio" id="radio_n" name="agree" value="n"> 
      	<label for="radio_n">不同意</label>
  </fieldset>
</form>
<hr>
<h3> 表格标签</h3>
<h4> 基本属性</h4>
<p><code>&lt;table&gt;</code> , 表示表格标签，表格是数据单元的行和列的两维表</p>
<ul>
<li>tr：table row，表示表中单元的行</li>
<li>td：table data，表示表中一个单元格</li>
<li>th：table header，表格单元格的表头，通常字体样式加粗居中</li>
<li><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML表格标签.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li>
</ul>
<p>代码展示：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果图：</p>
<table>
      <tbody><tr>
        <th>First name</th>
        <th>Last name</th>
      </tr>
      <tr>
        <td>John</td>
        <td>Doe</td>
      </tr>
      <tr>
        <td>Jane</td>
        <td>Doe</td>
      </tr>
</tbody></table>
<hr>
<h4> 跨行跨列</h4>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>效果图：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML表格标签跨行跨列效果图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 表格结构</h4>
<table>
<thead>
<tr>
<th>标签名</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>thead</td>
<td>定义表格的列头的行</td>
<td>一个表格中仅有一个</td>
</tr>
<tr>
<td>tbody</td>
<td>定义表格的主体</td>
<td>用来封装一组表行（tr元素）</td>
</tr>
<tr>
<td>tfoot</td>
<td>定义表格的各列汇总行</td>
<td>一个表格中仅有一个</td>
</tr>
</tbody>
</table>
<hr>
<h3> 样式布局</h3>
<h4> 基本格式</h4>
<p>在head标签中，通过style标签加入样式。</p>
<p>基本格式：可以含有多个属性，一个属性名也可以含有多个值，同时设置多样式。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 背景格式</h4>
<p>background属性用来设置背景相关的样式。</p>
<ul>
<li>
<p>背景色<br>
[<code>background-color</code>]属性定义任何元素的背景色</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>背景图<br>
该[<code>background-image</code>]属性允许在元素的背景中显示图像。使用url函数指定图片路径</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML背景图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>背景重复</p>
<p>[<code>background-repeat</code>]属性用于控制图像的平铺行为。可用值：</p>
<ul>
<li><code>no-repeat</code> -停止完全重复背景</li>
<li><code>repeat-x</code> —水平重复</li>
<li><code>repeat-y</code> —竖直重复</li>
<li><code>repeat</code>—默认值；双向重复</li>
</ul>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML背景设计.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<hr>
<h4> div布局</h4>
<ul>
<li>
<p>div简单布局：</p>
<ul>
<li>broader：边界</li>
<li>solid：实线</li>
<li>blue：颜色</li>
</ul>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML-div简单布局.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>class值<br>
可以设置宽度，浮动，背景</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>属性</p>
<ul>
<li>
<p>background：背景颜色</p>
</li>
<li>
<p>width：宽度 (npx 或者 n%)</p>
</li>
<li>
<p>height：长度</p>
</li>
<li>
<p>text-align：文本对齐方式</p>
</li>
<li>
<p>background-image: url("../img/bg.png")：背景图</p>
</li>
<li>
<p>float：浮动</p>
<p>指定一个元素应沿其容器的左侧或右侧放置，允许文本或者内联元素环绕它，该元素从网页的正常流动中移除，其他部分保持正常文档流顺序。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
</li>
<li>
<p>div基本布局</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML-div基本布局.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<hr>
<h3> 语义化标签</h3>
<p>为了更好的组织文档，HTML5规范中设计了几个语义元素，可以将特殊含义传达给浏览器。</p>
<table>
<thead>
<tr>
<th>标签</th>
<th>名称</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>header</strong></td>
<td>标头元素</td>
<td>表示内容的介绍</td>
<td>块元素，文档中可以定义多个</td>
</tr>
<tr>
<td><strong>nav</strong></td>
<td>导航元素</td>
<td>表示导航链接</td>
<td>常见于网站的菜单，目录和索引等，可以嵌套在header中</td>
</tr>
<tr>
<td><strong>article</strong></td>
<td>文章元素</td>
<td>表示独立内容区域</td>
<td>标签定义的内容本身必须是有意义且必须独立于文档的其他部分</td>
</tr>
<tr>
<td><strong>footer</strong></td>
<td>页脚元素</td>
<td>表示页面的底部</td>
<td>块元素，文档中可以定义多个</td>
</tr>
</tbody>
</table>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/语义化标签结构图.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h2> HTML拓展</h2>
<h3> 音频标签</h3>
<p><code>&lt;audio&gt;</code>：用于播放声音，比如音乐或其他音频流，是 HTML 5 的新标签。</p>
<p>常用属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>取值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td>URL</td>
<td>音频资源的路径</td>
</tr>
<tr>
<td>autoplay</td>
<td>autoplay</td>
<td>音频准备就绪后自动播放</td>
</tr>
<tr>
<td>controls</td>
<td>controls</td>
<td>显示控件，比如播放按钮。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>表示循环播放</td>
</tr>
<tr>
<td>preload</td>
<td>preload</td>
<td>音频在页面加载时进行预加载。<br>如果使用 "autoplay"，则忽略该属性。</td>
</tr>
</tbody>
</table>



    <meta charset="UTF-8">
    <title>HTML5媒体标签-音频audio</title>


    <audio src="media/horse.ogg" controls="">
        你的浏览器不支持 audio 标签。
    </audio>


<hr>
<h3> 视频标签</h3>
<p><code>&lt;video&gt;</code> 标签用于播放视频，比如电影片段或其他视频流，是 HTML 5 的新标签。</p>
<p>常用属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>取值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td><em>URL</em></td>
<td>要播放的视频的 URL。</td>
</tr>
<tr>
<td>width</td>
<td></td>
<td>设置视频播放器的宽度。</td>
</tr>
<tr>
<td>height</td>
<td></td>
<td>设置视频播放器的高度。</td>
</tr>
<tr>
<td>autoplay</td>
<td>autoplay</td>
<td>视频在就绪后自动播放。</td>
</tr>
<tr>
<td>control</td>
<td>controls</td>
<td>显示控件，比如播放按钮。</td>
</tr>
<tr>
<td>loop</td>
<td>loop</td>
<td>如果出现该属性，则当媒介文件完成播放后再次开始播放。</td>
</tr>
<tr>
<td>preload</td>
<td>preload</td>
<td>视频在页面加载时进行加载。<br>如果使用 "autoplay"，则忽略该属性。</td>
</tr>
<tr>
<td>mute</td>
<td>muted</td>
<td>规定视频的音频输出应该被静音。</td>
</tr>
<tr>
<td>poste</td>
<td><em>URL</em></td>
<td>视频下载时显示的图像，或者视频播放前显示的图像。</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML标签video.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 回到顶部</h3>
<p>在html里面锚点的作用: 通过a标签跳转到指定的位置.</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3> 详情概要</h3>
<p>summary标签来描述概要信息, 利用details标签来描述详情信息. 默认情况下是折叠展示, 想看见详情必须点击</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><details>
    <summary>概要信息</summary>
    详情信息
</details>
<hr>
]]></content:encoded>
      <enclosure url="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTML结构.png" type="image/png"/>
    </item>
    <item>
      <title>HTTP</title>
      <link>https://newzone.top/JavaWeb/HTTP.html</link>
      <guid>https://newzone.top/JavaWeb/HTTP.html</guid>
      <source url="https://newzone.top/rss.xml">HTTP</source>
      <description>HTTP 相关概念 HTTP：Hyper Text Transfer Protocol，意为超文本传输协议，是建立在 TCP/IP 协议基础上，指的是服务器和客户端之间交互必须遵循的一问一答的规则，形容这个规则：问答机制、握手机制 HTTP 协议是一个无状态的面向连接的协议，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。所以打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系 注意：无状态并不是代表 HTTP 就是 UDP，面向连接也不是代表 HTTP 就是TCP</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> HTTP</h1>
<h2> 相关概念</h2>
<p>HTTP：Hyper Text Transfer Protocol，意为超文本传输协议，是建立在 <strong>TCP/IP 协议</strong>基础上，指的是服务器和客户端之间交互必须遵循的一问一答的规则，形容这个规则：问答机制、握手机制</p>
<p>HTTP 协议是<strong>一个无状态的面向连接的协议</strong>，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。所以打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系</p>
<p>注意：无状态并不是代表 HTTP 就是 UDP，面向连接也不是代表 HTTP 就是TCP</p>
<p>HTTP 作用：用于定义 WEB 浏览器与 WEB 服务器之间交换数据的过程和数据本身的内容</p>
<p>浏览器和服务器交互过程：浏览器请求，服务请求响应</p>
<ul>
<li>请求（请求行、请求头、请求体）</li>
<li>响应（响应行、响应头、响应体）</li>
</ul>
<p>URL 和 URI</p>
<ul>
<li>
<p>URL：统一资源定位符</p>
<ul>
<li>格式：<a href="http://127.0.0.1:8080/request/servletDemo01" target="_blank" rel="noopener noreferrer">http://127.0.0.1:8080/request/servletDemo01</a></li>
<li>详解：http：协议；127.0.0.1：域名；8080：端口；request/servletDemo01：请求资源路径</li>
</ul>
</li>
<li>
<p>URI：统一资源标志符</p>
<ul>
<li>格式：/request/servletDemo01</li>
</ul>
</li>
<li>
<p>区别：<code>URL - HOST = URI</code>，URI 是抽象的定义，URL 用地址定位，URI 用名称定位。<strong>只要能唯一标识资源的是 URI，在 URI 的基础上给出其资源的访问方式的是 URL</strong></p>
</li>
</ul>
<p><strong>从浏览器地址栏输入 URL 到请求返回发生了什么？</strong></p>
<ul>
<li>
<p>进行 URL 解析，进行编码</p>
</li>
<li>
<p>DNS 解析，顺序是先查 hosts 文件是否有记录，有的话就会把相对应映射的 IP 返回，然后去本地 DNS 缓存中寻找，然后依次向本地域名服务器、根域名服务器、顶级域名服务器、权限域名服务器发起查询请求，最终返回 IP 地址给本地域名服务器</p>
<p>本地域名服务器将得到的 IP 地址返回给操作系统，同时将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来</p>
</li>
<li>
<p>查找到 IP 之后，进行 TCP 协议的三次握手建立连接</p>
</li>
<li>
<p>发出 HTTP 请求，取文件指令</p>
</li>
<li>
<p>服务器处理请求，返回响应</p>
</li>
<li>
<p>释放 TCP 连接</p>
</li>
<li>
<p>浏览器解析渲染页面</p>
</li>
</ul>
<p>推荐阅读：<a href="https://xiaolincoding.com/network/" target="_blank" rel="noopener noreferrer">https://xiaolincoding.com/network/</a></p>
<hr>
<h2> 版本区别</h2>
<p>版本介绍：</p>
<ul>
<li>HTTP/0.9 仅支持 GET 请求，不支持请求头</li>
<li>HTTP/1.0 默认短连接（一次请求建议一次 TCP 连接，请求完就断开），支持 GET、POST、 HEAD 请求</li>
<li>HTTP/1.1 默认长连接（一次 TCP 连接可以多次请求）；支持 PUT、DELETE、PATCH 等六种请求；增加 HOST 头，支持虚拟主机；支持<strong>断点续传</strong>功能</li>
<li>HTTP/2.0 多路复用，降低开销（一次 TCP 连接可以处理多个请求）；服务器主动推送（相关资源一个请求全部推送）；解析基于二进制，解析错误少，更高效（HTTP/1.X 解析基于文本）；报头压缩，降低开销</li>
<li>HTTP/3.0 QUIC (Quick UDP Internet Connections)，快速 UDP 互联网连接，基于 UDP 协议</li>
</ul>
<p>HTTP 1.0 和 HTTP 1.1 的主要区别：</p>
<ul>
<li>
<p>长短连接：</p>
<p><strong>在HTTP/1.0中，默认使用的是短连接</strong>，每次请求都要重新建立一次连接，比如获取 HTML 和 CSS 文件，需要两次请求。HTTP 基于 TCP/IP 协议的，每一次建立或者断开连接都需要三次握手四次挥手，开销会比较大</p>
<p><strong>HTTP 1.1起，默认使用长连接</strong> ，默认开启 <code>Connection: keep-alive</code>，Keep-Alive 有一个保持时间，不会永久保持连接。持续连接有非流水线方式和流水线方式 ，流水线方式是客户端在收到 HTTP 的响应报文之前就能接着发送新的请求报文，非流水线方式是客户端在收到前一个响应后才能发送下一个请求</p>
<p>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接</p>
</li>
<li>
<p>错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除</p>
</li>
<li>
<p>缓存处理：在 HTTP1.0 中主要使用 header 里的 If-Modified-Since，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略，例如 Entity tag，If-Unmodified-Since，If-Match，If-None-Match等</p>
</li>
<li>
<p>带宽优化及网络连接的使用：HTTP1.0 存在一些浪费带宽的现象，例如客户端只需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持<strong>断点续传</strong>功能，HTTP1.1 则在请求头引入了 range 头域，允许只<strong>请求资源的某个部分</strong>，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接</p>
</li>
<li>
<p>HOST 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此请求消息中的 URL 并没有传递主机名。HTTP1.1 时代虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且共享一个 IP 地址，故 HTTP1.1 增加了 HOST 信息</p>
</li>
</ul>
<p>HTTP 1.1 和 HTTP 2.0 的主要区别：</p>
<ul>
<li>新的二进制格式：HTTP1.1 基于文本格式传输数据，HTTP2.0 采用二进制格式传输数据，解析更高效</li>
<li><strong>多路复用</strong>：在一个连接里，允许同时发送多个请求或响应，并且这些请求或响应能够并行的传输而不被阻塞，避免 HTTP1.1 出现的队头堵塞问题</li>
<li>头部压缩，HTTP1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP2.0 把 header 从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧。并且 HTTP2.0 在客户端和服务器端记录了之前发送的键值对，对于相同的数据不会重复发送。比如请求 A 发送了所有的头信息字段，请求 B 则只需要发送差异数据，这样可以减少冗余数据，降低开销</li>
<li><strong>服务端推送</strong>：HTTP2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取</li>
</ul>
<hr>
<h2> 安全请求</h2>
<p>HTTP 和 HTTPS 的区别：</p>
<ul>
<li>端口 ：HTTP 默认使用端口 80，HTTPS 默认使用端口 443</li>
<li>安全性：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份；HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密</li>
<li>资源消耗：HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</li>
</ul>
<p><strong>对称加密和非对称加密</strong></p>
<ul>
<li>
<p>对称加密：加密和解密使用同一个秘钥，把密钥转发给需要发送数据的客户机，中途会被拦截（类似于把带锁的箱子和钥匙给别人，对方打开箱子放入数据，上锁后发送），私钥用来解密数据，典型的对称加密算法有 DES、AES 等</p>
<ul>
<li>优点：运算速度快</li>
<li>缺点：无法安全的将密钥传输给通信方</li>
</ul>
</li>
<li>
<p>非对称加密：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥，<strong>公钥公开给任何人</strong>（类似于把锁和箱子给别人，对方打开箱子放入数据，上锁后发送），典型的非对称加密算法有 RSA、DSA 等</p>
<ul>
<li>公钥加密，私钥解密：为了<strong>保证内容传输的安全</strong>，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容</li>
<li>私钥加密，公钥解密：为了<strong>保证消息不会被冒充</strong>，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的</li>
<li>可以更安全地将公开密钥传输给通信发送方，但是运算速度慢</li>
</ul>
</li>
<li>
<p><strong>使用对称加密和非对称加密的方式传送数据</strong></p>
<ul>
<li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性</li>
<li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率</li>
</ul>
<p>思想：锁上加锁</p>
</li>
</ul>
<p>名词解释：</p>
<ul>
<li>
<p>哈希算法：通过哈希函数计算出内容的哈希值，传输到对端后会重新计算内容的哈希，进行哈希比对来校验内容的完整性</p>
</li>
<li>
<p>数字签名：附加在报文上的特殊加密校验码，可以防止报文被篡改。一般是通过私钥对内容的哈希值进行加密，公钥正常解密并对比哈希值后，可以确保该内容就是对端发出的，防止出现中间人替换的问题</p>
</li>
<li>
<p>数字证书：由权威机构给某网站颁发的一种认可凭证</p>
</li>
</ul>
<p>HTTPS 工作流程：服务器端的公钥和私钥，用来进行非对称加密，客户端生成的随机密钥，用来进行对称加密</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP-HTTPS加密过程.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ol>
<li>客户端向服务器发起 HTTPS 请求，连接到服务器的 443 端口，请求携带了浏览器支持的加密算法和哈希算法，协商加密算法</li>
<li>服务器端会向数字证书认证机构注册公开密钥，认证机构<strong>用 CA 私钥</strong>对公开密钥做数字签名后绑定在数字证书（又叫公钥证书，内容有公钥，网站地址，证书颁发机构，失效日期等）</li>
<li>服务器将数字证书发送给客户端，私钥由服务器持有</li>
<li>客户端收到服务器端的数字证书后<strong>通过 CA 公钥</strong>（事先置入浏览器或操作系统）对证书进行检查，验证其合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，将该密钥称之为 client key（客户端密钥、会话密钥）。用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文，HTTPS 中的第一次 HTTP 请求结束</li>
<li>客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端密钥发送给服务器</li>
<li>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文</li>
<li>服务器将加密后的密文发送给客户端</li>
<li>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据，这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成</li>
</ol>
<p>参考文章：<a href="https://www.cnblogs.com/linianhui/p/security-https-workflow.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/linianhui/p/security-https-workflow.html</a></p>
<p>参考文章：<a href="https://www.jianshu.com/p/14cd2c9d2cd2" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/14cd2c9d2cd2</a></p>
<hr>
<h2> 请求部分</h2>
<p>请求行： 永远位于请求的第一行</p>
<p>请求头： 从第二行开始，到第一个空行结束</p>
<p>请求体： 从第一个空行后开始，到正文的结束（GET 没有）</p>
<ul>
<li>
<p>请求方式</p>
<ul>
<li>POST</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP请求部分.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>GET</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>GET 和 POST 比较</strong></p>
<p>作用：GET 用于获取资源，而 POST 用于传输实体主体</p>
<p>参数：GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中（GET 也有请求体，POST 也可以通过 URL 传输参数）。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看</p>
<p>安全：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是安全的，而 POST 不是，因为 POST 的目的是传送实体主体内容</p>
<ul>
<li>安全的方法除了 GET 之外还有：HEAD、OPTIONS</li>
<li>不安全的方法除了 POST 之外还有 PUT、DELETE</li>
</ul>
<p>幂等性：同样的请求<strong>被执行一次与连续执行多次的效果是一样的</strong>，服务器的状态也是一样的，所有的安全方法也都是幂等的。在正确实现条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，POST 方法不是</p>
<p>可缓存：如果要对响应进行缓存，需要满足以下条件</p>
<ul>
<li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存</li>
<li>响应报文的状态码是可缓存的，包括：200、203、204、206、300、301、404、405、410、414 and 501</li>
<li>响应报文的 Cache-Control 首部字段没有指定不进行缓存</li>
</ul>
</li>
<li>
<p>PUT 和 POST 的区别</p>
<p>PUT 请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉（幂等），所以 PUT 用来修改资源</p>
<p>POST 请求：后一个请求不会把第一个请求覆盖掉（非幂等），所以 POST 用来创建资源</p>
<p>PATCH 方法 是新引入的，是对 PUT 方法的补充，用来对已知资源进行<strong>局部更新</strong></p>
</li>
</ul>
</li>
<li>
<p>请求行详解</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET/POST</td>
<td>请求的方式。</td>
</tr>
<tr>
<td>/myApp/success.html</td>
<td>请求的资源。</td>
</tr>
<tr>
<td>HTTP/1.1</td>
<td>使用的协议，及协议的版本。</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>请求头详解</p>
<p>从第 2 行到空行处，都叫请求头，以键值对的形式存在，但存在一个 key 对应多个值的请求头</p>
<table>
<thead>
<tr>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>告知服务器，客户浏览器支持的 MIME 类型</td>
</tr>
<tr>
<td>User-Agent</td>
<td>浏览器相关信息</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>告诉服务器，客户浏览器支持哪种字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>告知服务器，客户浏览器支持的压缩编码格式，常用 gzip 压缩</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>告知服务器，客户浏览器支持的语言，zh_CN 或 en_US 等</td>
</tr>
<tr>
<td>Host</td>
<td>初始 URL 中的主机和端口</td>
</tr>
<tr>
<td>Referer</td>
<td>告知服务器，当前请求的来源。只有当前请求有来源，才有这个消息头。<br>作用：1 投放广告  2 防盗链</td>
</tr>
<tr>
<td>Content-Type</td>
<td>告知服务器，请求正文的 MIME 类型，文件传输的类型，<br>application/x-www-form-urlencoded</td>
</tr>
<tr>
<td>Content-Length</td>
<td>告知服务器，请求正文的长度。</td>
</tr>
<tr>
<td>Connection</td>
<td>表示是否需要持久连接，一般是 <code>Keep -Alive</code>（HTTP 1.1 默认进行持久连接 )</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>告知服务器，客户浏览器缓存文件的最后修改时间</td>
</tr>
<tr>
<td>Cookie</td>
<td>会话管理相关（非常的重要）</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>请求体详解</p>
<ul>
<li>
<p>只有 POST 请求方式，才有请求的正文，GET 方式的正文是在地址栏中的</p>
</li>
<li>
<p>表单的输入域有 name 属性的才会被提交，不分 GET 和 POST 的请求方式</p>
</li>
<li>
<p>表单的 enctype 属性取值决定了请求正文的体现形式</p>
<table>
<thead>
<tr>
<th>enctype取值</th>
<th>请求正文体现形式</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>application/x-www-form-urlencoded</td>
<td>key=value&amp;key=value</td>
<td>username=test&amp;password=1234</td>
</tr>
<tr>
<td>multipart/form-data</td>
<td>此时变成了多部分表单数据。多部分是靠分隔符分隔的。</td>
<td>-----------------------------7df23a16c0210<br>Content-Disposition: form-data; name="username"<br>test<br>-----------------------------7df23a16c0210<br>Content-Disposition: form-data; name="password"<br>1234<br>-------------------------------7df23a16c0210</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
</ul>
<hr>
<h2> 响应部分</h2>
<p>响应部分图：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP响应部分.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>响应行</p>
<p>HTTP/1.1：使用协议的版本</p>
<p>200：响应状态码</p>
<p>OK：状态码描述</p>
<ul>
<li>
<p>响应状态码：<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP状态响应码.png" alt="" loading="lazy"></p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>一切都 OK，与服务器连接成功，发送请求成功</td>
</tr>
<tr>
<td>302/307</td>
<td>请求重定向（客户端行为，两次请求，地址栏发生改变）</td>
</tr>
<tr>
<td>304</td>
<td>请求资源未改变，使用缓存</td>
</tr>
<tr>
<td>400</td>
<td>客户端错误，请求错误，最常见的就是请求参数有问题</td>
</tr>
<tr>
<td>403</td>
<td>客户端错误，但 forbidden 权限不够，拒绝处理</td>
</tr>
<tr>
<td>404</td>
<td>客户端错误，请求资源未找到</td>
</tr>
<tr>
<td>500</td>
<td>服务器错误，服务器运行内部错误</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>转移：</p>
<ul>
<li>301 redirect：301 代表永久性转移 (Permanently Moved)</li>
<li>302 redirect：302 代表暂时性转移 (Temporarily Moved )</li>
</ul>
</li>
<li>
<p>响应头：以 key:vaue 存在，可能多个 value 情况</p>
<table>
<thead>
<tr>
<th>消息头</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Location</td>
<td>请求重定向的地址，常与 302，307 配合使用。</td>
</tr>
<tr>
<td>Server</td>
<td>服务器相关信息</td>
</tr>
<tr>
<td>Content-Type</td>
<td>告知客户浏览器，响应正文的MIME类型</td>
</tr>
<tr>
<td>Content-Length</td>
<td>告知客户浏览器，响应正文的长度</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>告知客户浏览器，响应正文使用的压缩编码格式，常用的 gzip 压缩</td>
</tr>
<tr>
<td>Content-Language</td>
<td>告知客户浏览器，响应正文的语言，zh_CN 或 en_US 等</td>
</tr>
<tr>
<td>Content-Disposition</td>
<td>告知客户浏览器，以下载的方式打开响应正文</td>
</tr>
<tr>
<td>Refresh</td>
<td>客户端的刷新频率，单位是秒</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>服务器资源的最后修改时间</td>
</tr>
<tr>
<td>Set-Cookie</td>
<td>服务器端发送的 Cookie，会话管理相关</td>
</tr>
<tr>
<td>Expires:-1</td>
<td>服务器资源到客户浏览器后的缓存时间</td>
</tr>
<tr>
<td>Catch-Control: no-catch</td>
<td>不要缓存，<a href="//xn--http1-i37hl13cy63grwq.xn--1-856b314a" target="_blank" rel="noopener noreferrer">//针对http协议1.1版本</a></td>
</tr>
<tr>
<td>Pragma:no-catch</td>
<td>不要缓存，<a href="//xn--http1-i37hl13cy63grwq.xn--0-856b314a" target="_blank" rel="noopener noreferrer">//针对http协议1.0版本</a></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>响应体：页面展示内容, 类似网页的源码</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
]]></content:encoded>
      <enclosure url="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP-HTTPS加密过程.png" type="image/png"/>
    </item>
    <item>
      <title>JS</title>
      <link>https://newzone.top/JavaWeb/JS.html</link>
      <guid>https://newzone.top/JavaWeb/JS.html</guid>
      <source url="https://newzone.top/rss.xml">JS</source>
      <description>JS 概述 JavaScript 是一种客户端脚本语言。运行在客户端浏览器中，每一个浏览器都具备解析 JavaScript 的引擎。 脚本语言：不需要编译，就可以被浏览器直接解析执行了。 作用：增强用户和 HTML 页面的交互过程，让页面产生动态效果，增强用户的体验。 组成部分：ECMAScript、DOM、BOM 开发环境搭建：安装Node.js，是JavaScript运行环境 语法 引入 引入HTML文件 内部方式：&amp;lt;script&amp;gt;标签 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;quot;UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;JS快速入门&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;!--html语句--&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script&amp;gt; // JS语句 &amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt; 外部方式 创建js文件：my.js alert(&amp;quot;Hello&amp;quot;);//js语句 在html中引用外部js文件 &amp;lt;body&amp;gt; &amp;lt;!--html语句--&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;script src=&amp;quot;js/my.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;html&amp;gt;</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> JS</h1>
<h2> 概述</h2>
<p>JavaScript 是一种客户端脚本语言。运行在客户端浏览器中，每一个浏览器都具备解析 JavaScript 的引擎。</p>
<p>脚本语言：不需要编译，就可以被浏览器直接解析执行了。</p>
<p>作用：增强用户和 HTML 页面的交互过程，让页面产生动态效果，增强用户的体验。</p>
<p>组成部分：ECMAScript、DOM、BOM</p>
<p>开发环境搭建：安装Node.js，是JavaScript运行环境</p>
<hr>
<h2> 语法</h2>
<h3> 引入</h3>
<p>引入HTML文件</p>
<ul>
<li>
<p>内部方式：&lt;script&gt;标签</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>外部方式</p>
<ul>
<li>
<p>创建js文件：my.js</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>在html中引用外部js文件</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
<hr>
<h3> 注释</h3>
<ul>
<li>
<p>单行注释</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>多行注释</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h3> 输入输出</h3>
<ul>
<li>
<p>输入框：prompt(“提示内容”);</p>
</li>
<li>
<p>弹出警告框：alert(“提示内容”);</p>
</li>
<li>
<p>控制台输出：console.log(“显示内容”);</p>
</li>
<li>
<p>页面内容输出：document.write(“显示内容”);</p>
<p>注：<code>document.write("&lt;br/&gt;")</code>换行，通常输出数据后跟br标签</p>
</li>
</ul>
<hr>
<h3> 变量常量</h3>
<p>JavaScript 属于弱类型的语言，定义变量时不区分具体的数据类型</p>
<ul>
<li>
<p>定义局部变量：let 变量名 = 值;</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>定义全局变量：变量名 = 值;</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>定义常量：const 常量名 = 值;<br>
常量不能被重新赋值</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 数据类型</h3>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td>布尔类型，true或false</td>
</tr>
<tr>
<td>null</td>
<td>声明null值的特殊关键字</td>
</tr>
<tr>
<td>undefined</td>
<td>代表变量未定义</td>
</tr>
<tr>
<td>number</td>
<td>整数或浮点数</td>
</tr>
<tr>
<td>string</td>
<td>字符串</td>
</tr>
<tr>
<td>bigint</td>
<td>大整数，例如：let num = 10n;</td>
</tr>
</tbody>
</table>
<p><strong>typeof 用于判断变量的数据类型</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 运算符</h3>
<ul>
<li>
<p>算术运算符</p>
<table>
<thead>
<tr>
<th>算术运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加法运算</td>
</tr>
<tr>
<td>-</td>
<td>减法运算</td>
</tr>
<tr>
<td>*</td>
<td>乘法运算</td>
</tr>
<tr>
<td>/</td>
<td>除法运算</td>
</tr>
<tr>
<td>%</td>
<td>取余数</td>
</tr>
<tr>
<td>++</td>
<td>自增</td>
</tr>
<tr>
<td>--</td>
<td>自减</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>赋值运算符</p>
<table>
<thead>
<tr>
<th>赋值运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>=</td>
<td>加法运算</td>
</tr>
<tr>
<td>+=</td>
<td>减法运算</td>
</tr>
<tr>
<td>-=</td>
<td>乘法运算</td>
</tr>
<tr>
<td>*=</td>
<td>除法运算</td>
</tr>
<tr>
<td>/=</td>
<td>取余数</td>
</tr>
<tr>
<td>%=</td>
<td>自增</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>比较运算符</p>
<table>
<thead>
<tr>
<th>比较运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>判断值是否相等</td>
</tr>
<tr>
<td>===</td>
<td>判断数据类型和值是否相等</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与，并且的功能</td>
</tr>
<tr>
<td>||</td>
<td>逻辑或，或者的功能</td>
</tr>
<tr>
<td>!</td>
<td>取反</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>三元运算符</strong></p>
<ul>
<li>三元运算符格式：(比较表达式) ? 表达式1 : 表达式2;</li>
<li>格式说明：<br>
如果比较表达式为true，则取表达式1<br>
如果比较表达式为false，则取表达式2</li>
</ul>
</li>
</ul>
<hr>
<h3> 流程控制</h3>
<ul>
<li>
<p><strong>if语句</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>switch语句</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>for循环</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p><strong>while循环</strong></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 数组</h3>
<p>数组的使用和 java 中的数组基本一致，在JavaScript 中的数组更加灵活，数据类型和长度都没有限制</p>
<ul>
<li>
<p>定义格式</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>索引范围：从 0 开始，最大到数组长度-1</p>
</li>
<li>
<p>数组长度：数组名.length</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>数组高级运算符：...</p>
<ul>
<li>
<p>数组赋值</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
<li>
<p>合并数组</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>字符串转数组</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
</li>
</ul>
<hr>
<h3> 函数</h3>
<p>函数类似于 java 中的方法，可以将一些代码进行抽取，达到复用的效果</p>
<ul>
<li>
<p>定义格式：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>调用：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>可变参数：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>匿名函数</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h2> DOM</h2>
<h3> DOM介绍</h3>
<p>DOM(Document Object Model)：文档对象模型。</p>
<p>将 HTML 文档的各个组成部分，封装为对象。借助这些对象，可以对 HTML 文档进行增删改查的动态操作。</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/DOM介绍.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 元素获取</h3>
<p>Element元素的获取操作：document接口方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getElementById(id属性值)</td>
<td>根据id属性值获取元素对象</td>
</tr>
<tr>
<td>getElementsByTagName(标签名称)</td>
<td>根据标签名称获取元素对象，返回数组</td>
</tr>
<tr>
<td>getElementsByClassName(class属性值)</td>
<td>根据class属性值获取元素对象，返回数组</td>
</tr>
<tr>
<td>getElementsByName(name属性值)</td>
<td>根据name属性值获取元素对象，返回数组</td>
</tr>
<tr>
<td>子元素对象.parentElement属性</td>
<td>获取当前元素的父元素</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 元素增删改</h3>
<p>Element元素的增删改操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>createElement(标签名)</td>
<td>创建一个新的标签元素</td>
</tr>
<tr>
<td>appendChild(子元素)</td>
<td>将指定子元素添加到父元素中</td>
</tr>
<tr>
<td>removeChild(子元素)</td>
<td>用父元素删除指定子元素</td>
</tr>
<tr>
<td>replaceChild(新元素, 旧元素)</td>
<td>用新元素替换子元素</td>
</tr>
<tr>
<td>createTextNode(数据)</td>
<td>创建文本元素</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 属性操作</h3>
<p>Attribute属性的操作：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>setAttribute(属性名, 属性值)</td>
<td>设置属性</td>
</tr>
<tr>
<td>getAttribute(属性名)</td>
<td>根据属性名获取属性值</td>
</tr>
<tr>
<td>removeAttribute(属性名)</td>
<td>根据属性名移除指定的属性</td>
</tr>
<tr>
<td>元素名.style属性</td>
<td>为元素添加样式</td>
</tr>
<tr>
<td>元素名.className属性</td>
<td>为元素添加指定样式</td>
</tr>
</tbody>
</table>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 文本操作</h3>
<ul>
<li>
<p>Text文本的操作：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>innerText</td>
<td>元素的文本内容，不解析标签</td>
</tr>
<tr>
<td>innerHTML</td>
<td>元素的文本内容，解析标签</td>
</tr>
</tbody>
</table>
<p>类似于赋值操作，同时支持取用该值</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>输入框文本：input元素.value;</p>
</li>
</ul>
<hr>
<h2> 事件</h2>
<h3> 事件介绍</h3>
<p>事件指的就是当某些组件执行了某些操作后，会触发某些代码的执行</p>
<ul>
<li>
<p>常用的事件：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JS常用的事件.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>更多的事件：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JS更多的事件.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<hr>
<h3> 事件操作</h3>
<p>绑定事件的方式</p>
<ul>
<li>
<p>方式一：通过标签中的事件属性进行绑定</p>
</li>
<li>
<p>方式二：通过 DOM 元素属性绑定</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 综合案例</h3>
<p>案例介绍：</p>
<p>在姓名、年龄、性别三个文本框中填写信息后，添加到“学生信息表”列表（表格），点击删除后，删除该行数据，并且不需刷新</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/事件案例效果.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<ul>
<li>
<p>添加功能分析</p>
<ol>
<li>为添加按钮绑定单击事件</li>
<li>创建 tr 元素</li>
<li>创建 4 个 td 元素</li>
<li>将 td 添加到 tr 中</li>
<li>获取文本框输入的信息</li>
<li>创建 3 个文本元素</li>
<li>将文本元素添加到对应的 td 中</li>
<li>创建 a 元素</li>
<li>将 a 元素添加到对应的 td 中</li>
<li>将 tr 添加到 table 中</li>
</ol>
</li>
<li>
<p>删除功能分析</p>
<ol>
<li>为每个删除超链接添加单击事件属性</li>
<li>定义删除的方法</li>
<li>获取 table 元素</li>
<li>获取 tr 元素</li>
<li>通过 table 删除 tr</li>
</ol>
</li>
<li>
<p>HTML</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>CSS</p>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h2> 对象</h2>
<h3> 类</h3>
<ul>
<li>
<p>定义格式：</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>使用格式</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>字面量类</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 继承</h3>
<ul>
<li>
<p>继承：让类与类产生子父类的关系，子类可以使用父类有权限的成员。</p>
</li>
<li>
<p>继承关键字：extends</p>
</li>
<li>
<p>顶级父类：Object</p>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 内置对象</h3>
<p>内置对象是 JavaScript 提供的带有属性和方法的特殊数据类型，常见的有普通类型、JSON和正则表达式</p>
<hr>
<h3> 普通类型</h3>
<h4> 数字</h4>
<ul>
<li>
<p>Number</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>parseFloat(Sring)</td>
<td>将传入的字符串转为浮点数</td>
</tr>
<tr>
<td>parseInt()</td>
<td>将传入的字符串整数转为整数</td>
</tr>
</tbody>
</table>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Math</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ceil(x)</td>
<td>向上取整</td>
</tr>
<tr>
<td>floor(x)</td>
<td>向下取整</td>
</tr>
<tr>
<td>round(x)</td>
<td>四舍五入为整数</td>
</tr>
<tr>
<td>random()</td>
<td>随机数，返回的是0.0-1.0之间的范围（含头不含尾）</td>
</tr>
<tr>
<td>pow(x,y)</td>
<td>幂运算，x的y次方</td>
</tr>
</tbody>
</table>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 日期</h4>
<ul>
<li>
<p>Date构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date()</td>
<td>根据当前时间创建对象</td>
</tr>
<tr>
<td>Date(value)</td>
<td>根据指定毫秒值创建对象</td>
</tr>
<tr>
<td>Date(year, month, [day, hours, minutes, seconds, milliseconds])</td>
<td>根据指定字段创建对象</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Date成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getFullYear()</td>
<td>获取年份</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获取月份</td>
</tr>
<tr>
<td>getDate()</td>
<td>获取天数，相对于月份</td>
</tr>
<tr>
<td>getHours()</td>
<td>获取小时</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>获取分钟</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>获取秒数</td>
</tr>
<tr>
<td>getTime()</td>
<td>返回据1970年1月1日至今的毫秒数</td>
</tr>
<tr>
<td>toLocaleString()</td>
<td>返回本地日期格式的字符串<br>2021/2/3下午8:20:20</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h4> 字符串</h4>
<p>String</p>
<ul>
<li>
<p>构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>gengenString(vale)</td>
<td>根据指定字符串创建对象</td>
</tr>
<tr>
<td>let s = "字符串"</td>
<td>直接赋值</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>length</td>
<td>获取字符串长度</td>
</tr>
<tr>
<td>charAt(index)</td>
<td>获取指定索引处的字符</td>
</tr>
<tr>
<td>indexOf(value)</td>
<td>获取指定字符串出现的索引位置，找不到为-1</td>
</tr>
<tr>
<td>substring(start, end)</td>
<td>根据指定索引范围截取字符串（含头不含尾）</td>
</tr>
<tr>
<td>split(value)</td>
<td>根据指定规则切割字符串，返回数组</td>
</tr>
<tr>
<td>replace(old, new)</td>
<td>使用新字符替换老字符串</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h4> 数组集合</h4>
<ul>
<li>
<p>Array</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>push(value)</td>
<td>添加元素到数组的末尾</td>
</tr>
<tr>
<td>pop()</td>
<td>删除数组末尾的元素</td>
</tr>
<tr>
<td>shift()</td>
<td>删除数组最前面的元素</td>
</tr>
<tr>
<td>includes(value)</td>
<td>判断数组是否包含给定的值</td>
</tr>
<tr>
<td>reverse()</td>
<td>反转数组中的元素</td>
</tr>
<tr>
<td>sort()</td>
<td>对数组元素进行升序排序</td>
</tr>
<tr>
<td>length</td>
<td>返回数组的长度</td>
</tr>
</tbody>
</table>
<p><strong>降序排序：先sort，再reverse</strong></p>
</li>
<li>
<p>Set：JavaScript中的Set集合，元素唯一，存取顺序一致</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set()</td>
<td>创建Set集合对象</td>
</tr>
<tr>
<td>add(value)</td>
<td>向集合中添加元素</td>
</tr>
<tr>
<td>size</td>
<td>获取集合长度</td>
</tr>
<tr>
<td>keys()</td>
<td>获取迭代器对象（遍历方法看实例）</td>
</tr>
<tr>
<td>delete(value)</td>
<td>删除指定元素</td>
</tr>
</tbody>
</table>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Map：JavaScript 中的 Map 集合，key 唯一，存取顺序一致</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Map()</td>
<td>创建Map集合对象</td>
</tr>
<tr>
<td>set(key, value)</td>
<td>向集合添加元素</td>
</tr>
<tr>
<td>size</td>
<td>获取集合长度</td>
</tr>
<tr>
<td>get(key)</td>
<td>根据key获取value</td>
</tr>
<tr>
<td>entries()</td>
<td>获取迭代器对象</td>
</tr>
<tr>
<td>delete(key)</td>
<td>根据key删除键值对</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h3> JSON</h3>
<h4> JSON入门</h4>
<p>JSON(JavaScript Object Notation)：是一种轻量级的数据交换格式。</p>
<ul>
<li>基于 ECMAScript 规范的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据</li>
<li>简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言，易于人阅读和编写，同时也易于计算机解析和 生成，并有效的提升网络传输效率。</li>
</ul>
<ul>
<li>
<p>创建格式：<br>
<strong>name是字符串类型</strong><br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JSON创建格式.png" alt="" loading="lazy"></p>
</li>
<li>
<p>json常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>stringify(对象)</td>
<td>将指定对象转换为json格式字符串</td>
</tr>
<tr>
<td>parse(字符串)</td>
<td>将指定json格式字符串解析成对象</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>入门案例</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 转换工具</h4>
<p>我们除了可以在 JavaScript 中来使用 JSON 以外，在 JAVA 中同样也可以使用 JSON。</p>
<p>JSON 的转换工具是通过 JAVA 封装好的一些 JAR 工具包，可以将 JAVA 对象或集合转换成 JSON 格式的字符串，也可以将 JSON 格式的字符串转成 JAVA 对象。</p>
<p>Jackson：开源免费的 JSON 转换工具，SpringMVC 转换默认使用 Jackson。</p>
<ul>
<li>
<p>常用类</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ObjectMapper</td>
<td>是Jackson工具包的核心类，提供方法来实现JSON字符串和对象之间的转换</td>
</tr>
<tr>
<td>TypeReference</td>
<td>对集合泛型的反序列化，使用TypeReference可以明确的指定反序列化的对象类型</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>ObjectMapper常用方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String writeValueAsString(Object obj)</td>
<td>将Java对象转换成JSON字符串</td>
</tr>
<tr>
<td>&lt;T&gt; T readValue(String json, Class&lt;T&gt; valueType)</td>
<td>将JSON字符串转换成Java对象</td>
</tr>
<tr>
<td>&lt;T&gt; T readValue(String json, TypeReference valueTypeRef)</td>
<td>将JSON字符串转换成Java对象</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>方法练习：</p>
<ul>
<li>
<p>对象转 JSON，JSON 转对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Map转 JSON，JSON 转 Map</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Map转 JSON，JSON 转 Map&lt;自定义类&gt;</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>List</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 正则</h3>
<h4> 正则表达式</h4>
<p>正则表达式：是一种对字符串进行匹配的规则</p>
<p>RegExp：</p>
<ul>
<li>
<p>构造方法</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>RegExp(规则)</td>
<td>根据指定规则创建对象</td>
</tr>
<tr>
<td>let reg = /^规则$/</td>
<td>直接赋值</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>成员方法</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>test(匹配的字符串)</td>
<td>根据指定规则验证字符串是否符合</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h4> 验证用户</h4>
<p>使用 onsubmit 表单提交事件</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/表单校验.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> BOM</h2>
<h3> BOM介绍</h3>
<p>BOM(Browser Object Model)：浏览器对象模型。</p>
<p>将浏览器的各个组成部分封装成不同的对象，方便我们进行操作。</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/BOM介绍.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> Window</h3>
<p>Windows窗口对象：</p>
<ul>
<li><strong>定时器</strong>
<ul>
<li>唯一标识 setTimeout(功能，毫秒值)：设置一次性定时器。</li>
<li>clearTimeout(标识)：取消一次性定时器。</li>
<li>唯一标识 setInterval(功能，毫秒值)：设置循环定时器。</li>
<li>clearInterval(标识)：取消循环定时器。</li>
</ul>
</li>
<li>加载事件
<ul>
<li>window.onload：在页面加载完毕后触发此事件的功能</li>
</ul>
</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> Location</h3>
<p>Location地址栏对象：</p>
<ul>
<li>href 属性：浏览器的地址栏。我们可以通过为该属性设置新的URL，使浏览器读取并显示新URL的内容</li>
</ul>
<p>实现效果：秒数会自动变小，倒计时，5，4，3，2，1</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h2> 封装</h2>
<p>封装思想：</p>
<ul>
<li>
<p>**封装：**将复杂的操作进行封装隐藏，对外提供更加简单的操作。</p>
</li>
<li>
<p><strong>获取元素的方法</strong></p>
<ul>
<li>document.getElementById(id值)：根据 id 值获取元素</li>
<li>document.getElementsByName(name值)：根据 name 属性值获取元素们</li>
<li>document.getElementsByTagName(标签名)：根据标签名获取元素们</li>
</ul>
</li>
</ul>
<p>代码实现：</p>
<ul>
<li>
<p>my.js</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>封装.html</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h2> JQuery</h2>
<h3> 简介</h3>
<p>jQuery 是一个 JavaScript 库</p>
<ul>
<li>所谓的库，就是一个 JS 文件，里面封装了很多预定义的函数，比如获取元素，执行隐藏、移动等，目的就是在使用时直接调用，不需要再重复定义，这样就可以极大地简化了 JavaScript 编程。</li>
<li>jQuery 官网：<a href="https://www.jquery.com" target="_blank" rel="noopener noreferrer">https://www.jquery.com</a></li>
</ul>
<p>引入jQ文件</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>jQuery 的核心语法 $()</li>
</ul>
<hr>
<h3> 语法</h3>
<h4> 对象转换</h4>
<p>jQuery 本质上虽然也是 JS，但二者的 API 方法不能混合使用，若想使用对方的 API，需要进行对象的转换</p>
<ul>
<li>
<p>JS 的 DOM 对象转换成 jQuery 对象：$(JS的DOM对象);</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>jQuery 对象转换成 JS 对象</p>
<ul>
<li>jQuery对象[索引];</li>
<li>jQuery对象.get(索引);</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 事件操作</h4>
<h5> 绑定解绑</h5>
<p>在 jQuery 中将事件封装成了对应的方法。去掉了 JS 中的 .on 语法</p>
<ul>
<li>
<p>绑定事件：<code>jQuery对象.on(事件名称,执行的功能);</code></p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>解绑事件：<code>jQuery对象.off(事件名称);</code><br>
如果不指定事件名称，则会把该对象绑定的所有事件都解绑</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<h5> 事件切换</h5>
<p>事件切换：需要给同一个对象绑定多个事件，而且多个事件还有先后顺序关系</p>
<ul>
<li>
<p>方式一：单独定义</p>
<ul>
<li>$(元素).事件方法名1(要执行的功能);</li>
<li>$(元素).事件方法名2(要执行的功能);</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>方式二：链式定义</p>
<ul>
<li>$(元素).事件方法名1(要执行的功能) .事件方法名2(要执行的功能);</li>
</ul>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 遍历操作</h4>
<ul>
<li>
<p>数据准备，实现按键后遍历无序列表</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>for循环</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>对象.each方法</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>$.each()方法</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>for of语句</p>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 选择器</h3>
<h4> 基本选择器</h4>
<p>选择器：类似于 CSS 的选择器，可以帮助我们获取元素。</p>
<ul>
<li>下面所有的A B均为标签名</li>
</ul>
<table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>元素选择器</td>
<td>$("元素的名称")</td>
<td>根据元素名称获取元素对象（数组）</td>
</tr>
<tr>
<td>id选择器</td>
<td>$("#id的属性值")</td>
<td>根据id属性值获取元素对象</td>
</tr>
<tr>
<td>类选择器</td>
<td>$(".class的属性值")</td>
<td>根据class属性值获取元素对象（数组）</td>
</tr>
</tbody>
</table>
<h4> 层级选择器</h4>
<table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>后代选择器</td>
<td>$("A B")</td>
<td>A下的所有B，包括B的子级</td>
</tr>
<tr>
<td>子选择器</td>
<td>$("A &gt; B")</td>
<td>A下的所有B，不 包括B的子级</td>
</tr>
<tr>
<td>兄弟选择器</td>
<td>$("A + B")</td>
<td>A相邻的下一个B</td>
</tr>
<tr>
<td>兄弟选择器</td>
<td>$("A ~ B")</td>
<td>A相邻的所有B</td>
</tr>
</tbody>
</table>
<h4> 属性选择器</h4>
<table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>属性名选择器</td>
<td>$("A[属性名]")</td>
<td>根据指定属性名获取元素对象（数组）</td>
</tr>
<tr>
<td>属性值选择器</td>
<td>$("A[属性名=属性值]")</td>
<td>根据指定属性名和属性值获取元素对象（数组）</td>
</tr>
</tbody>
</table>
<hr>
<h4> 过滤器选择器</h4>
<table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>首元素选择器</td>
<td>$("A:first")</td>
<td>获取选择的元素中的第一个元素</td>
</tr>
<tr>
<td>尾元素选择器</td>
<td>$("A:last")</td>
<td>获取选择的元素中的最后一个元素</td>
</tr>
<tr>
<td>非元素选择器</td>
<td>$("A:not(B)")</td>
<td>不包括指定内容的元素</td>
</tr>
<tr>
<td>偶数选择器</td>
<td>$("A:even")</td>
<td>偶数，从0开始计数</td>
</tr>
<tr>
<td>奇数选择器</td>
<td>$("A:odd")</td>
<td>奇数，从0开始计数</td>
</tr>
<tr>
<td>等于索引选择器</td>
<td>$("A:eq(index)")</td>
<td>指定索引的元素</td>
</tr>
<tr>
<td>大于索引选择器</td>
<td>$("A:gt(index)")</td>
<td>大于指定索引的元素</td>
</tr>
<tr>
<td>小于索引选择器</td>
<td>$("A:lt(index)")</td>
<td>小于指定索引的元素</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 表单属性选择器</h4>
<table>
<thead>
<tr>
<th>选择器</th>
<th>语法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>可用选择器</td>
<td>$("A:enabled")</td>
<td>获得可用元素</td>
</tr>
<tr>
<td>不可用元素选择器</td>
<td>$("A:disabled")</td>
<td>获得不可用元素</td>
</tr>
<tr>
<td>单选/复选框被选中的元素</td>
<td>$("A:checked")</td>
<td>获取单选/复选框被选中的元素</td>
</tr>
<tr>
<td>下拉框被选中的元素</td>
<td>$("A:selected")</td>
<td>获取下拉框被选中的元素</td>
</tr>
</tbody>
</table>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> DOM</h3>
<h4> 文本操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>html()</td>
<td>获取标签的文本</td>
</tr>
<tr>
<td>html(value)</td>
<td>设置标签的文本内容，解析标签</td>
</tr>
</tbody>
</table>
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 对象操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>$("元素")</td>
<td>创建指定元素</td>
</tr>
<tr>
<td>append(element)</td>
<td>添加成最后一个子元素，由添加者对象调用</td>
</tr>
<tr>
<td>appendTo(element)</td>
<td>添加成最后一个子元素，由被添加者对象调用</td>
</tr>
<tr>
<td>prepend(element)</td>
<td>添加成第一个子元素，由添加者对象调用</td>
</tr>
<tr>
<td>prependTo(element)</td>
<td>添加成第一个子元素，由被添加者对象调用</td>
</tr>
<tr>
<td>before(element)</td>
<td>添加到当前元素的前面，两者之间是兄弟关系，由添加者对象调用</td>
</tr>
<tr>
<td>after(element)</td>
<td>添加到当前元素的后面，两者之间是兄弟关系，由添加者对象调用</td>
</tr>
<tr>
<td>remove()</td>
<td>删除指定元素（自己移除自己）</td>
</tr>
<tr>
<td>empty()</td>
<td>清空指定元素的所有子元素（自己还在）</td>
</tr>
</tbody>
</table>
<div id="div"></div>
<ul id="city">
    <li id="bj">北京</li>
    <li id="sh">上海</li>
</ul>
<ul id="desc">
    <li id="jy">加油</li>
</ul> 
<div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 样式操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>css(name)</td>
<td>根据样式名称获取css样式</td>
</tr>
<tr>
<td>css(name,value)</td>
<td>设置css样式</td>
</tr>
<tr>
<td>addClass(value)</td>
<td>给指定的对象添加样式类名</td>
</tr>
<tr>
<td>removeClass(value)</td>
<td>给指定的对象删除样式类名</td>
</tr>
<tr>
<td>toggleClass(value)</td>
<td>没有样式类名就添加，有就删除，循环如此</td>
</tr>
</tbody>
</table>
<div class="language-css line-numbers-mode" data-ext="css"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-ext="js"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 属性操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>attr(name,[value])</td>
<td>获得/设置属性的值</td>
</tr>
<tr>
<td>prop(name,[value])</td>
<td>获得/设置属性的值（checked, selected）</td>
</tr>
</tbody>
</table>



    <meta charset="UTF-8">
    <title>操作属性</title>


    <input type="text" id="username"> <br>
    <input type="button" id="btn1" value="获取输入框的id属性">  &nbsp;&nbsp;
    <input type="button" id="btn2" value="给输入框设置value属性"><br>
    <input type="radio" id="gender1" name="gender">男
	<input type="radio" id="gender2" name="gender">女<br>
	<input type="button" id="btn3" value="选中女"><br><br>
    <select>
    <option>---请选择---</option>
    <option id="bk">本科</option>
    <option id="zk">专科</option>
	</select><br>
    <input type="button" id="btn4" value="选中本科">


<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
]]></content:encoded>
      <enclosure url="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/DOM介绍.png" type="image/png"/>
    </item>
    <item>
      <title>Nginx</title>
      <link>https://newzone.top/JavaWeb/Nginx.html</link>
      <guid>https://newzone.top/JavaWeb/Nginx.html</guid>
      <source url="https://newzone.top/rss.xml">Nginx</source>
      <description>Nginx 安装软件 Nginx 是一个高性能的 HTTP 和反向代理 Web 服务器，同时也提供了 IMAP/POP3/SMTP 服务 Nginx 两个最核心的功能：高性能的静态 Web 服务器，反向代理 安装指令：sudo apt-get install nginx 查看版本：nginx -v 系统指令：systemctl / service start/restart/stop/status nginx</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Nginx</h1>
<h2> 安装软件</h2>
<p>Nginx 是一个高性能的 HTTP 和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488" target="_blank" rel="noopener noreferrer">反向代理 </a>Web 服务器，同时也提供了 IMAP/POP3/SMTP 服务</p>
<p>Nginx 两个最核心的功能：高性能的静态 Web 服务器，反向代理</p>
<ul>
<li>
<p>安装指令：sudo apt-get install nginx</p>
</li>
<li>
<p>查看版本：nginx -v</p>
</li>
<li>
<p>系统指令：systemctl / service  start/restart/stop/status nginx</p>
</li>
</ul>
<p>配置文件安装目录：/etc/nginx</p>
<p>日志文件：/var/log/nginx</p>
<hr>
<h2> 配置文件</h2>
<p>nginx.conf 文件时 Nginx 的主配置文件</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Nginx配置文件conf.jpg" style="zoom:80%;">
<ul>
<li>
<p>main 部分<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Nginx配置文件main部分.jpg" style="zoom: 67%;"></p>
</li>
<li>
<p>events 部分<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Nginx配置文件events部分.jpg" style="zoom:67%;"></p>
</li>
<li>
<p>server 部分<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Nginx配置文件server部分.jpg" style="zoom:67%;"></p>
<p>root 设置的路径会拼接上 location 的路径，然后去最终路径寻找对应的文件</p>
</li>
</ul>
<hr>
<h2> 发布项目</h2>
<ol>
<li>
<p>创建一个 toutiao 目录</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>将项目上传到 toutiao 目录</p>
</li>
<li>
<p>解压项目 unzip web.zip</p>
</li>
<li>
<p>编辑 Nginx 配置文件 nginx.conf</p>
<div class="language-bash line-numbers-mode" data-ext="sh"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>重启 Nginx 服务：systemctl  restart nginx</p>
</li>
<li>
<p>浏览器打开网址：<a href="http://127.0.0.1:80" target="_blank" rel="noopener noreferrer">http://127.0.0.1:80</a></p>
</li>
</ol>
<hr>
<h2> 反向代理</h2>
<blockquote>
<p>无法访问 Google，可以配置一个代理服务器，发送请求到代理服务器，代理服务器经过转发，再将请求转发给 Google，返回结果之后，再次转发给用户，这个叫做正向代理，正向代理对于用户来说，是有感知的</p>
</blockquote>
<p><strong>正向代理（forward proxy）</strong>：是一个位于客户端和目标服务器之间的代理服务器，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端，<strong>正向代理，其实是"代理服务器"代理了当前"客户端"，去和"目标服务器"进行交互</strong></p>
<p>作用：</p>
<ul>
<li>突破访问限制：通过代理服务器，可以突破自身 IP 访问限制，访问国外网站，教育网等</li>
<li>提高访问速度：代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度</li>
<li>隐藏客户端真实 IP：隐藏自己的 IP，免受攻击</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/正向代理.png" style="zoom:50%;">
<p><strong>反向代理（reverse proxy）</strong>：是指以代理服务器来接受 Internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 Internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器，<strong>反向代理，其实是"代理服务器"代理了"目标服务器"，去和当前"客户端"进行交互</strong></p>
<p>作用：</p>
<ul>
<li>隐藏服务器真实 IP：使用反向代理，可以对客户端隐藏服务器的 IP 地址</li>
<li>负载均衡：根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上</li>
<li>提高访问速度：反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务</li>
<li>提供安全保障：反向代理服务器可以作为应用层防火墙，为网站提供对基于 Web 的攻击行为（例如 DoS/DDoS）的防护，更容易排查恶意软件等</li>
</ul>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/反向代理.png" style="zoom:50%;">
<p>区别：</p>
<ul>
<li>
<p>正向代理其实是客户端的代理，帮助客户端访问其无法访问的服务器资源；反向代理则是服务器的代理，帮助服务器做负载均衡，安全防护等</p>
</li>
<li>
<p>正向代理一般是客户端架设的，比如在自己的机器上安装一个代理软件；反向代理一般是服务器架设的，比如在自己的机器集群中部署一个反向代理服务器</p>
</li>
<li>
<p>正向代理中，服务器不知道真正的客户端到底是谁，以为访问自己的就是真实的客户端；反向代理中，客户端不知道真正的服务器是谁，以为自己访问的就是真实的服务器</p>
</li>
<li>
<p>正向代理和反向代理的作用和目的不同。正向代理主要是用来解决访问限制问题；而反向代理则是提供负载均衡、安全防护等作用；二者均能提高访问速度</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Servlet</title>
      <link>https://newzone.top/JavaWeb/Servlet.html</link>
      <guid>https://newzone.top/JavaWeb/Servlet.html</guid>
      <source url="https://newzone.top/rss.xml">Servlet</source>
      <description>Servlet JavaEE JavaEE规范 JavaEE 规范是 J2EE 规范的新名称，早期被称为 J2EE 规范，其全称是 Java 2 Platform Enterprise Edition，它是由 SUN 公司领导、各厂家共同制定并得到广泛认可的工业标准（JCP组织成员）。之所以改名为JavaEE，目的还是让大家清楚 J2EE 只是 Java 企业应用。在 2004 年底中国软件技术大会 Ioc 微容器（也就是 Jdon 框架的实现原理）演讲中指出：我们需要一个跨 J2SE/WEB/EJB 的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖 J2SE/J2EE 版本。此次 J2EE 改名为 Java EE，实际也反映出业界这种共同心声</description>
      <pubDate>Wed, 16 Aug 2023 07:46:55 GMT</pubDate>
      <content:encoded><![CDATA[<h1> Servlet</h1>
<h2> JavaEE</h2>
<h3> JavaEE规范</h3>
<p><code>JavaEE</code> 规范是 <code>J2EE</code> 规范的新名称，早期被称为 <code>J2EE</code> 规范，其全称是 <code>Java 2 Platform Enterprise Edition</code>，它是由 SUN 公司领导、各厂家共同制定并得到广泛认可的工业标准（<code>JCP</code>组织成员）。之所以改名为<code>JavaEE</code>，目的还是让大家清楚 <code>J2EE</code> 只是 <code>Java</code> 企业应用。在 2004 年底中国软件技术大会 <code>Ioc</code> 微容器（也就是 <code>Jdon</code> 框架的实现原理）演讲中指出：我们需要一个跨 <code>J2SE/WEB/EJB</code> 的微容器，保护我们的业务核心组件，以延续它的生命力，而不是依赖 <code>J2SE/J2EE</code> 版本。此次 <code>J2EE</code> 改名为 <code>Java EE</code>，实际也反映出业界这种共同心声</p>
<p><code>JavaEE</code> 规范是很多 Java 开发技术的总称。这些技术规范都是沿用自 <code>J2EE</code> 的。一共包括了 13 个技术规范，例如：<code>jsp/servlet</code>，<code>jndi</code>，<code>jaxp</code>，<code>jdbc</code>，<code>jni</code>，<code>jaxb</code>，<code>jmf</code>，<code>jta</code>，<code>jpa</code>，<code>EJB</code>等。</p>
<p>其中，<code>JCP</code> 组织的全称是 Java Community Process，是一个开放的国际组织，主要由 Java 开发者以及被授权者组成，职能是发展和更新。成立于 1998 年。官网是：<a href="https://jcp.org/en/home/index" target="_blank" rel="noopener noreferrer">JCP</a></p>
<p><code>JavaEE</code> 的版本是延续了 <code>J2EE</code> 的版本，但是没有继续采用其命名规则。<code>J2EE</code> 的版本从 1.0 开始到 1.4 结束，而 <code>JavaEE</code> 版本是从 <code>JavaEE 5</code> 版本开始，目前最新的的版本是 <code>JavaEE 8</code></p>
<p>详情请参考：<a href="https://www.oracle.com/technetwork/cn/java/javaee/overview/index.html" target="_blank" rel="noopener noreferrer">JavaEE8 规范概览</a></p>
<hr>
<h3> Web 概述</h3>
<p>Web，在计算机领域指网络。像我们接触的 <code>WWW</code>，它是由 3 个单词组成的，即：<code>World Wide Web </code>，中文含义是<b>万维网</b>。而我们前面学的 HTML 的参考文档《W3School 全套教程》中的 <code>W3C</code> 就是万维网联盟，他们的出现都是为了让我们在网络的世界中获取资源，这些资源的存放之处，我们称之为网站。我们通过输入网站的地址（网址），就可以访问网站中提供的资源。在网上我们能访问到的内容全是资源（不区分局域网还是广域网），只不过不同类型的资源展示的效果不一样</p>
<p>资源分为静态资源和动态资源</p>
<ul>
<li>
<p>静态资源指的是，网站中提供给人们展示的资源是一成不变的，也就是说不同人或者在不同时间，看到的内容都是一样的。例如：我们看到的新闻，网站的使用手册，网站功能说明文档等等。而作为开发者，我们编写的 <code>html</code>、<code>css</code>、<code>js</code> 图片，多媒体等等都可以称为静态资源</p>
</li>
<li>
<p>动态资源它指的是，网站中提供给人们展示的资源是由程序产生的，在不同的时间或者用不同的人员由于身份的不同，所看到的内容是不一样的。例如：我们在CSDN上下载资料，只有登录成功后，且积分足够时才能下载。否则就不能下载，这就是访客身份和会员身份的区别。作为开发人员，我们编写的 <code>JSP</code>，<code>servlet</code>，<code>php</code>，<code>ASP</code> 等都是动态资源。</p>
</li>
</ul>
<p>关于广域网和局域网的划分</p>
<ul>
<li>广域网指的就是万维网，也就是我们说的互联网。</li>
<li>局域网是指的是在一定范围之内可以访问的网络，出了这个范围，就不能再使用的网络。</li>
</ul>
<hr>
<h3> 系统结构</h3>
<p>基础结构划分：C/S结构，B/S结构两类。</p>
<p>技术选型划分：Model1模型，Model2模型，MVC模型和三层架构+MVC模型。</p>
<p>部署方式划分：一体化架构，垂直拆分架构，分布式架构，流动计算架构，微服务架构。</p>
<ul>
<li>
<p>C/S结构：客户端—服务器的方式。其中C代表Client，S代表服务器。C/S结构的系统设计图如下：<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JavaEE-CS结构图.jpg" style="zoom:67%;"></p>
</li>
<li>
<p>B/S结构是浏览器—服务器的方式。B代表Browser，S代表服务器。B/S结构的系统设计图如下：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JavaEE-BS结构图.jpg" style="zoom:67%;">
</li>
<li>
<p>两种结构的区别及优劣</p>
<ul>
<li>
<p>区别：</p>
<ul>
<li>第一：硬件环境不同，C/S通常是建立在专用的网络或小范围的网络环境上（即局域网），且必须要安装客户端。而B/S是建立在广域网上的，适应范围强，通常有操作系统和浏览器就行。</li>
<li>第二：C/S结构比B/S结构更安全，因为用户群相对固定，对信息的保护更强。</li>
<li>第三：B/S结构维护升级比较简单，而C/S结构维护升级相对困难。</li>
</ul>
</li>
<li>
<p>优劣</p>
<ul>
<li>C/S：能充分发挥客户端PC的处理能力，很多工作可以在客户端处理后再提交给服务器。对应的优点就是客户端响应速度快。</li>
<li>B/S：总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软件就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能使用。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>我们的课程中涉及的系统结构都是是基于B/S结构</p>
</li>
</ul>
<hr>
<h2> Tomcat</h2>
<h3> 服务器</h3>
<p>服务器的概念非常的广泛，它可以指代一台特殊的计算机（相比普通计算机运行更快、负载更高、价格更贵），也可以指代用于部署网站的应用。我们这里说的服务器，其实是web服务器，或者应用服务器。它本质就是一个软件，一个应用。作用就是发布我们的应用（工程），让用户可以通过浏览器访问我们的应用。</p>
<p>常见的应用服务器，请看下表：</p>
<table>
<thead>
<tr>
<th>服务器名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>weblogic</td>
<td>实现了 JavaEE 规范，重量级服务器，又称为 JavaEE 容器</td>
</tr>
<tr>
<td>websphereAS</td>
<td>实现了 JavaEE 规范，重量级服务器。</td>
</tr>
<tr>
<td>JBOSSAS</td>
<td>实现了 JavaEE 规范，重量级服务器，免费</td>
</tr>
<tr>
<td>Tomcat</td>
<td>实现了 jsp/servlet 规范，是一个轻量级服务器，开源免费</td>
</tr>
</tbody>
</table>
<hr>
<h3> 基本介绍</h3>
<h4> Windows安装</h4>
<p>下载地址：<a href="http://tomcat.apache.org/" target="_blank" rel="noopener noreferrer">http://tomcat.apache.org/</a></p>
<p>目录结构详解：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat目录结构详解.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> Linux安装</h4>
<p>解压apache-tomcat-8.5.32.tar.gz。</p>
<p>防火墙设置</p>
<ul>
<li>
<p>方式1：service iptables stop  关闭防火墙(不建议); 用到哪一个端口号就放行哪一个(80,8080,3306...)</p>
</li>
<li>
<p>方式2：放行8080 端口</p>
<ul>
<li>修改配置文件<code>cd /etc/sysconfig</code>--&gt;<code>vi iptables</code><br>
<code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 8080 -j ACCEPT</code></li>
<li>重启加载防火墙或者重启防火墙<br>
<code>service iptables reload</code> 或者<code>service iptables restart</code></li>
</ul>
</li>
</ul>
<hr>
<h4> 启动停止</h4>
<p>Tomcat服务器的启动文件在二进制文件目录bin中：startup.bat，<a href="http://startup.sh" target="_blank" rel="noopener noreferrer">startup.sh</a></p>
<p>Tomcat服务器的停止文件也在二进制文件目录bin中：shutdown.bat，<a href="http://shutdown.sh" target="_blank" rel="noopener noreferrer">shutdown.sh</a>  （推荐直接关闭控制台）</p>
<p>其中<code>.bat</code>文件是针对windows系统的运行程序，<code>.sh</code>文件是针对linux系统的运行程序。</p>
<hr>
<h4> 常见问题</h4>
<ul>
<li>
<p>启动一闪而过</p>
<p>没有配置环境变量，配置上 JAVA_HOME 环境变量。</p>
</li>
<li>
<p>Tomcat 启动后控制台输出乱码</p>
<p>打开 <code>/conf/logging.properties</code>，设置 gbk <code>java.util.logging.ConsoleHandler.encoding = gbk</code></p>
</li>
<li>
<p>Address already in use : JVM_Bind：端口被占用，找到占用该端口的应用</p>
<ul>
<li>
<p>进程不重要：使用cmd命令：netstat -a -o 查看 pid  在任务管理器中结束占用端口的进程</p>
</li>
<li>
<p>进程很重要：修改自己的端口号。修改的是 Tomcat 目录下<code>\conf\server.xml</code>中的配置。</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-server.xml端口配置.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
</li>
</ul>
<hr>
<h4> IDEA集成</h4>
<p>Run -&gt; Edit Configurations -&gt; Templates -&gt; Tomcat Server -&gt; Local</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-IDEA配置Tomcat.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 发布应用</h3>
<h4> 虚拟目录</h4>
<p>在 <code>server.xml</code> 的 <code>&lt;Host&gt;</code> 元素中加一个 <code>&lt;Context path="" docBase=""/&gt;</code> 元素</p>
<ul>
<li><code>path</code>：访问资源URI，URI名称可以随便起，但是必须在前面加上一个/</li>
<li><code>docBase</code>：资源所在的磁盘物理地址</li>
</ul>
<hr>
<h4> 虚拟主机</h4>
<p>在<code>&lt;Engine&gt;</code>元素中添加一个<code>&lt;Host name="" appBase="" unparkWARs="" autoDeploy="" /&gt;</code>，其中：</p>
<ul>
<li><code>name</code>：指定主机的名称</li>
<li><code>appBase</code>：当前主机的应用发布目录</li>
<li><code>unparkWARs</code>：启动时是否自动解压war包</li>
<li><code>autoDeploy</code>：是否自动发布</li>
</ul>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> IDEA部署</h4>
<ul>
<li>
<p>新建工程<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-IEDA新建工程.png" style="zoom:67%;"></p>
</li>
<li>
<p>发布工程<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-IDEA发布工程.png" alt="" loading="lazy"></p>
</li>
<li>
<p>Run</p>
</li>
</ul>
<hr>
<h4> IDEA发布</h4>
<p>把资源移动到 Tomcat 工程下 web 目录中，两种访问方式</p>
<ul>
<li>
<p>直接访问：<a href="http://localhost:8080/Tomcat/login/login.html" target="_blank" rel="noopener noreferrer">http://localhost:8080/Tomcat/login/login.html</a></p>
</li>
<li>
<p>在 web.xml 中配置默认主页</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 执行原理</h3>
<h4> 整体架构</h4>
<p>Tomcat 核心组件架构图如下所示：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat-核心组件架构图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>组件介绍：</p>
<ul>
<li>GlobalNamingResources：实现 JNDI，指定一些资源的配置信息</li>
<li>Server：Tomcat 是一个 Servlet 容器，一个 Tomcat 对应一个 Server，一个 Server 可以包含多个 Service</li>
<li>Service：核心服务是 Catalina，用来对请求进行处理，一个 Service 包含多个 Connector 和一个 Container</li>
<li>Connector：连接器，负责处理客户端请求，解析不同协议及 I/O 方式</li>
<li>Executor：线程池</li>
<li>Container：容易包含 Engine，Host，Context，Wrapper 等组件</li>
<li>Engine：服务交给引擎处理请求，Container 容器中顶层的容器对象，一个 Engine 可以包含多个 Host 主机</li>
<li>Host：Engine 容器的子容器，一个 Host 对应一个网络域名，一个 Host 包含多个 Context</li>
<li>Context：Host 容器的子容器，表示一个 Web 应用</li>
<li>Wrapper：Tomcat 中的最小容器单元，表示 Web 应用中的 Servlet</li>
</ul>
<p>核心类库：</p>
<ul>
<li>Coyote：Tomcat 连接器的名称，封装了底层的网络通信，为 Catalina 容器提供了统一的接口，使容器与具体的协议以及 I/O 解耦</li>
<li>EndPoint：Coyote 通信端点，即通信监听的接口，是 Socket 接收和发送处理器，是对传输层的抽象，用来实现 TCP/IP 协议</li>
<li>Processor ： Coyote 协议处理接口，用来实现 HTTP 协议，Processor 接收来自 EndPoint 的 Socket，读取字节流解析成 Tomcat 的 Request 和 Response 对象，并通过 Adapter 将其提交到容器处理，Processor 是对应用层协议的抽象</li>
<li>CoyoteAdapter：适配器，连接器调用 CoyoteAdapter 的 sevice 方法，传入的是 TomcatRequest 对象，CoyoteAdapter 负责将TomcatRequest 转成 ServletRequest，再调用容器的 service 方法</li>
</ul>
<p>参考文章：<a href="https://www.jianshu.com/p/7c9401b85704" target="_blank" rel="noopener noreferrer">https://www.jianshu.com/p/7c9401b85704</a></p>
<p>参考文章：<a href="https://www.yuque.com/yinhuidong/yu877c/ktq82e" target="_blank" rel="noopener noreferrer">https://www.yuque.com/yinhuidong/yu877c/ktq82e</a></p>
<hr>
<h4> 启动过程</h4>
<p>Tomcat 的启动入口是 Bootstrap#main 函数，首先通过调用 <code>bootstrap.init()</code> 初始化相关组件：</p>
<ul>
<li><code>initClassLoaders()</code>：初始化三个类加载器，commonLoader 的父类加载器是启动类加载器</li>
<li><code>Thread.currentThread().setContextClassLoader(catalinaLoader)</code>：自定义类加载器加载 Catalina 类，<strong>打破双亲委派</strong></li>
<li><code>Object startupInstance = startupClass.getConstructor().newInstance()</code>：反射创建 Catalina 对象</li>
<li><code>method.invoke(startupInstance, paramValues)</code>：反射调用方法，设置父类加载器是 sharedLoader</li>
<li><code>catalinaDaemon = startupInstance</code>：引用 Catalina 对象</li>
</ul>
<p><code>daemon.load(args)</code> 方法反射调用 Catalina 对象的 load 方法，对<strong>服务器的组件进行初始化</strong>，并绑定了 ServerSocket 的端口：</p>
<ul>
<li>
<p><code>parseServerXml(true)</code>：解析 XML 配置文件</p>
</li>
<li>
<p><code>getServer().init()</code>：服务器执行初始化，采用责任链的执行方式</p>
<ul>
<li>
<p><code>LifecycleBase.init()</code>：生命周期接口的初始化方法，开始链式调用</p>
</li>
<li>
<p><code>StandardServer.initInternal()</code>：Server 的初始化，遍历所有的 Service 进行初始化</p>
</li>
<li>
<p><code>StandardService.initInternal()</code>：Service 的初始化，对 Engine、Executor、listener、Connector 进行初始化</p>
</li>
<li>
<p><code>StandardEngine.initInternal()</code>：Engine 的初始化</p>
<ul>
<li><code>getRealm()</code>：创建一个 Realm 对象</li>
<li><code>ContainerBase.initInternal()</code>：容器的初始化，设置处理容器内组件的启动和停止事件的线程池</li>
</ul>
</li>
<li>
<p><code>Connector.initInternal()</code>：Connector 的初始化</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p><code>adapter = new CoyoteAdapter(this)</code>：实例化 CoyoteAdapter 对象</p>
</li>
<li>
<p><code>protocolHandler.setAdapter(adapter)</code>：设置到 ProtocolHandler 协议处理器中</p>
</li>
<li>
<p><code>ProtocolHandler.init()</code>：协议处理器的初始化，底层调用 <code>AbstractProtocol#init</code> 方法</p>
<p><code>endpoint.init()</code>：端口的初始化，底层调用 <code>AbstractEndpoint#init</code> 方法</p>
<p><code>NioEndpoint.bind()</code>：绑定方法</p>
<ul>
<li><code>initServerSocket()</code>：<strong>初始化 ServerSocket</strong>，以 NIO 的方式监听端口
<ul>
<li><code>serverSock = ServerSocketChannel.open()</code>：<strong>NIO 的方式打开通道</strong></li>
<li><code>serverSock.bind(addr, getAcceptCount())</code>：通道绑定连接端口</li>
<li><code>serverSock.configureBlocking(true)</code>：切换为阻塞模式（没懂，为什么阻塞）</li>
</ul>
</li>
<li><code>initialiseSsl()</code>：初始化 SSL 连接</li>
<li><code>selectorPool.open(getName())</code>：打开选择器，类似 NIO 的多路复用器</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>初始化完所有的组件，调用 <code>daemon.start()</code> 进行<strong>组件的启动</strong>，底层反射调用 Catalina 对象的 start 方法：</p>
<ul>
<li>
<p><code>getServer().start()</code>：启动组件，也是责任链的模式</p>
<ul>
<li>
<p><code>LifecycleBase.start()</code>：生命周期接口的初始化方法，开始链式调用</p>
</li>
<li>
<p><code>StandardServer.startInternal()</code>：Server 服务的启动</p>
<ul>
<li><code>globalNamingResources.start()</code>：启动 JNDI 服务</li>
<li><code>for (Service service : services)</code>：遍历所有的 Service 进行启动</li>
</ul>
</li>
<li>
<p><code>StandardService.startInternal()</code>：Service 的启动，对所有 Executor、listener、Connector 进行启</p>
</li>
<li>
<p><code>StandardEngine.startInternal()</code>：启动引擎，部署项目</p>
<ul>
<li><code>ContainerBase.startInternal()</code>：容器的启动
<ul>
<li>启动集群、Realm 组件，并且创建子容器，提交给线程池</li>
<li><code>((Lifecycle) pipeline).start()</code>：遍历所有的管道进行启动
<ul>
<li><code>Valve current = first</code>：获取第一个阀门</li>
<li><code>((Lifecycle) current).start()</code>：启动阀门，底层 <code>ValveBase#startInternal</code> 中设置启动的状态</li>
<li><code>current = current.getNext()</code>：获取下一个阀门</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>Connector.startInternal()</code>：Connector 的初始化</p>
<ul>
<li>
<p><code>protocolHandler.start()</code>：协议处理器的启动</p>
<p><code>endpoint.start()</code>：端点启动</p>
<p><code>NioEndpoint.startInternal()</code>：启动 NIO 的端点</p>
<ul>
<li><code>createExecutor()</code>：创建 Worker 线程组，10 个线程，用来进行任务处理</li>
<li><code>initializeConnectionLatch()</code>：用来进行连接限流，<strong>最大 8*1024 条连接</strong></li>
<li><code>poller = new Poller()</code>：<strong>创建 Poller 对象</strong>，开启了一个多路复用器 Selector</li>
<li><code>Thread pollerThread = new Thread(poller, getName() + "-ClientPoller")</code>：创建并启动 Poller 线程，Poller 实现了 Runnable 接口，是一个任务对象，<strong>线程 start 后进入 Poller#run 方法</strong></li>
<li><code>pollerThread.setDaemon(true)</code>：设置为守护线程</li>
<li><code>startAcceptorThread()</code>：启动接收者线程
<ul>
<li><code>acceptor = new Acceptor&lt;&gt;(this)</code>：<strong>创建 Acceptor 对象</strong></li>
<li><code>Thread t = new Thread(acceptor, threadName)</code>：创建并启动 Acceptor 接受者线程</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4> 处理过程</h4>
<ol>
<li>Acceptor 监听客户端套接字，每 50ms 调用一次 <strong><code>serverSocket.accept</code></strong>，获取 Socket 后把封装成 NioSocketWrapper（是 SocketWrapperBase 的子类），并设置为非阻塞模式，把 NioSocketWrapper 封装成 PollerEvent 放入同步队列中</li>
<li>Poller 循环判断同步队列中是否有就绪的事件，如果有则通过 <code>selector.selectedKeys()</code> 获取就绪事件，获取 SocketChannel 中携带的 attachment（NioSocketWrapper），在 processKey 方法中根据事件类型进行 processSocket，将 Wrapper 对象封装成 SocketProcessor 对象，该对象是一个任务对象，提交到 Worker 线程池进行执行</li>
<li><code>SocketProcessorBase.run()</code> 加锁调用 <code>SocketProcessor#doRun</code>，保证线程安全，从协议处理器 ProtocolHandler 中获取 AbstractProtocol，然后<strong>创建 Http11Processor 对象处理请求</strong></li>
<li><code>Http11Processor#service</code> 中调用 <code>CoyoteAdapter#service</code> ，把生成的 Tomcat 下的 Request 和 Response 对象通过方法 postParseRequest 匹配到对应的 Servlet 的请求响应，将请求传递到对应的 Engine 容器中调用 Pipeline，管道中包含若干个 Valve，执行完所有的 Valve 最后执行 StandardEngineValve，继续调用 Host 容器的 Pipeline，执行 Host 的 Valve，再传递给 Context 的 Pipeline，最后传递到 Wrapper 容器</li>
<li><code>StandardWrapperValve#invoke</code> 中创建了 Servlet 对象并执行初始化，并为当前请求准备一个 FilterChain 过滤器链执行 doFilter 方法，<code>ApplicationFilterChain#doFilter</code> 是一个<strong>责任链的驱动方法</strong>，通过调用 internalDoFilter 来获取过滤器链的下一个过滤器执行 doFilter，执行完所有的过滤器后执行 <code>servlet.service</code> 的方法</li>
<li>最后调用 HttpServlet#service()，根据请求的方法来调用 doGet、doPost 等，执行到自定义的业务方法</li>
</ol>
<hr>
<h2> Servlet</h2>
<h3> Socket</h3>
<p>Socket 是使用 TCP/IP 或者 UDP 协议在服务器与客户端之间进行传输的技术，是网络编程的基础</p>
<ul>
<li><strong>Servlet 是使用 HTTP 协议在服务器与客户端之间通信的技术，是 Socket 的一种应用</strong></li>
<li><strong>HTTP 协议：是在 TCP/IP 协议之上进一步封装的一层协议，关注数据传输的格式是否规范，底层的数据传输还是运用了 Socket 和 TCP/IP</strong></li>
</ul>
<p>Tomcat 和 Servlet 的关系：Servlet 的运行环境叫做 Web 容器或 Servlet 服务器，<strong>Tomcat 是 Web 应用服务器，是一个 Servlet/JSP 容器</strong>。Tomcat 作为 Servlet 容器，负责处理客户请求，把请求传送给 Servlet，并将 Servlet 的响应传送回给客户。而 Servlet 是一种运行在支持 Java 语言的服务器上的组件，Servlet 用来扩展 Java Web 服务器功能，提供非常安全的、可移植的、易于使用的 CGI 替代品<br>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat与Servlet的关系.png" alt="" loading="lazy"></p>
<hr>
<h3> 基本介绍</h3>
<h4> Servlet类</h4>
<p>Servlet是SUN公司提供的一套规范，名称就叫Servlet规范，它也是JavaEE规范之一。通过API来使用Servlet。</p>
<ol>
<li>
<p>Servlet是一个运行在web服务端的java小程序，用于接收和响应客户端的请求。一个服务器包含多个Servlet</p>
</li>
<li>
<p>通过实现Servlet接口，继承GenericServlet或者HttpServlet，实现Servlet功能</p>
</li>
<li>
<p>每次请求都会执行service方法，在service方法中还有参数ServletRequest和ServletResponse</p>
</li>
<li>
<p>支持配置相关功能</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet类关系总视图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ol>
<hr>
<h4> 执行流程</h4>
<p>创建 Web 工程 → 编写普通类继承 Servlet 相关类 → 重写方法</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet入门案例执行.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<p>Servlet执行过程分析：</p>
<p>通过浏览器发送请求，请求首先到达Tomcat服务器，由服务器解析请求URL，然后在部署的应用列表中找到应用。然后找到web.xml配置文件，在web.xml中找到FirstServlet的配置（<code>&lt;url-pattern&gt;/&lt;url-pattern&gt;</code>），找到后执行service方法，最后由FirstServlet响应客户浏览器。整个过程如下图所示：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet执行过程图.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 实现方式</h4>
<p>实现 Servlet 功能时，可以选择以下三种方式：</p>
<ul>
<li>
<p>第一种：实现 Servlet 接口，接口中的方法必须全部实现。<br>
使用此种方式，表示接口中的所有方法在需求方面都有重写的必要。此种方式支持最大程度的自定义。</p>
</li>
<li>
<p>第二种：继承 GenericServlet，service 方法必须重写，其他方可根据需求，选择性重写。<br>
使用此种方式，表示只在接收和响应客户端请求这方面有重写的需求，而其他方法可根据实际需求选择性重写，使我们的开发Servlet变得简单。但是，此种方式是和 HTTP 协议无关的。</p>
</li>
<li>
<p>第三种：继承 HttpServlet，它是 javax.servlet.http 包下的一个抽象类，是 GenericServlet 的子类。选择继承 HttpServlet 时，<strong>需要重写 doGet 和 doPost 方法</strong>，来接收 get 方式和 post 方式的请求，不要覆盖 service 方法。使用此种方式，表示我们的请求和响应需要和 HTTP 协议相关，我们是通过 HTTP 协议来访问。每次请求和响应都符合 HTTP 协议的规范。请求的方式就是 HTTP 协议所支持的方式（GET POST PUT DELETE TRACE OPTIONS HEAD )。</p>
</li>
</ul>
<hr>
<h3> 相关问题</h3>
<h4> 异步处理</h4>
<p>Servlet 3.0 中的异步处理指的是允许Servlet重新发起一条新线程去调用 耗时业务方法，这样就可以避免等待</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet3.0的异步处理.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 生命周期</h4>
<p>servlet从创建到销毁的过程：</p>
<ul>
<li>
<p>出生：（初始化）请求第一次到达 Servlet 时，创建对象，并且初始化成功。Only one time</p>
</li>
<li>
<p>活着：（服务）服务器提供服务的整个过程中，该对象一直存在，每次只是执行 service 方法</p>
</li>
<li>
<p>死亡：（销毁）当服务停止时，或者服务器宕机时，对象删除，</p>
</li>
</ul>
<p>serrvlet生命周期方法:<br>
<code>init(ServletConfig config)</code> → <code>service(ServletRequest req, ServletResponse res)</code> → <code>destroy()</code></p>
<p>默认情况下, 有了第一次请求, 会调用 init() 方法进行初始化【调用一次】，任何一次请求，都会调用 service() 方法处理这个请求，服务器正常关闭或者项目从服务器移除, 调用 destory() 方法进行销毁【调用一次】</p>
<p><strong>扩展</strong>：servlet 是单例多线程的，尽量不要在 servlet 里面使用全局(成员)变量，可能会导致线程不安全</p>
<ul>
<li>单例：Servlet 对象只会创建一次，销毁一次，Servlet 对象只有一个实例。</li>
<li>多线程：服务器会针对每次请求, 开启一个线程调用 service() 方法处理这个请求</li>
</ul>
<hr>
<h4> 线程安全</h4>
<p>Servlet运用了单例模式，整个应用中只有一个实例对象，所以需要分析这个唯一的实例中的类成员是否线程安全</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>启动两个浏览器，输入不同的参数(<a href="http://localhost:8080/ServletDemo/username=aaa" target="_blank" rel="noopener noreferrer">http://localhost:8080/ServletDemo/username=aaa</a> 或者bbb)，访问之后发现输出的结果都是一样，所以出现线程安全问题。</p>
<p>在Servlet中定义了类成员之后，多个浏览器都会共享类成员的数据，其中任何一个线程修改了数据，都会影响其他线程。因此，我们可以认为Servlet它不是线程安全的。因为Servlet是单例，单例对象的类成员只会随类实例化时初始化一次，之后的操作都是改变，而不会重新初始化。</p>
<p>解决办法：如果类成员是共用的，只在初始化时赋值，其余时间都是获取。或者加锁synchronized</p>
<hr>
<h4> 映射方式</h4>
<p>Servlet支持三种映射方式，三种映射方式的优先级为：第一种&gt;第二种&gt;第三种。</p>
<ol>
<li>
<p>具体名称方式<br>
这种方式，只有和映射配置一模一样时，Servlet才会接收和响应来自客户端的请求。<br>
访问URL：<a href="http://localhost:8080/servlet/servletDemo" target="_blank" rel="noopener noreferrer">http://localhost:8080/servlet/servletDemo</a></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>/开头+通配符的方式<br>
这种方式，只要符合目录结构即可，不用考虑结尾是什么<br>
访问URL：<a href="http://localhost:8080/servlet/" target="_blank" rel="noopener noreferrer">http://localhost:8080/servlet/</a> + 任何字符</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>通配符+固定格式结尾<br>
这种方式，只要符合固定结尾格式即可，其前面的访问URI无须关心（注意协议，主机和端口必须正确）<br>
访问URL：<a href="http://localhost:8080/%E4%BB%BB%E4%BD%95%E5%AD%97%E7%AC%A6%E4%BB%BB%E4%BD%95%E7%9B%AE%E5%BD%95" target="_blank" rel="noopener noreferrer">http://localhost:8080/任何字符任何目录</a> + .do (<a href="http://localhost:8080/seazean/i.do" target="_blank" rel="noopener noreferrer">http://localhost:8080/seazean/i.do</a>)</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ol>
<hr>
<h4> 多路径映射</h4>
<p>一个Servlet的多种路径配置的支持。给一个Servlet配置多个访问映射，从而根据不同请求的URL实现不同的功能</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就可以根据不同的网页显示不同的数据。</p>
<hr>
<h4> 启动时创建</h4>
<ul>
<li>第一种：应用加载时创建Servlet，它的优势是在服务器启动时，就把需要的对象都创建完成了，从而在使用的时候减少了创建对象的时间，提高了首次执行的效率。它的弊端是在应用加载时就创建了Servlet对象，因此，导致内存中充斥着大量用不上的Servlet对象，造成了内存的浪费。</li>
<li>第二种：请求第一次访问是创建Servlet，它的优势就是减少了对服务器内存的浪费，因为一直没有被访问过的Servlet对象都没有创建，因此也提高了服务器的启动时间。而它的弊端就是要在应用加载时就做的初始化操作，它都没法完成，从而要考虑其他技术实现。</li>
</ul>
<p>在web.xml中是支持对Servlet的创建时机进行配置的，配置的方式如下：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4> 默认Servlet</h4>
<p>默认 Servlet 是由服务器提供的一个 Servlet，它配置在 Tomcat 的 conf 目录下的 web.xml 中。</p>
<p>它的映射路径是<code>&lt;url-pattern&gt;/&lt;url-pattern&gt;</code>，我们在发送请求时，首先会在我们应用中的 web.xml 中查找映射配置。但是当找不到对应的 Servlet 路径时，就去找默认的 Servlet，由默认 Servlet 处理。</p>
<hr>
<h3> ServletConfig</h3>
<p>ServletConfig 是 Servlet 的配置参数对象。在 Servlet 规范中，允许为每个 Servlet 都提供一些初始化配置，每个 Servlet 都有自己的ServletConfig，作用是<strong>在 Servlet 初始化期间，把一些配置信息传递给 Servlet</strong></p>
<p>生命周期：在初始化阶段读取了 web.xml 中为 Servlet 准备的初始化配置，并把配置信息传递给 Servlet，所以生命周期与 Servlet 相同。如果 Servlet 配置了 <code>&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</code>，ServletConfig 也会在应用加载时创建。</p>
<p>获取 ServletConfig：在 init 方法中为 ServletConfig 赋值</p>
<p>常用API：</p>
<ul>
<li><code>String getInitParameter(String name)</code>：根据初始化参数的名称获取参数的值，根据<code>&lt;param-name&gt;</code>，获取<code>&lt;param-value&gt;</code></li>
<li><code>Enumeration&lt;String&gt; getInitParameterNames()</code> : 获取所有初始化参数名称的枚举(遍历方式看例子)</li>
<li><code>ServletContext getServletContext()</code> : 获取<strong>ServletContext</strong>对象</li>
<li><code>String getServletName()</code> : 获取Servlet名称</li>
</ul>
<p>代码实现：</p>
<ul>
<li>
<p>web.xml 配置：<br>
初始化参数使用 <code>&lt;servlet&gt;</code> 标签中的 <code>&lt;init-param&gt; </code>标签来配置，并且每个 Servlet 都支持有多个初始化参数，并且初始化参数都是以键值对的形式存在的</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>效果：</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/ServletConfig演示.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<hr>
<h3> ServletContext</h3>
<p>ServletContext 对象是应用上下文对象。服务器为每一个应用都创建了一个 ServletContext 对象，ServletContext 属于整个应用，不局限于某个 Servlet，可以实现让应用中所有 Servlet 间的数据共享。</p>
<p>上下文代表了程序当下所运行的环境，联系整个应用的生命周期与资源调用，是程序可以访问到的所有资源的总和，资源可以是一个变量，也可以是一个对象的引用</p>
<p>生命周期：</p>
<ul>
<li>出生：应用一加载，该对象就被创建出来。一个应用只有一个实例对象（Servlet 和 ServletContext 都是单例的）</li>
<li>活着：只要应用一直提供服务，该对象就一直存在。</li>
<li>死亡：应用被卸载（或者服务器停止），该对象消亡。</li>
</ul>
<p>域对象：指的是对象有作用域，即有作用范围，可以<strong>实现数据共享</strong>，不同作用范围的域对象，共享数据的能力不一样。</p>
<p>Servlet 规范中，共有4个域对象，ServletContext 是其中一个，web 应用中最大的作用域，叫 application 域，可以实现整个应用间的数据共享功能。</p>
<p>数据共享：</p>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/ServletContext共享数据.png" style="zoom:50%;">
<p>获取ServletContext：</p>
<ul>
<li>
<p>Java 项目继承 HttpServlet，HttpServlet 继承 GenericServlet，GenericServlet 中有一个方法可以直接使用</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>ServletRequest 类方法：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li>
</ul>
<p>常用API：</p>
<ul>
<li><code>String getInitParameter(String name)</code> : 根据名称获取全局配置的参数</li>
<li><code>String getContextPath</code> : 获取当前应用访问的虚拟目录</li>
<li><code>String getRealPath(String path)</code> : 根据虚拟目录获取应用部署的磁盘绝对路径</li>
<li><code>void setAttribute(String name, Object object)</code> : 向应用域对象中存储数据</li>
<li><code>Object getAttribute(String name)</code> : 根据名称获取域对象中的数据，没有则返回null</li>
<li><code>void removeAttribute(String name)</code> : 根据名称移除应用域对象中的数据</li>
</ul>
<p>代码实现：</p>
<ul>
<li>
<p>web.xml配置：<br>
配置的方式，需要在<code>&lt;web-app&gt;</code>标签中使用<code>&lt;context-param&gt;</code>来配置初始化参数，它的配置是针对整个应用的配置，被称为应用的初始化参数配置。</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 注解开发</h3>
<p>Servlet3.0 版本！不需要配置 web.xml</p>
<ul>
<li>
<p>注解案例</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>WebServlet注解（@since Servlet 3.0 (Section 8.1.1)）</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>手动创建容器：（了解）</p>
</li>
</ul>
<hr>
<h2> Request</h2>
<h3> 请求响应</h3>
<p>Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Servlet请求响应图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 请求对象</h3>
<p>请求：客户机希望从服务器端索取一些资源，向服务器发出询问</p>
<p>请求对象：在 JavaEE 工程中，用于发送请求的对象，常用的对象是 ServletRequest 和 HttpServletRequest ，它们的区是是否与 HTTP 协议有关</p>
<p>Request 作用：</p>
<ul>
<li>操作请求三部分(行,头,体)</li>
<li>请求转发</li>
<li>作为域对象存数据</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Request请求对象的类视图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 请求路径</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>String  getLocalAddr()</td>
<td>获取本机（服务器）地址</td>
</tr>
<tr>
<td>String getLocalName()</td>
<td>获取本机（服务器）名称</td>
</tr>
<tr>
<td>int getLocalPort()</td>
<td>获取本机（服务器）端口</td>
</tr>
<tr>
<td>String getRemoteAddr()</td>
<td>获取访问者IP</td>
</tr>
<tr>
<td>String getRemoteHost</td>
<td>获取访问者主机</td>
</tr>
<tr>
<td>int getRemotePort()</td>
<td>获取访问者端口</td>
</tr>
<tr>
<td>String getMethod();</td>
<td>获得请求方式</td>
</tr>
<tr>
<td>String getRequestURI()</td>
<td>获取统一资源标识符（/request/servletDemo01）</td>
</tr>
<tr>
<td>String getRequestURL()</td>
<td>获取统一资源定位符（<a href="http://localhost:8080/request/servletDemo01%EF%BC%89" target="_blank" rel="noopener noreferrer">http://localhost:8080/request/servletDemo01）</a></td>
</tr>
<tr>
<td>String getQueryString()</td>
<td>获取请求消息的数据<br>（GET方式 URL中带参字符串：username=aaa&amp;password=123）</td>
</tr>
<tr>
<td>String getContextPath()</td>
<td>获取虚拟目录名称（/request）</td>
</tr>
<tr>
<td>String getServletPath</td>
<td>获取Servlet映射路径<br>（<code>&lt;url-pattern&gt;</code>或@WebServlet值: /servletDemo01）</td>
</tr>
<tr>
<td>String getRealPath(String path)</td>
<td>根据虚拟目录获取应用部署的磁盘绝对路径</td>
</tr>
</tbody>
</table>
<p>URL = URI + HOST</p>
<p>URL = HOST + ContextPath + ServletPath</p>
<hr>
<h3> 获取请求头</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>String  getHeader(String name)</td>
<td>获得指定请求头的值。<br>如果没有该请求头返回null，有多个值返回第一个</td>
</tr>
<tr>
<td>Enumeration&lt;String&gt; getHeaders(String name)</td>
<td>获取指定请求头的多个值</td>
</tr>
<tr>
<td>Enumeration&lt;String&gt; getHeaderNames()</td>
<td>获取所有请求头名称的枚举</td>
</tr>
</tbody>
</table>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 请求参数</h3>
<h4> 请求参数</h4>
<p>请求参数是正文部分&lt;input&gt;标签内容，&lt;form&gt;标签属性action="/request/servletDemo08"，服务器URI</p>
<table>
<thead>
<tr>
<th>法名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getParameter(String name)</td>
<td>获得指定参数名的值<br>如果没有该参数则返回null，如果有多个获得第一个</td>
</tr>
<tr>
<td>String[] getParameterValues(String name)</td>
<td>获得指定参数名所有的值。此方法为复选框提供的</td>
</tr>
<tr>
<td>Enumeration&lt;String&gt; getParameterNames()</td>
<td>获得所有参数名</td>
</tr>
<tr>
<td>Map&lt;String,String[]&gt; getParameterMap()</td>
<td>获得所有的请求参数键值对（key=value）</td>
</tr>
</tbody>
</table>
<hr>
<h4> 封装参数</h4>
<p>封装请求参数到类对象：</p>
<ul>
<li>
<p>直接封装：有参构造或者set方法</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>反射方式：</p>
<p>表单<code>&lt;input&gt;</code>标签的name属性取值，必须和实体类中定义的属性名称一致</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>commons-beanutils封装</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 流获取数据</h4>
<p><code>ServletInputStream getInputStream()</code> : 获取请求字节输入流对象<br>
<code>BufferedReader getReader()  </code> : 获取请求缓冲字符输入流对象</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 请求域</h3>
<h4> 请求域</h4>
<p>request 域：可以在一次请求范围内进行共享数据</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void setAttribute(String name, Object value)</td>
<td>向请求域对象中存储数据</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>通过名称获取请求域对象的数据</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>通过名称移除请求域对象的数据</td>
</tr>
</tbody>
</table>
<hr>
<h4> 请求转发</h4>
<p>请求转发：客户端的一次请求到达后，需要借助其他 Servlet 来实现功能，进行请求转发。特点：</p>
<ul>
<li>浏览器地址栏不变</li>
<li>域对象中的数据不丢失</li>
<li>负责转发的 Servlet 转发前后响应正文会丢失</li>
<li>由转发目的地来响应客户端</li>
</ul>
<p>HttpServletRequest 类方法：</p>
<ul>
<li><code>RequestDispatcher getRequestDispatcher(String path) </code> : 获取任务调度对象</li>
</ul>
<p>RequestDispatcher 类方法：</p>
<ul>
<li><code>void forward(ServletRequest request, ServletResponse response)</code> : 实现转发，将请求从 Servlet 转发到服务器上的另一个资源（Servlet，JSP 文件或 HTML 文件）</li>
</ul>
<p>过程：浏览器访问 <a href="http://localhost:8080/request/servletDemo09%EF%BC%8C/servletDemo10%E4%B9%9F%E4%BC%9A%E6%89%A7%E8%A1%8C" target="_blank" rel="noopener noreferrer">http://localhost:8080/request/servletDemo09，/servletDemo10也会执行</a></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 请求包含</h4>
<p>请求包含：合并其他的 Servlet 中的功能一起响应给客户端。特点：</p>
<ul>
<li>浏览器地址栏不变</li>
<li>域对象中的数据不丢失</li>
<li>被包含的 Servlet 响应头会丢失</li>
</ul>
<p>请求转发的注意事项：负责转发的 Servlet，转发前后的响应正文丢失，由转发目的地来响应浏览器</p>
<p>请求包含的注意事项：被包含者的响应消息头丢失，因为它被包含者包含起来了</p>
<p>HttpServletRequest 类方法：</p>
<ul>
<li><code>RequestDispatcher getRequestDispatcher(String path) </code> : 获取任务调度对象</li>
</ul>
<p>RequestDispatcher 类方法：</p>
<ul>
<li><code>void include(ServletRequest request, ServletResponse response) </code> : 实现包含。包括响应中资源的内容（servlet，JSP页面，HTML文件）。</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 乱码问题</h3>
<p>请求体</p>
<ul>
<li>
<p>POST：<code>void setCharacterEncoding(String env)</code>：设置请求体的编码</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>GET：Tomcat8.5 版本及以后，Tomcat 服务器已经帮我们解决</p>
</li>
</ul>
<hr>
<h2> Response</h2>
<h3> 响应对象</h3>
<p>响应，服务器把请求的处理结果告知客户端</p>
<p>响应对象：在 JavaEE 工程中，用于发送响应的对象</p>
<ul>
<li>协议无关的对象标准是：ServletResponse 接口</li>
<li>协议相关的对象标准是：HttpServletResponse 接口</li>
</ul>
<p>Response 的作用：</p>
<ul>
<li>操作响应的三部分(行, 头, 体)</li>
</ul>
<ul>
<li>请求重定向</li>
</ul>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Response响应类视图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 操作响应行</h3>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>int getStatus()</td>
<td>Gets the current status code of this response</td>
</tr>
<tr>
<td>void setStatus(int sc)</td>
<td>Sets the status code for this response</td>
</tr>
</tbody>
</table>
<p>状态码：（HTTP--&gt;相应部分）</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态码</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1xx</td>
<td style="text-align:center">消息</td>
</tr>
<tr>
<td style="text-align:center">2xx</td>
<td style="text-align:center">成功</td>
</tr>
<tr>
<td style="text-align:center">3xx</td>
<td style="text-align:center">重定向</td>
</tr>
<tr>
<td style="text-align:center">4xx</td>
<td style="text-align:center">客户端错误</td>
</tr>
<tr>
<td style="text-align:center">5xx</td>
<td style="text-align:center">服务器错误</td>
</tr>
</tbody>
</table>
<hr>
<h3> 操作响应体</h3>
<h4> 字节流响应</h4>
<p>响应体对应<strong>乱码问题</strong></p>
<p>项目中常用的编码格式是UTF-8，而浏览器默认使用的编码是gbk。导致乱码！</p>
<p>解决方式：<br>
一：修改浏览器的编码格式(不推荐，不能让用户做修改的动作)<br>
二：通过输出流写出一个标签：&lt;meta http-equiv='content-type'content='text/html;charset=UTF-8'&gt;<br>
三：指定响应头信息：response.setHeader("Content-Type","text/html;charset=UTF-8")<br>
四：response.setContentType("text/html;charset=UTF-8")</p>
<p>常用API：<br>
<code>ServletOutputStream getOutputStream()</code> : 获取响应字节输出流对象<br>
<code>void setContenType("text/html;charset=UTF-8")</code> : 设置响应内容类型，解决中文乱码问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 字符流响应</h4>
<p>response得到的字符流和字节流互斥，只能选其一，response获取的流不用关闭，由服务器关闭即可。</p>
<p>常用API：<br>
<code>PrintWriter getWriter()</code> : 获取响应字节输出流对象，可以发送标签<br>
<code>void setContenType("text/html;charset=UTF-8")</code> : 设置响应内容类型，解决中文乱码问题</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 响应图片</h4>
<p>响应图片到浏览器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> 操作响应头</h3>
<h4> 常用方法</h4>
<p>响应头: 是服务器指示浏览器去做什么</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getHeader(String name)</td>
<td>获取指定响应头的内容</td>
</tr>
<tr>
<td>Collection&lt;String&gt; getHeaders(String name)</td>
<td>获取指定响应头的多个值</td>
</tr>
<tr>
<td>Collection&lt;String&gt; getHeaderNames()</td>
<td>获取所有响应头名称的枚举</td>
</tr>
<tr>
<td>void setHeader(String name, String value)</td>
<td>设置响应头</td>
</tr>
<tr>
<td>void setDateHeader(String name, long date)</td>
<td>设置具有给定名称和日期值的响应消息头</td>
</tr>
<tr>
<td>void sendRedirect(String location)</td>
<td>设置重定向</td>
</tr>
</tbody>
</table>
<p>setHeader常用响应头：</p>
<ul>
<li>Expires：设置缓存时间</li>
<li>Refresh：定时跳转</li>
<li>Location：重定向地址</li>
<li>Content-Disposition: 告诉浏览器下载</li>
<li>Content-Type：设置响应内容的MIME类型(服务器告诉浏览器内容的类型)</li>
</ul>
<hr>
<h4> 控制缓存</h4>
<p>缓存：对于不经常变化的数据，我们可以设置合理的缓存时间，防止浏览器频繁的请求服务器。</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Response设置缓存时间.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 定时刷新</h4>
<p>定时刷新：过了指定时间后，页面进行自动跳转</p>
<p>格式：<code>setHeader("Refresh", "3;URL=https://www.baidu.com"");</code><br>
Refresh设置的时间单位是秒，如果刷新到其他地址，需要在时间后面拼接上地址</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 下载文件</h4>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 重定向</h4>
<h5> 实现重定向</h5>
<p>请求重定向：客户端的一次请求到达后，需要借助其他 Servlet 来实现功能。特点：</p>
<ol>
<li>重定向两次请求</li>
<li>重定向的地址栏路径改变</li>
<li><strong>重定向的路径写绝对路径</strong>（带域名 /ip 地址，如果是同一个项目，可以省略域名 /ip 地址）</li>
<li>重定向的路径可以是项目内部的,也可以是项目以外的（百度）</li>
<li>重定向不能重定向到 WEB-INF 下的资源</li>
<li>把数据存到 request 域里面，重定向不可用</li>
</ol>
<p>实现方式：</p>
<ul>
<li>
<p>方式一：</p>
<ol>
<li>设置响应状态码：<code>resp.setStatus(302)</code></li>
<li>设置重定向的路径（响应到哪里，通过响应头 location 来指定）
<ul>
<li><code>response.setHeader("Location","http://www.baidu.com");</code></li>
<li><code>response.setHeader("Location","/response/servletDemo08);</code></li>
</ul>
</li>
</ol>
</li>
<li>
<p>方式二：</p>
<ul>
<li><code> resp.sendRedirect("重定向的路径");</code></li>
</ul>
</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h5> 重定向和转发</h5>
<p>请求重定向跳转的特点：</p>
<ol>
<li>重定向是由<strong>浏览器发起</strong>的，在这个过程中浏览器会发起<strong>两次请求</strong></li>
<li>重定向可以跳转到任意服务器的资源，但是<strong>无法跳转到WEB-INF中的资源</strong></li>
<li>重定向不能和请求域对象共享数据，数据会丢失</li>
<li>重定向浏览器的地址栏中的地址会变成跳转到的路径</li>
</ol>
<p>请求转发跳转的特点：</p>
<ol>
<li>请求转发是由<strong>服务器发起</strong>的，在这个过程中浏览器只会发起<strong>一次请求</strong></li>
<li>请求转发只能跳转到本项目的资源，但是<strong>可以跳转到WEB-INF中的资源</strong></li>
<li>请求转发可以和请求域对象共享数据，数据不会丢失</li>
<li>请求转发浏览器地址栏不变</li>
</ol>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/重定向和请求转发对比图.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 路径问题</h3>
<p><strong>完整URL地址：</strong></p>
<ol>
<li>协议：http://</li>
<li>服务器主机地址：127.0.0.1  or localhost</li>
<li>服务器端口号：8080</li>
<li>项目的虚拟路径(部署路径)：/response</li>
<li>具体的项目上资源路径   /login.html      or     Demo 的Servlet映射路径</li>
</ol>
<p><strong>相对路径：</strong></p>
<p>不以"/"开头的路径写法，它是以目标路径相对当前文件的路径，其中".."表示上一级目录。</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>绝对路径：</strong></p>
<p>绝对路径就是以"/"开头的路径写法，项目部署的路径</p>
<hr>
<h2> Cookie</h2>
<h3> 会话技术</h3>
<p><strong>会话</strong>：浏览器和服务器之间的多次请求和响应</p>
<p>浏览器和服务器可能产生多次的请求和响应，从浏览器访问服务器开始，到访问服务器结束（关闭浏览器、到了过期时间），这期间产生的多次请求和响应加在一起称为浏览器和服务器之间的一次对话</p>
<p>作用：保存用户各自的数据（以浏览器为单位），在多次请求间实现数据共享</p>
<p><strong>常用的会话管理技术</strong>：</p>
<ul>
<li>
<p>Cookie：客户端会话管理技术，用户浏览的信息以键值对（key=value）的形式保存在浏览器上。如果没有关闭浏览器，再次访问服务器，会把 cookie 带到服务端，服务端就可以做相应的处理</p>
</li>
<li>
<p>Session：服务端会话管理技术。当客户端第一次请求 session 对象时，服务器为每一个浏览器开辟一块内存空间，并将通过特殊算法算出一个 session 的 ID，用来标识该 session 对象。由于内存空间是每一个浏览器独享的，所有用户在访问的时候，可以把信息保存在 session 对象中，同时服务器会把 sessionId 写到 cookie 中，再次访问的时候，浏览器会把 cookie(sessionId) 带过来，找到对应的 session 对象即可</p>
<p>tomcat 生成的 sessionID 叫做 jsessionID</p>
</li>
</ul>
<p>两者区别：</p>
<ul>
<li>
<p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie，应该将 Cookie 信息加密然后使用到的时候再去服务器端解密</p>
</li>
<li>
<p>Cookie 一般用来保存用户信息，在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候就不需要重新登录，因为用户登录的时候可以存放一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可（为了安全考虑，重新登录一般要将 Token 重写），所以登录一次网站后访问网站其他页面不需要重新登录</p>
</li>
<li>
<p>Session 通过服务端记录用户的状态，服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户</p>
</li>
<li>
<p>Cookie 只能存储 ASCII 码，而 Session 可以存储任何类型的数据</p>
</li>
</ul>
<p>参考文章：<a href="https://blog.csdn.net/weixin_43625577/article/details/92393581" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/weixin_43625577/article/details/92393581</a></p>
<hr>
<h3> 基本介绍</h3>
<p>Cookie：客户端会话管理技术，把要共享的数据保存到了客户端（也就是浏览器端）。每次请求时，把会话信息带到服务器，从而实现多次请求的数据共享。</p>
<p>作用：保存客户浏览器访问网站的相关内容（需要客户端不禁用 Cookie），从而在每次访问同一个内容时，先从本地缓存获取，使资源共享，提高效率。</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Cookie类讲解.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h3> 基本使用</h3>
<h4> 常用API</h4>
<ul>
<li>
<p><strong>Cookie属性：</strong></p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>属性作用</th>
<th>是否重要</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>cookie的名称</td>
<td>必要属性</td>
</tr>
<tr>
<td>value</td>
<td>cookie的值（不能是中文）</td>
<td>必要属性</td>
</tr>
<tr>
<td>path</td>
<td>cookie的路径</td>
<td>重要</td>
</tr>
<tr>
<td>domain</td>
<td>cookie的域名</td>
<td>重要</td>
</tr>
<tr>
<td>maxAge</td>
<td>cookie的生存时间</td>
<td>重要</td>
</tr>
<tr>
<td>version</td>
<td>cookie的版本号</td>
<td>不重要</td>
</tr>
<tr>
<td>comment</td>
<td>cookie的说明</td>
<td>不重要</td>
</tr>
</tbody>
</table>
<p>注意：Cookie 有大小，个数限制。每个网站最多只能存20个 Cookie，且大小不能超过 4kb。同时所有网站的 Cookie 总数不超过300个。</p>
</li>
<li>
<p><strong>Cookie类API：</strong></p>
<ul>
<li>
<p><code>Cookie(String name, String value)</code> : 构造方法创建 Cookie 对象</p>
</li>
<li>
<p>Cookie 属性对应的 set 和 get 方法，name 属性被 final 修饰，没有 set 方法</p>
</li>
</ul>
</li>
<li>
<p>HttpServletResponse 类 API：</p>
<ul>
<li><code>void addCookie(Cookie cookie)</code>：向客户端添加 Cookie，Adds cookie to the response</li>
</ul>
</li>
<li>
<p>HttpServletRequest类API：</p>
<ul>
<li><code>Cookie[] getCookies()</code>：获取所有的 Cookie 对象，client sent with this request</li>
</ul>
</li>
</ul>
<hr>
<h4> 有效期</h4>
<p>如果不设置过期时间，表示这个 Cookie 生命周期为浏览器会话期间，只要关闭浏览器窗口 Cookie 就消失，这种生命期为浏览会话期的 Cookie 被称为会话 Cookie，会话 Cookie 一般不保存在硬盘上而是保存在内存里。</p>
<p>如果设置过期时间，浏览器就会把 Cookie 保存到硬盘上，关闭后再次打开浏览器，这些 Cookie 依然有效直到超过设定的过期时间。存储在硬盘上的 Cookie 可以在<strong>不同的浏览器进程间共享</strong>，比如两个 IE 窗口，而对于保存在内存的 Cookie，不同的浏览器有不同的处理方式</p>
<p>设置 Cookie 存活时间 API：<code>void setMaxAge(int expiry)</code></p>
<ul>
<li>-1：默认，代表 Cookie 数据存到浏览器关闭（保存在浏览器文件中）</li>
<li>0：代表删除 Cookie，如果要删除 Cookie 要确保<strong>路径一致</strong></li>
<li>正整数：以秒为单位保存数据有有效时间（把缓存数据保存到磁盘中）</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 有效路径</h4>
<p><code>setPath(String url)</code> : Cookie 设置有效路径</p>
<p>有效路径作用 :</p>
<ol>
<li>保证不会携带别的网站/项目里面的 Cookie 到我们自己的项目</li>
<li>路径不一样，Cookie 的 key 可以相同</li>
<li>保证自己的项目可以合理的利用自己项目的 Cookie</li>
</ol>
<p>判断路径是否携带 Cookie：请求资源 URI.startWith(cookie的path)，返回 true 就带</p>
<table>
<thead>
<tr>
<th>访问URL</th>
<th>URI部分</th>
<th>Cookie的Path</th>
<th>是否携带Cookie</th>
<th>能否取到Cookie</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://localhost:8080/servlet/servletDemo02" target="_blank" rel="noopener noreferrer">servletDemo02</a></td>
<td>/servlet/servletDemo02</td>
<td>/servlet/</td>
<td>带</td>
<td>能取到</td>
</tr>
<tr>
<td><a href="http://localhost:8080/servlet/servletDemo03" target="_blank" rel="noopener noreferrer">servletDemo03</a></td>
<td>/servlet/servletDemo03</td>
<td>/servlet/</td>
<td>带</td>
<td>能取到</td>
</tr>
<tr>
<td><a href="http://localhost:8080/servlet/aaa/servletDemo03" target="_blank" rel="noopener noreferrer">servletDemo04</a></td>
<td>/servlet/aaa/servletDemo04</td>
<td>/servlet/</td>
<td>带</td>
<td>能取到</td>
</tr>
<tr>
<td><a href="http://localhost:8080/bbb/servletDemo03" target="_blank" rel="noopener noreferrer">servletDemo05</a></td>
<td>/bbb/servletDemo04</td>
<td>/servlet/</td>
<td>不带</td>
<td>不能取到</td>
</tr>
</tbody>
</table>
<p>只有当访问资源的 url 包含此 cookie 的有效 path 的时候，才会携带这个 cookie</p>
<p>想要当前项目下的 Servlet 可以使用该 cookie，一般设置：<code>cookie.setPath(request.getContextPath())</code></p>
<hr>
<h4> 安全性</h4>
<p>如果 Cookie 中设置了 HttpOnly 属性，通过 js 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击，窃取 cookie 内容，这样就增加了安全性，即便是这样，也不要将重要信息存入cookie。</p>
<p>XSS 全称 Cross SiteScript，跨站脚本攻击，是Web程序中常见的漏洞，XSS 属于被动式且用于客户端的攻击方式，所以容易被忽略其危害性。其原理是攻击者向有 XSS 漏洞的网站中输入(传入)恶意的 HTML 代码，当其它用户浏览该网站时，这段HTML代码会自动执行，从而达到攻击的目的。如盗取用户 Cookie、破坏页面结构、重定向到其它网站等。</p>
<hr>
<h2> Session</h2>
<h3> 基本介绍</h3>
<p>Session：服务器端会话管理技术，本质也是采用客户端会话管理技术，不过在客户端保存的是一个特殊标识，共享的数据保存到了服务器的内存对象中。每次请求时，会将特殊标识带到服务器端，根据标识来找到对应的内存空间，从而实现数据共享。简单说它就是一个服务端会话对象，用于存储用户的会话数据</p>
<p>Session 域（会话域）对象是 Servlet 规范中四大域对象之一，并且它也是用于实现数据共享的</p>
<table>
<thead>
<tr>
<th>域对象</th>
<th>功能</th>
<th>创建</th>
<th>销毁</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>ServletContext</td>
<td>应用域</td>
<td>服务器启动</td>
<td>服务器关闭</td>
<td>在整个应用之间实现数据共享<br>（记录网站访问次数，聊天室）</td>
</tr>
<tr>
<td>ServletRequest</td>
<td>请求域</td>
<td>请求到来</td>
<td>响应了这个请求</td>
<td>在当前请求或者请求转发之间实现数据共享</td>
</tr>
<tr>
<td>HttpSession</td>
<td>会话域</td>
<td>getSession()</td>
<td>session过期，调用invalidate()，服务器关闭</td>
<td>在当前会话范围中实现数据共享，可以在多次请求中实现数据共享。<br>（验证码校验, 保存用户登录状态等）</td>
</tr>
</tbody>
</table>
<hr>
<h3> 基本使用</h3>
<h4> 获取会话</h4>
<p>HttpServletRequest类获取Session：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>HttpSession getSession()</td>
<td>获取HttpSession对象</td>
</tr>
<tr>
<td>HttpSession getSession(boolean creat)</td>
<td>获取HttpSession对象，未获取到是否自动创建</td>
</tr>
</tbody>
</table>
<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Session获取的两个方法.png" style="zoom: 80%;">
<hr>
<h4> 常用API</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void setAttribute(String name, Object value)</td>
<td>设置会话域中的数据</td>
</tr>
<tr>
<td>Object getAttribute(String name)</td>
<td>获取指定名称的会话域数据</td>
</tr>
<tr>
<td>Enumeration&lt;String&gt; getAttributeNames()</td>
<td>获取所有会话域所有属性的名称</td>
</tr>
<tr>
<td>void removeAttribute(String name)</td>
<td>移除会话域中指定名称的数据</td>
</tr>
<tr>
<td>String getId()</td>
<td>获取唯一标识名称，Jsessionid的值</td>
</tr>
<tr>
<td>void invalidate()</td>
<td>立即失效session</td>
</tr>
</tbody>
</table>
<hr>
<h4> 实现会话</h4>
<p>通过第一个Servlet设置共享的数据用户名，并在第二个Servlet获取到</p>
<p>项目执行完以后，去浏览器抓包，Request Headers 中的 Cookie JSESSIONID的值是一样的</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 生命周期</h4>
<p>Session 的创建：一个常见的错误是以为 Session 在有客户端访问时就被创建，事实是直到某 server 端程序（如 Servlet）调用 <code>HttpServletRequest.getSession(true)</code> 这样的语句时才会被创建</p>
<p>Session 在以下情况会被删除：</p>
<ul>
<li>程序调用 HttpSession.invalidate()</li>
<li>距离上一次收到客户端发送的 session id 时间间隔超过了 session 的最大有效时间</li>
<li>服务器进程被停止</li>
</ul>
<p>注意事项：</p>
<ul>
<li>客户端只保存 sessionID 到 cookie 中，而不会保存 session</li>
<li>关闭浏览器只会使存储在客户端浏览器内存中的 cookie 失效，不会使服务器端的 session 对象失效，同样也不会使已经保存到硬盘上的持久化cookie消失</li>
</ul>
<p>打开两个浏览器窗口访问应用程序会使用的是不同的session，通常 session cookie 是不能跨窗口使用，当新开了一个浏览器窗口进入相同页面时，系统会赋予一个新的 session id，实现跨窗口信息共享：</p>
<ul>
<li>先把 session id 保存在 persistent cookie 中（通过设置session的最大有效时间）</li>
<li>在新窗口中读出来，就可以得到上一个窗口的 session id，这样通过 session cookie 和 persistent cookie 的结合就可以实现跨窗口的会话跟踪</li>
</ul>
<hr>
<h3> 会话问题</h3>
<h4> 禁用Cookie</h4>
<p>浏览器禁用Cookie解决办法：</p>
<ul>
<li>
<p>方式一：通过提示信息告知用户</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>方式二：访问时拼接 jsessionid 标识，通过 encodeURL() 方法<strong>重写地址</strong></p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 钝化活化</h4>
<p>Session 存放在服务器端的内存中，可以做持久化管理。</p>
<p>钝化：序列化，持久态。把长时间不用，但还不到过期时间的 HttpSession 进行序列化写到磁盘上。</p>
<p>活化：相反的状态</p>
<p>何时钝化：</p>
<ul>
<li>当访问量很大时，服务器会根据getLastAccessTime来进行排序，对长时间不用，但是还没到过期时间的HttpSession进行序列化（持久化）</li>
<li>当服务器进行重启的时候，为了保持客户HttpSession中的数据，也要对HttpSession进行序列化（持久化）</li>
</ul>
<p>注意：</p>
<ul>
<li>HttpSession的持久化由服务器来负责管理，我们不用关心</li>
<li>只有实现了序列化接口的类才能被序列化</li>
</ul>
<hr>
<h2> JSP</h2>
<h3> JSP概述</h3>
<p>JSP(Java Server Page)：是一种动态网页技术标准。（页面技术）</p>
<p>JSP是基于Java语言的，它的本质就是Servlet，一个特殊的Servlet。</p>
<p>JSP部署在服务器上，可以处理客户端发送的请求，并根据请求内容动态的生成HTML、XML或其他格式文档的Web网页，然后响应给客户端。</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTML</td>
<td>开发静态资源，不能包含java代码，无法添加动态数据。</td>
</tr>
<tr>
<td>CSS</td>
<td>美化页面</td>
</tr>
<tr>
<td>JavaScript</td>
<td>给网页添加动态效果</td>
</tr>
<tr>
<td>Servlet</td>
<td>编写java代码，实现后台功能处理，但是很不方便，开发效率低。</td>
</tr>
<tr>
<td>JSP</td>
<td>包括了显示页面技术，同时具备Servlet输出动态资源的能力。但是不适合作为控制器来用。</td>
</tr>
</tbody>
</table>
<h3> 执行原理</h3>
<ul>
<li>
<p>新建JavaEE工程，编写index.jsp文件</p>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>执行过程：</p>
<p>客户端提交请求——Tomcat服务器解析请求地址——找到JSP页面——Tomcat将JSP页面翻译成Servlet的java文件——将翻译好的.java文件编译成.class文件——返回到客户浏览器上</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/JSP执行过程.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>溯源，打开JSP翻译后的Java文件</p>
<p><code>public final class index_jsp extends org.apache.jasper.runtime.HttpJspBase</code>，<code>public abstract class HttpJspBase extends HttpServlet implements HttpJspPage</code>，HttpJspBase是个抽象类继承HttpServlet，所以JSP本质上继承HttpServlet</p>
<p>在文件中找到了输出页面的代码，本质都是用out.write()输出的JSP语句</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Jsp的本质说明.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
<li>
<p>总结：<br>
JSP它是一个特殊的Servlet，主要是用于展示动态数据。它展示的方式是用流把数据输出出来，而我们在使用JSP时，涉及HTML的部分，都与HTML的用法一致，这部分称为jsp中的模板元素，决定了页面的外观。</p>
</li>
</ul>
<hr>
<h3> JSP语法</h3>
<ul>
<li>
<p>JSP注释：</p>
<table>
<thead>
<tr>
<th>注释类型</th>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>JSP注释</td>
<td>&lt;%--注释内容--%&gt;</td>
<td>被jsp注释的部分不会被翻译成.java文件，不会在浏览器上显示</td>
</tr>
<tr>
<td>HTML注释</td>
<td><!--HTML注释--></td>
<td>在Jsp中可以使用html的注释，但是只能注释html元素<br>被html注释部分会参与翻译，并且会在浏览器上显示</td>
</tr>
<tr>
<td>Java注释</td>
<td>//; /* */</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>Java代码块</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>JSP表达式</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>JSP声明</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>语法示例：</p>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> JSP指令</h3>
<ul>
<li>
<p><strong>page指令：</strong></p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>contentType</td>
<td>设置响应正文支持的MIME类型和编码格式：contentType="text/html;charset=UTF-8"</td>
</tr>
<tr>
<td>language</td>
<td>告知引擎，脚本使用的语言，默认为Java</td>
</tr>
<tr>
<td>errorPage</td>
<td>当前页面出现异常后跳转的页面</td>
</tr>
<tr>
<td>isErrorPage</td>
<td>是否抓住异常。值为true页面中就能使用exception对象，打印异常信息。默认值false</td>
</tr>
<tr>
<td>import</td>
<td>导入哪些包（类）&lt;%@ page import="java.util.ArrayList" %&gt;</td>
</tr>
<tr>
<td>session</td>
<td>是否创建HttpSession对象，默认是true</td>
</tr>
<tr>
<td>buffer</td>
<td>设定JspWriter用s输出jsp内容的缓存大小。默认8kb</td>
</tr>
<tr>
<td>pageEncoding</td>
<td>翻译jsp时所用的编码格式，pageEncoding="UTF-8"相当于用UTF-8读取JSP</td>
</tr>
<tr>
<td>isELIgnored</td>
<td>是否忽略EL表达式，默认值是false</td>
</tr>
</tbody>
</table>
<p>Note：当使用全局错误页面，就无须配置errorPage实现跳转错误页面，而是由服务器负责跳转到错误页面</p>
<ul>
<li>
<p>配置全局错误页面：web.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
</li>
<li>
<p>**include指令：**包含其他页面</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>属性：file，以/开头，就代表当前应用</p>
</li>
<li>
<p>**taglib指令：**引入外部标签库</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>html标签和jsp标签不用引入</p>
</li>
</ul>
<hr>
<h3> 隐式对象</h3>
<h4> 九大隐式对象</h4>
<p>隐式对象：在jsp中可以不声明就直接使用的对象。它只存在于jsp中，因为java类中的变量必须要先声明再使用。<br>
jsp中的隐式对象也并不是未声明，它是在翻译成.java文件时声明的，所以我们在jsp中可以直接使用。</p>
<table>
<thead>
<tr>
<th>隐式对象名称</th>
<th>类型</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>request</td>
<td>javax.servlet.http.HttpServletRequest</td>
<td></td>
</tr>
<tr>
<td>response</td>
<td>javax.servlet.http.HttpServletResponse</td>
<td></td>
</tr>
<tr>
<td>session</td>
<td>javax.servlet.http.HttpSession</td>
<td>Page指令可以控制开关</td>
</tr>
<tr>
<td>application</td>
<td>javax.servlet.ServletContext</td>
<td></td>
</tr>
<tr>
<td>page</td>
<td>Java.lang.Object</td>
<td>当前jsp对应的servlet引用实例</td>
</tr>
<tr>
<td>config</td>
<td>javax.servlet.ServletConfig</td>
<td></td>
</tr>
<tr>
<td>exception</td>
<td>java.lang.Throwable</td>
<td>page指令有开关</td>
</tr>
<tr>
<td>out</td>
<td>javax.servlet.jsp.JspWriter</td>
<td>字符输出流，相当于printwriter</td>
</tr>
<tr>
<td>pageContext</td>
<td>javax.servlet.jsp.PageContext</td>
<td>很重要，页面域</td>
</tr>
</tbody>
</table>
<h4> PageContext</h4>
<ul>
<li>
<p>PageContext对象特点：</p>
<ul>
<li>PageContextd对象是JSP独有的对象，Servlet中没有</li>
<li>PageContextd对象是一个<strong>页面域（作用范围）对象</strong>，还可以操作其他三个域对象中的属性</li>
<li>PageContextd对象<strong>可以获取其他八个隐式对象</strong></li>
<li>PageContextd对象是一个局部变量，它的生命周期随着JSP的创建而诞生，随着JSP的结束而消失。每个JSP页面都有一个独立的PageContext</li>
</ul>
</li>
<li>
<p>PageContext方法如下，页面域操作的方法定义在了PageContext的父类JspContext中</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/PageContext方法详解.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
</li>
</ul>
<hr>
<h3> 四大域对象</h3>
<table>
<thead>
<tr>
<th>域对象名称</th>
<th>范围</th>
<th>级别</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>PageContext</td>
<td>页面范围</td>
<td>最小，只能在当前页面用</td>
<td>因范围太小，开发中用的很少</td>
</tr>
<tr>
<td>ServletRequest</td>
<td>请求范围</td>
<td>一次请求或当期请求转发用</td>
<td>当请求转发之后，再次转发时请求域丢失</td>
</tr>
<tr>
<td>HttpSession</td>
<td>会话范围</td>
<td>多次请求数据共享时使用</td>
<td>多次请求共享数据，但不同的客户端不能共享</td>
</tr>
<tr>
<td>ServletContext</td>
<td>应用范围</td>
<td>最大，整个应用都可以使用</td>
<td>尽量少用，如果对数据有修改需要做同步处理</td>
</tr>
</tbody>
</table>
<hr>
<h3> MVC模型</h3>
<p>M : model， 通常用于封装数据，封装的是数据模型<br>
V :  view，通常用于展示数据。动态展示用jsp页面，静态数据展示用html<br>
C :  controller，通常用于处理请求和响应，一般指的是Servlet</p>
<figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/MVC模型.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h2> EL</h2>
<h3> EL概述</h3>
<p>EL表达式：Expression Language，意为表达式语言。它是Servlet规范中的一部分，是JSP2.0规范加入的内容。</p>
<p>EL表达式作用：在JSP页面中获取数据，让JSP脱离java代码块和JSP表达式</p>
<p>EL表达式格式： <code>${表达式内容}</code></p>
<p>EL表达式特点：</p>
<ul>
<li>有明确的<strong>返回值</strong></li>
<li>把内容输出到<strong>页面</strong>上</li>
<li><strong>只能在四大域对象中获取数据</strong>，不在四大域对象中的数据取不到。</li>
</ul>
<hr>
<h3> EL用法</h3>
<h4> 多种类型</h4>
<p>EL表达式可以获取不同类型数据，前提是数据放入四大域对象。</p>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 异常问题</h4>
<p>EL表达式的注意事项：</p>
<ol>
<li>EL表达式没有空指针异常</li>
<li>EL表达式没有数组下标越界</li>
<li>EL表达式没有字符串拼接</li>
</ol>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 运算符</h4>
<p>EL表达式中运算符：</p>
<ul>
<li>
<p>关系运算符：<img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/EL表达式关系运算符.png" alt="" loading="lazy"></p>
</li>
<li>
<p>逻辑运算符：</p>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp; 或 and</td>
<td>交集</td>
</tr>
<tr>
<td>|| 或 or</td>
<td>并集</td>
</tr>
<tr>
<td>! 或 not</td>
<td>非</td>
</tr>
</tbody>
</table>
<p>​</p>
</li>
<li>
<p>其他运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>empty</td>
<td>1. 判断对象是否为null<br>2. 判断字符串是否为空字符串<br>3. 判断容器元素是否为0</td>
</tr>
<tr>
<td>条件 ? 表达式1 : 表达式2</td>
<td>三元运算符，条件?真:假</td>
</tr>
</tbody>
</table>
</li>
</ul>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/EL表达式运算符效果图.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>
<hr>
<h4> 四大域数据</h4>
<p>EL表达式只能从从四大域中获取数据，调用的就是<code>findAttribute(name,value);</code>方法，根据名称由小到大在域对象中查找，找到就返回，找不到就什么都不显示。</p>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> EL隐式对象</h3>
<h4> EL表达式隐式对象</h4>
<p>EL表达式也为我们提供隐式对象，可以让我们不声明直接来使用，需要注意的是，它和JSP的隐式对象不是同一种事物。</p>
<table>
<thead>
<tr>
<th>EL中的隐式对象</th>
<th>类型</th>
<th>对应JSP隐式对象</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>PageContext</td>
<td>Javax.serlvet.jsp.PageContext</td>
<td>PageContext</td>
<td>完全一样</td>
</tr>
<tr>
<td>ApplicationScope</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>应用层范围</td>
</tr>
<tr>
<td>SessionScope</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>会话范围</td>
</tr>
<tr>
<td>RequestScope</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求范围</td>
</tr>
<tr>
<td>PageScope</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>页面层范围</td>
</tr>
<tr>
<td>Header</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求消息头key，值是value（一个）</td>
</tr>
<tr>
<td>HeaderValues</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求消息头key，值是数组（一个头多个值）</td>
</tr>
<tr>
<td>Param</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求参数key，值是value（一个）</td>
</tr>
<tr>
<td>ParamValues</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>请求参数key，值是数组（一个名称多个值）</td>
</tr>
<tr>
<td>InitParam</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>全局参数，key是参数名称，value是参数值</td>
</tr>
<tr>
<td>Cookie</td>
<td>Java.util.Map</td>
<td>没有</td>
<td>Key是cookie的名称，value是cookie对象</td>
</tr>
</tbody>
</table>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在web.xml配置全局参数</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> 获取JSP隐式对象</h4>
<p>通过获取页面域对象，获取其他JSP八个隐式对象</p>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h3> JSTL</h3>
<p>JSTL：Java Server Pages Standarded Tag Library，JSP中标准标签库。</p>
<p>作用：提供给开发人员一个标准的标签库，开发人员可以利用这些标签取代JSP页面上的Java代码，从而提高程序的可读性，降低程序的维护难度。</p>
<table>
<thead>
<tr>
<th>组成</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core</td>
<td>核心标签库</td>
<td>通用逻辑处理</td>
</tr>
<tr>
<td>Fmt</td>
<td>国际化有关</td>
<td>需要不同地域显示不同语言时使用</td>
</tr>
<tr>
<td>Functions</td>
<td>EL函数</td>
<td>EL表达式可以使用的方法</td>
</tr>
<tr>
<td>SQL</td>
<td>操作数据库</td>
<td></td>
</tr>
<tr>
<td>XML</td>
<td>操作XML</td>
<td></td>
</tr>
</tbody>
</table>
<p>使用：添加jar包，通过taglib导入，prefix属性表示程序调用标签使用的引用名</p>
<table>
<thead>
<tr>
<th>标签名称</th>
<th>功能分类</th>
<th>分类</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>`&lt;c:if test="${A==B</td>
<td></td>
<td>C==D}"&gt;`</td>
<td>流程控制</td>
</tr>
<tr>
<td><code>&lt;c:choose&gt; ,&lt;c:when&gt;,&lt;c:otherwise&gt;</code></td>
<td>流程控制</td>
<td>核心标签库</td>
<td>用于多个条件判断</td>
</tr>
<tr>
<td><code>&lt;c:foreache&gt;</code></td>
<td>迭代操作</td>
<td>核心标签库</td>
<td>用于循环遍历</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>流程控制</p>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>迭代操作<br>
c:forEach：用来遍历集合，属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>items</td>
<td>指定要遍历的集合，它可以是用EL表达式取出来的元素</td>
</tr>
<tr>
<td>var</td>
<td>把当前遍历的元素放入指定的page域中。var的值是key，遍历的元素是value<br>注意：var不支持EL表达式，只能是字符串常量</td>
</tr>
<tr>
<td>begin</td>
<td>开始遍历的索引</td>
</tr>
<tr>
<td>end</td>
<td>结束遍历的索引</td>
</tr>
<tr>
<td>step</td>
<td>步长，i+=step</td>
</tr>
<tr>
<td>varStatus</td>
<td>它是一个计数器对象，有两个属性，一个是用于记录索引，一个是用于计数。索引是从0开始，计数是从1开始</td>
</tr>
</tbody>
</table>
<div class="language-jsp line-numbers-mode" data-ext="jsp"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h2> Filter</h2>
<h3> 过滤器</h3>
<p>Filter：过滤器，是 JavaWeb 三大组件之一，另外两个是 Servlet 和 Listener</p>
<p>工作流程：在程序访问服务器资源时，当一个请求到来，服务器首先判断是否有过滤器与去请求资源相关联，如果有过滤器可以将请求拦截下来，完成一些特定的功能，再由过滤器决定是否交给请求资源，如果没有就直接请求资源，响应同理</p>
<p>作用：过滤器一般用于完成通用的操作，例如：登录验证、统一编码处理、敏感字符过滤等</p>
<hr>
<h3> 相关类</h3>
<h4> Filter</h4>
<p>Filter是一个接口，如果想实现过滤器的功能，必须实现该接口</p>
<ul>
<li>
<p>核心方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void init(FilterConfig filterConfig)</td>
<td>初始化，开启过滤器</td>
</tr>
<tr>
<td>void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</td>
<td>对请求资源和响应资源过滤</td>
</tr>
<tr>
<td>void destroy()</td>
<td>销毁过滤器</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>配置方式</p>
<p>注解方式</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>配置文件</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> FilterChain</h4>
<ul>
<li>
<p>FilterChain 是一个接口，代表过滤器对象。由Servlet容器提供实现类对象，直接使用即可。</p>
</li>
<li>
<p>过滤器可以定义多个，就会组成过滤器链</p>
</li>
<li>
<p>核心方法：<code>void doFilter(ServletRequest request, ServletResponse response)</code> 用来放行方法</p>
<p>如果有多个过滤器，在第一个过滤器中调用下一个过滤器，以此类推，直到到达最终访问资源。<br>
如果只有一个过滤器，放行时就会直接到达最终访问资源。</p>
</li>
</ul>
<h4> FilterConfig</h4>
<p>FilterConfig 是一个接口，代表过滤器的配置对象，可以加载一些初始化参数</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getFilterName()</td>
<td>获取过滤器对象名称</td>
</tr>
<tr>
<td>String getInitParameter(String name)</td>
<td>获取指定名称的初始化参数的值，不存在返回null</td>
</tr>
<tr>
<td>Enumeration&lt;String&gt; getInitParameterNames()</td>
<td>获取所有参数的名称</td>
</tr>
<tr>
<td>ServletContext getServletContext()</td>
<td>获取应用上下文对象</td>
</tr>
</tbody>
</table>
<hr>
<h3> Filter使用</h3>
<h4> 设置页面编码</h4>
<p>请求先被过滤器拦截进行相关操作</p>
<p>过滤器放行之后执行完目标资源，仍会回到过滤器中</p>
<ul>
<li>
<p>Filter 代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Servlet 代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>控制台输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> 多过滤器顺序</h4>
<p>多个过滤器使用的顺序，取决于过滤器映射的顺序。</p>
<ul>
<li>
<p>两个 Filter 代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Servlet代码：<code>System.out.println("servletDemo02执行了...");</code></p>
</li>
<li>
<p>web.xml配置：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>控制台输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<p>在过滤器的配置中，有过滤器的声明和过滤器的映射两部分，到底是声明决定顺序，还是映射决定顺序呢？</p>
<p>答案是：<code>&lt;filter-mapping&gt;</code>的配置前后顺序决定过滤器的调用顺序，也就是由映射配置顺序决定。</p>
<hr>
<h4> Filter生命周期</h4>
<p>**创建：**当应用加载时实例化对象并执行init()初始化方法</p>
<p>**服务：**对象提供服务的过程，执行doFilter()方法</p>
<p><strong>销毁</strong>：当应用卸载时或服务器停止时对象销毁，执行destroy()方法</p>
<ul>
<li>
<p>Filter代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>Servlet 代码：<code>System.out.println("servletDemo03执行了...");</code></p>
</li>
<li>
<p>控制台输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h4> FilterConfig使用</h4>
<p>Filter初始化函数init的参数是FilterConfig 对象</p>
<ul>
<li>
<p>Filter代码：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>web.xml配置</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>控制台输出：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> Filter案例</h3>
<p>在访问html，js，image时，不需要每次都重新发送请求读取资源，就可以通过设置响应消息头的方式，设置缓存时间。但是如果每个Servlet都编写相同的代码，显然不符合我们统一调用和维护的理念。</p>
<p>静态资源设置缓存时间：html设置为1小时，js设置为2小时，css设置为3小时</p>
<ul>
<li>
<p>配置过滤器</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>编写过滤器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 拦截行为</h3>
<p>Filter过滤器默认拦截的是请求，但是在实际开发中，我们还有请求转发和请求包含，以及由服务器触发调用的全局错误页面。默认情况下过滤器是不参与过滤的，需要配置web.xml</p>
<p>开启功能后，当访问页面发生相关行为后，会执行过滤器的操作</p>
<p>五种拦截行为：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>
<p>web.xml：</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>ServletDemo03：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>FilterDemo05：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li>
<li>
<p>访问URL：<a href="http://localhost:8080/filter/servletDemo03" target="_blank" rel="noopener noreferrer">http://localhost:8080/filter/servletDemo03</a></p>
</li>
<li>
<p>控制台输出（注意输出顺序）：</p>
<div class="language-text line-numbers-mode" data-ext="text"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li>
</ul>
<hr>
<h3> 对比Servlet</h3>
<table>
<thead>
<tr>
<th>方法/类型</th>
<th>Servlet</th>
<th>Filter</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始化                                        方法</td>
<td>void   init(ServletConfig);</td>
<td>void init(FilterConfig);</td>
<td>几乎一样，都是在web.xml中配置参数，用该对象的方法可以获取到。</td>
</tr>
<tr>
<td>提供服务方法</td>
<td>void   service(request,response);</td>
<td>void   dofilter(request,response,FilterChain)</td>
<td>Filter比Servlet多了一个FilterChain，它不仅能完成Servlet的功能，而且还可以决定程序是否能继续执行。所以过滤器比Servlet更为强大。   在Struts2中，核心控制器就是一个过滤器。</td>
</tr>
<tr>
<td>销毁方法</td>
<td>void destroy();</td>
<td>void destroy();</td>
<td>方法/类型</td>
</tr>
</tbody>
</table>
<hr>
<h2> Listener</h2>
<h3> 观察者设计者</h3>
<p>所有的监听器都是基于观察者设计模式的。</p>
<p>观察者模式通常由以下三部分组成：</p>
<ul>
<li>
<p>事件源：触发事件的对象。</p>
</li>
<li>
<p>事件：触发的动作，里面封装了事件源。</p>
</li>
<li>
<p>监听器：当事件源触发事件后，可以完成的功能。一般是一个接口，由使用者来实现。（此处的思想还涉及了一个策略模式）</p>
</li>
</ul>
<hr>
<h3> 监听器分类</h3>
<p>在程序当中，我们可以对：对象的创建销毁、域对象中属性的变化、会话相关内容进行监听。</p>
<p>Servlet规范中共计8个监听器，<strong>监听器都是以接口形式提供</strong>，具体功能需要我们自己完成</p>
<h4> 监听对象</h4>
<ul>
<li>
<p>ServletContextListener：用于监听ServletContext对象的创建和销毁</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void contextInitialized(ServletContextEvent sce)</td>
<td>对象创建时执行该方法</td>
</tr>
<tr>
<td>void contextDestroyed(ServletContextEvent sce)</td>
<td>对象销毁时执行该方法</td>
</tr>
</tbody>
</table>
<p>参数ServletContextEvent 代表事件对象，事件对象中封装了事件源ServletContext，真正的事件指的是创建或者销毁ServletContext对象的操作</p>
</li>
<li>
<p>HttpSessionListener：用于监听HttpSession对象的创建和销毁</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void sessionCreated(HttpSessionEvent se)</td>
<td style="text-align:left">对象创建时执行该方法</td>
</tr>
<tr>
<td>void sessionDestroyed(HttpSessionEvent se)</td>
<td style="text-align:left">对象销毁时执行该方法</td>
</tr>
</tbody>
</table>
<p>参数HttpSessionEvent 代表事件对象，事件对象中封装了事件源HttpSession，真正的事件指的是创建或者销毁HttpSession对象的操作</p>
</li>
<li>
<p>ServletRequestListener：用于监听ServletRequest对象的创建和销毁</p>
<table>
<thead>
<tr>
<th>方法</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void requestInitialized(ServletRequestEvent sre)</td>
<td style="text-align:left">对象创建时执行该方法</td>
</tr>
<tr>
<td>void requestDestroyed(ServletRequestEvent sre)</td>
<td style="text-align:left">对象销毁时执行该方法</td>
</tr>
</tbody>
</table>
<p>参数ServletRequestEvent 代表事件对象，事件对象中封装了事件源ServletRequest，真正的事件指的是创建或者销毁ServletRequest对象的操作</p>
</li>
</ul>
<hr>
<h4> 监听域对象属性</h4>
<ul>
<li>
<p>ServletContextAttributeListener：用于监听ServletContext应用域中属性的变化</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void attributeAdded(ServletContextAttributeEvent event)</td>
<td>域中添加属性时执行该方法</td>
</tr>
<tr>
<td>void attributeRemoved(ServletContextAttributeEvent event)</td>
<td>域中移除属性时执行该方法</td>
</tr>
<tr>
<td>void attributeReplaced(ServletContextAttributeEvent event)</td>
<td>域中替换属性时执行该方法</td>
</tr>
</tbody>
</table>
<p>参数ServletContextAttributeEvent 代表事件对象，事件对象中封装了事件源ServletContext，真正的事件指的是添加、移除、替换应用域中属性的操作</p>
</li>
<li>
<p>HttpSessionAttributeListener：用于监听HttpSession会话域中属性的变化</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void attributeAdded(HttpSessionBindingEvent event)</td>
<td>域中添加属性时执行该方法</td>
</tr>
<tr>
<td>void attributeRemoved(HttpSessionBindingEvent event)</td>
<td>域中移除属性时执行该方法</td>
</tr>
<tr>
<td>void attributeReplaced(HttpSessionBindingEvent event)</td>
<td>域中替换属性时执行该方法</td>
</tr>
</tbody>
</table>
<p>参数HttpSessionBindingEvent 代表事件对象，事件对象中封装了事件源HttpSession，真正的事件指的是添加、移除、替换应用域中属性的操作</p>
</li>
<li>
<p>ServletRequestAttributeListener：用于监听ServletRequest请求域中属性的变化</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void attributeAdded(ServletRequestAttributeEvent srae)</td>
<td>域中添加属性时执行该方法</td>
</tr>
<tr>
<td>void attributeRemoved(ServletRequestAttributeEvent srae)</td>
<td>域中移除属性时执行该方法</td>
</tr>
<tr>
<td>void attributeReplaced(ServletRequestAttributeEvent srae)</td>
<td>域中替换属性时执行该方法</td>
</tr>
</tbody>
</table>
<p>参数ServletRequestAttributeEvent 代表事件对象，事件对象中封装了事件源ServletRequest，真正的事件指的是添加、移除、替换应用域中属性的操作</p>
</li>
<li>
<p>页面域对象没有监听器</p>
</li>
</ul>
<hr>
<h4> 感知型监听器</h4>
<p>监听会话相关的感知型监听器，和会话域相关的两个感知型监听器是无需配置（注解）的，可以直接编写代码</p>
<ul>
<li>
<p>HttpSessionBindingListener：用于感知对象和会话域绑定的监听器</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void valueBound(HttpSessionBindingEvent event)</td>
<td>数据添加到会话域中(绑定)时执行该方法</td>
</tr>
<tr>
<td>void valueUnbound(HttpSessionBindingEvent event)</td>
<td>数据从会话域中移除(解绑)时执行该方法</td>
</tr>
</tbody>
</table>
<p>参数HttpSessionBindingEvent 代表事件对象，事件对象中封装了事件源HttpSession，真正的事件指的是添加、移除、替换应用域中属性的操作</p>
</li>
<li>
<p>HttpSessionActivationListener：用于感知会话域中对象和钝化和活化的监听器</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>void sessionWillPassivate(HttpSessionEvent se)</td>
<td>会话域中数据钝化时执行该方法</td>
</tr>
<tr>
<td>void sessionDidActivate(HttpSessionEvent se)</td>
<td>会话域中数据活化时执行该方法</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr>
<h3> 监听器使用</h3>
<h4> ServletContextListener</h4>
<p>ServletContext对象的创建和销毁的监听器</p>
<p>注解方式：</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>配置web.xml</p>
<div class="language-xml line-numbers-mode" data-ext="xml"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>
<h4> ServletContextAttributeListener</h4>
<p>应用域对象中的属性变化的监听器</p>
<div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-java line-numbers-mode" data-ext="java"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>控制台输出：</p>
<div class="language-html line-numbers-mode" data-ext="html"><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>]]></content:encoded>
      <enclosure url="https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/Tomcat目录结构详解.png" type="image/png"/>
    </item>
  </channel>
</rss>