# HTTP

## 相关概念

HTTP：Hyper Text Transfer Protocol，意为超文本传输协议，是建立在 **TCP/IP 协议**基础上，指的是服务器和客户端之间交互必须遵循的一问一答的规则，形容这个规则：问答机制、握手机制

HTTP 协议是**一个无状态的面向连接的协议**，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。所以打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系

注意：无状态并不是代表 HTTP 就是 UDP，面向连接也不是代表 HTTP 就是TCP

HTTP 作用：用于定义 WEB 浏览器与 WEB 服务器之间交换数据的过程和数据本身的内容

浏览器和服务器交互过程：浏览器请求，服务请求响应

* 请求（请求行、请求头、请求体）
* 响应（响应行、响应头、响应体）

URL 和 URI

* URL：统一资源定位符
  * 格式：http://127.0.0.1:8080/request/servletDemo01
  * 详解：http：协议；127.0.0.1：域名；8080：端口；request/servletDemo01：请求资源路径

* URI：统一资源标志符
  * 格式：/request/servletDemo01

* 区别：`URL - HOST = URI`，URI 是抽象的定义，URL 用地址定位，URI 用名称定位。**只要能唯一标识资源的是 URI，在 URI 的基础上给出其资源的访问方式的是 URL**

**从浏览器地址栏输入 URL 到请求返回发生了什么？**

* 进行 URL 解析，进行编码

* DNS 解析，顺序是先查 hosts 文件是否有记录，有的话就会把相对应映射的 IP 返回，然后去本地 DNS 缓存中寻找，然后依次向本地域名服务器、根域名服务器、顶级域名服务器、权限域名服务器发起查询请求，最终返回 IP 地址给本地域名服务器

  本地域名服务器将得到的 IP 地址返回给操作系统，同时将 IP 地址缓存起来；操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来

* 查找到 IP 之后，进行 TCP 协议的三次握手建立连接

* 发出 HTTP 请求，取文件指令

* 服务器处理请求，返回响应

* 释放 TCP 连接

* 浏览器解析渲染页面



推荐阅读：https://xiaolincoding.com/network/



***



## 版本区别

版本介绍：

* HTTP/0.9 仅支持 GET 请求，不支持请求头
* HTTP/1.0 默认短连接（一次请求建议一次 TCP 连接，请求完就断开），支持 GET、POST、 HEAD 请求
* HTTP/1.1 默认长连接（一次 TCP 连接可以多次请求）；支持 PUT、DELETE、PATCH 等六种请求；增加 HOST 头，支持虚拟主机；支持**断点续传**功能
* HTTP/2.0 多路复用，降低开销（一次 TCP 连接可以处理多个请求）；服务器主动推送（相关资源一个请求全部推送）；解析基于二进制，解析错误少，更高效（HTTP/1.X 解析基于文本）；报头压缩，降低开销
* HTTP/3.0 QUIC (Quick UDP Internet Connections)，快速 UDP 互联网连接，基于 UDP 协议

HTTP 1.0 和 HTTP 1.1 的主要区别：

* 长短连接：

  **在HTTP/1.0中，默认使用的是短连接**，每次请求都要重新建立一次连接，比如获取 HTML 和 CSS 文件，需要两次请求。HTTP 基于 TCP/IP 协议的，每一次建立或者断开连接都需要三次握手四次挥手，开销会比较大

  **HTTP 1.1起，默认使用长连接** ，默认开启 `Connection: keep-alive`，Keep-Alive 有一个保持时间，不会永久保持连接。持续连接有非流水线方式和流水线方式 ，流水线方式是客户端在收到 HTTP 的响应报文之前就能接着发送新的请求报文，非流水线方式是客户端在收到前一个响应后才能发送下一个请求

  HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接

* 错误状态响应码：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突，410（Gone）表示服务器上的某个资源被永久性的删除

* 缓存处理：在 HTTP1.0 中主要使用 header 里的 If-Modified-Since，Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略，例如 Entity tag，If-Unmodified-Since，If-Match，If-None-Match等

* 带宽优化及网络连接的使用：HTTP1.0 存在一些浪费带宽的现象，例如客户端只需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持**断点续传**功能，HTTP1.1 则在请求头引入了 range 头域，允许只**请求资源的某个部分**，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接

* HOST 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此请求消息中的 URL 并没有传递主机名。HTTP1.1 时代虚拟主机技术发展迅速，在一台物理服务器上可以存在多个虚拟主机，并且共享一个 IP 地址，故 HTTP1.1 增加了 HOST 信息

HTTP 1.1 和 HTTP 2.0 的主要区别：

* 新的二进制格式：HTTP1.1 基于文本格式传输数据，HTTP2.0 采用二进制格式传输数据，解析更高效
* **多路复用**：在一个连接里，允许同时发送多个请求或响应，并且这些请求或响应能够并行的传输而不被阻塞，避免 HTTP1.1 出现的队头堵塞问题
* 头部压缩，HTTP1.1 的 header 带有大量信息，而且每次都要重复发送；HTTP2.0 把 header 从数据中分离，并封装成头帧和数据帧，使用特定算法压缩头帧。并且 HTTP2.0 在客户端和服务器端记录了之前发送的键值对，对于相同的数据不会重复发送。比如请求 A 发送了所有的头信息字段，请求 B 则只需要发送差异数据，这样可以减少冗余数据，降低开销
* **服务端推送**：HTTP2.0 允许服务器向客户端推送资源，无需客户端发送请求到服务器获取



****



## 安全请求

HTTP 和 HTTPS 的区别：

* 端口 ：HTTP 默认使用端口 80，HTTPS 默认使用端口 443
* 安全性：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份；HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密
* 资源消耗：HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源

**对称加密和非对称加密**

* 对称加密：加密和解密使用同一个秘钥，把密钥转发给需要发送数据的客户机，中途会被拦截（类似于把带锁的箱子和钥匙给别人，对方打开箱子放入数据，上锁后发送），私钥用来解密数据，典型的对称加密算法有 DES、AES 等

  * 优点：运算速度快
  * 缺点：无法安全的将密钥传输给通信方

* 非对称加密：加密和解密使用不同的秘钥，一把作为公开的公钥，另一把作为私钥，**公钥公开给任何人**（类似于把锁和箱子给别人，对方打开箱子放入数据，上锁后发送），典型的非对称加密算法有 RSA、DSA 等

  * 公钥加密，私钥解密：为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容
  * 私钥加密，公钥解密：为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的
  * 可以更安全地将公开密钥传输给通信发送方，但是运算速度慢

* **使用对称加密和非对称加密的方式传送数据**

  * 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性
  * 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率

  思想：锁上加锁

名词解释：

* 哈希算法：通过哈希函数计算出内容的哈希值，传输到对端后会重新计算内容的哈希，进行哈希比对来校验内容的完整性

* 数字签名：附加在报文上的特殊加密校验码，可以防止报文被篡改。一般是通过私钥对内容的哈希值进行加密，公钥正常解密并对比哈希值后，可以确保该内容就是对端发出的，防止出现中间人替换的问题

* 数字证书：由权威机构给某网站颁发的一种认可凭证

HTTPS 工作流程：服务器端的公钥和私钥，用来进行非对称加密，客户端生成的随机密钥，用来进行对称加密

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP-HTTPS加密过程.png)

1. 客户端向服务器发起 HTTPS 请求，连接到服务器的 443 端口，请求携带了浏览器支持的加密算法和哈希算法，协商加密算法
2. 服务器端会向数字证书认证机构注册公开密钥，认证机构**用 CA 私钥**对公开密钥做数字签名后绑定在数字证书（又叫公钥证书，内容有公钥，网站地址，证书颁发机构，失效日期等）
3. 服务器将数字证书发送给客户端，私钥由服务器持有
4. 客户端收到服务器端的数字证书后**通过 CA 公钥**（事先置入浏览器或操作系统）对证书进行检查，验证其合法性。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，将该密钥称之为 client key（客户端密钥、会话密钥）。用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文，HTTPS 中的第一次 HTTP 请求结束
5. 客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端密钥发送给服务器
6. 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文
7. 服务器将加密后的密文发送给客户端
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据，这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成



参考文章：https://www.cnblogs.com/linianhui/p/security-https-workflow.html

参考文章：https://www.jianshu.com/p/14cd2c9d2cd2



****



## 请求部分

请求行： 永远位于请求的第一行

请求头： 从第二行开始，到第一个空行结束

请求体： 从第一个空行后开始，到正文的结束（GET 没有）

* 请求方式

  * POST

  ![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP请求部分.png)

  * GET

    ```html
    【请求行】
    GET /myApp/success.html?username=zs&password=123456 HTTP/1.1
    
    【请求头】
    Accept: text/html, application/xhtml+xml, */*; X-HttpWatch-RID: 41723-10011
    Referer: http://localhost:8080/myApp/login.html
    Accept-Language: zh-Hans-CN,zh-Hans;q=0.5
    User-Agent: Mozilla/5.0 (MSIE 9.0; qdesk 2.4.1266.203; Windows NT 6.3; WOW64; Trident/7.0; rv:11.0) like Gecko
    Accept-Encoding: gzip, deflate
    Host: localhost:8080
    Connection: Keep-Alive
    Cookie: Idea-b77ddca6=4bc282fe-febf-4fd1-b6c9-72e9e0f381e8
    ```

  * **GET 和 POST 比较**

    作用：GET 用于获取资源，而 POST 用于传输实体主体

    参数：GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中（GET 也有请求体，POST 也可以通过 URL 传输参数）。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看

    安全：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是安全的，而 POST 不是，因为 POST 的目的是传送实体主体内容

    * 安全的方法除了 GET 之外还有：HEAD、OPTIONS
    * 不安全的方法除了 POST 之外还有 PUT、DELETE

    幂等性：同样的请求**被执行一次与连续执行多次的效果是一样的**，服务器的状态也是一样的，所有的安全方法也都是幂等的。在正确实现条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，POST 方法不是

    可缓存：如果要对响应进行缓存，需要满足以下条件

    * 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存
    * 响应报文的状态码是可缓存的，包括：200、203、204、206、300、301、404、405、410、414 and 501
    * 响应报文的 Cache-Control 首部字段没有指定不进行缓存

  * PUT 和 POST 的区别

    PUT 请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉（幂等），所以 PUT 用来修改资源

    POST 请求：后一个请求不会把第一个请求覆盖掉（非幂等），所以 POST 用来创建资源

    PATCH 方法 是新引入的，是对 PUT 方法的补充，用来对已知资源进行**局部更新**

  

* 请求行详解

  ```html
  GET  /myApp/success.html?username=zs&password=123456 HTTP/1.1	
  POST /myApp/success.html HTTP/1.1
  ```

  | 内容                | 说明                       |
  | ------------------- | -------------------------- |
  | GET/POST            | 请求的方式。               |
  | /myApp/success.html | 请求的资源。               |
  | HTTP/1.1            | 使用的协议，及协议的版本。 |



* 请求头详解

  从第 2 行到空行处，都叫请求头，以键值对的形式存在，但存在一个 key 对应多个值的请求头

  | 内容              | 说明                                                         |
  | ----------------- | ------------------------------------------------------------ |
  | Accept            | 告知服务器，客户浏览器支持的 MIME 类型                       |
  | User-Agent        | 浏览器相关信息                                               |
  | Accept-Charset    | 告诉服务器，客户浏览器支持哪种字符集                         |
  | Accept-Encoding   | 告知服务器，客户浏览器支持的压缩编码格式，常用 gzip 压缩     |
  | Accept-Language   | 告知服务器，客户浏览器支持的语言，zh_CN 或 en_US 等          |
  | Host              | 初始 URL 中的主机和端口                                      |
  | Referer           | 告知服务器，当前请求的来源。只有当前请求有来源，才有这个消息头。<br/>作用：1 投放广告  2 防盗链 |
  | Content-Type      | 告知服务器，请求正文的 MIME 类型，文件传输的类型，<br/>application/x-www-form-urlencoded |
  | Content-Length    | 告知服务器，请求正文的长度。                                 |
  | Connection        | 表示是否需要持久连接，一般是 `Keep -Alive`（HTTP 1.1 默认进行持久连接 ) |
  | If-Modified-Since | 告知服务器，客户浏览器缓存文件的最后修改时间                 |
  | Cookie            | 会话管理相关（非常的重要）                                   |



* 请求体详解

  * 只有 POST 请求方式，才有请求的正文，GET 方式的正文是在地址栏中的

  * 表单的输入域有 name 属性的才会被提交，不分 GET 和 POST 的请求方式

  * 表单的 enctype 属性取值决定了请求正文的体现形式

    | enctype取值                       | 请求正文体现形式                                   | 示例                                                         |
    | --------------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
    | application/x-www-form-urlencoded | key=value&key=value                                | username=test&password=1234                                  |
    | multipart/form-data               | 此时变成了多部分表单数据。多部分是靠分隔符分隔的。 | -----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="username"<br/>test<br/>-----------------------------7df23a16c0210<br/>Content-Disposition: form-data; name="password"<br/>1234<br/>-------------------------------7df23a16c0210 |



***



## 响应部分

响应部分图：

![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP响应部分.png)



* 响应行

  HTTP/1.1：使用协议的版本

  200：响应状态码

  OK：状态码描述

  * 响应状态码：
    ![](https://seazean.oss-cn-beijing.aliyuncs.com/img/Web/HTTP状态响应码.png)

    | 状态码  | 说明                                               |
    | ------- | -------------------------------------------------- |
    | 200     | 一切都 OK，与服务器连接成功，发送请求成功          |
    | 302/307 | 请求重定向（客户端行为，两次请求，地址栏发生改变） |
    | 304     | 请求资源未改变，使用缓存                           |
    | 400     | 客户端错误，请求错误，最常见的就是请求参数有问题   |
    | 403     | 客户端错误，但 forbidden 权限不够，拒绝处理        |
    | 404     | 客户端错误，请求资源未找到                         |
    | 500     | 服务器错误，服务器运行内部错误                     |

  转移：

  * 301 redirect：301 代表永久性转移 (Permanently Moved)
  * 302 redirect：302 代表暂时性转移 (Temporarily Moved )

* 响应头：以 key:vaue 存在，可能多个 value 情况

  | 消息头                  | 说明                                                         |
  | ----------------------- | ------------------------------------------------------------ |
  | Location                | 请求重定向的地址，常与 302，307 配合使用。                   |
  | Server                  | 服务器相关信息                                               |
  | Content-Type            | 告知客户浏览器，响应正文的MIME类型                           |
  | Content-Length          | 告知客户浏览器，响应正文的长度                               |
  | Content-Encoding        | 告知客户浏览器，响应正文使用的压缩编码格式，常用的 gzip 压缩 |
  | Content-Language        | 告知客户浏览器，响应正文的语言，zh_CN 或 en_US 等            |
  | Content-Disposition     | 告知客户浏览器，以下载的方式打开响应正文                     |
  | Refresh                 | 客户端的刷新频率，单位是秒                                   |
  | Last-Modified           | 服务器资源的最后修改时间                                     |
  | Set-Cookie              | 服务器端发送的 Cookie，会话管理相关                          |
  | Expires:-1              | 服务器资源到客户浏览器后的缓存时间                           |
  | Catch-Control: no-catch | 不要缓存，//针对http协议1.1版本                              |
  | Pragma:no-catch         | 不要缓存，//针对http协议1.0版本                              |



* 响应体：页面展示内容, 类似网页的源码

  ```html
  <html>
      <head>
          <link rel="stylesheet" href="css.css" type="text/css">
          <script type="text/javascript" src="demo.js"></script>
      </head>
      <body>
          <img src="1.jpg" />
      </body>
  </html>
  ```

  



***

