import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as p,c as o,a,d as n,b as e,e as t}from"./app-109af9bf.js";const r={},d=t(`<h1 id="linux" tabindex="-1"><a class="header-anchor" href="#linux" aria-hidden="true">#</a> Linux</h1><h2 id="操作系统" tabindex="-1"><a class="header-anchor" href="#操作系统" aria-hidden="true">#</a> 操作系统</h2><p>操作系统（Operation System），是管理计算机硬件与软件资源的计算机程序，同时也是计算机系统的内核与基石。操作系统需要处理管理与配置内存、决定系统资源供需的优先次序、控制输入设备与输出设备、操作网络与管理文件系统等基本事务，操作系统也提供一个让用户与系统交互的操作界面</p><p>操作系统作为接口的示意图：</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/操作系统.png" style="zoom:80%;"><p>移动设备操作系统：</p><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/移动设备操作系统.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h2 id="linux系统" tabindex="-1"><a class="header-anchor" href="#linux系统" aria-hidden="true">#</a> Linux系统</h2><h3 id="系统介绍" tabindex="-1"><a class="header-anchor" href="#系统介绍" aria-hidden="true">#</a> 系统介绍</h3><p>从内到位依次是硬件 → 内核层 → Shell 层 → 应用层 → 用户<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/Linux系统.png" alt="Linux" loading="lazy"></p><p>内核层：核心和基础，附着在硬件平台上，控制和管理系统内的各种资源，有效的组织进程的运行，扩展硬件的功能，提高资源利用效率，为用户提供安全可靠的应用环境。</p><p>Shell 层：与用户直接交互的界面。用户可以在提示符下输入命令行，由 Shell 解释执行并输出相应结果或者有关信息，所以我们也把 Shell 称作命令解释器，利用系统提供的丰富命令可以快捷而简便地完成许多工作。</p><hr><h3 id="文件系统" tabindex="-1"><a class="header-anchor" href="#文件系统" aria-hidden="true">#</a> 文件系统</h3><p>Linux 文件系统目录结构和熟知的 windows 系统有较大区别，没有各种盘符的概念。根目录只有一个/，采用层级式的树状目录结构。</p><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/Linux文件系统.png" alt="Linux文件系统" tabindex="0" loading="lazy"><figcaption>Linux文件系统</figcaption></figure><hr><h2 id="远程连接" tabindex="-1"><a class="header-anchor" href="#远程连接" aria-hidden="true">#</a> 远程连接</h2><h3 id="设置ip" tabindex="-1"><a class="header-anchor" href="#设置ip" aria-hidden="true">#</a> 设置IP</h3><h4 id="nat" tabindex="-1"><a class="header-anchor" href="#nat" aria-hidden="true">#</a> NAT</h4><p>首先设置虚拟机中 NAT 模式的选项，打开 VMware，点击编辑下的虚拟网络编辑器，设置 NAT 参数<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/配置NAT.jpg" alt="" loading="lazy"></p><p><strong>注意</strong>：VMware Network Adapter VMnet8 保证是启用状态</p><p>​ <img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/本地主机网络连接.jpg" alt="" loading="lazy"></p><h4 id="静态ip" tabindex="-1"><a class="header-anchor" href="#静态ip" aria-hidden="true">#</a> 静态IP</h4><p>在普通用户下不能修改网卡的配置信息；所以我们要切换到 root 用户进行 ip 配置：su root/su</p><ul><li><p>修改网卡配置文件：<code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code></p></li><li><p>修改文件内容</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">TYPE</span><span class="token operator">=</span>Ethernet
<span class="token assign-left variable">PROXY_METHOD</span><span class="token operator">=</span>none
<span class="token assign-left variable">BROWSER_ONLY</span><span class="token operator">=</span>no
<span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>static
<span class="token assign-left variable">IPADDR</span><span class="token operator">=</span><span class="token number">10.2</span>.111.62
<span class="token assign-left variable">NETMASK</span><span class="token operator">=</span><span class="token number">255.255</span>.252.0
<span class="token assign-left variable">GATEWAY</span><span class="token operator">=</span><span class="token number">10.2</span>.111.254
<span class="token assign-left variable">DEFROUTE</span><span class="token operator">=</span>yes
<span class="token assign-left variable">IPV4_FAILURE_FATAL</span><span class="token operator">=</span>no
<span class="token assign-left variable">IPV6INIT</span><span class="token operator">=</span>yes
<span class="token assign-left variable">IPV6_AUTOCONF</span><span class="token operator">=</span>yes
<span class="token assign-left variable">IPV6_DEFROUTE</span><span class="token operator">=</span>yes
<span class="token assign-left variable">IPV6_FAILURE_FATAL</span><span class="token operator">=</span>no
<span class="token assign-left variable">IPV6_ADDR_GEN_MODE</span><span class="token operator">=</span>stable-privacy
<span class="token assign-left variable">NAME</span><span class="token operator">=</span>ens33
<span class="token assign-left variable">UUID</span><span class="token operator">=</span>2c2371f1-ef29-4514-a568-c4904bd11c82
<span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>ens33
<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>true
<span class="token comment">###########################</span>
BOOTPROTO设置为静态static
IPADDR设置ip地址
NETMASK设置子网掩码
GATEWAY设置网关
ONBOOT设置为true在系统启动时是否激活网卡
执行保存 :wq<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>重启网络：systemctl restart network</p></li><li><p>查看IP：ifconfig</p></li><li><p>宿主机 ping 虚拟机，虚拟机 ping 宿主机</p></li><li><p>在虚拟机中访问网络，需要增加一块 NAT 网卡</p><ul><li>【虚拟机】--【设置】--【添加】</li><li><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/两块NAT网卡.jpg" style="zoom:80%;"></li></ul></li></ul><hr><h3 id="远程登陆" tabindex="-1"><a class="header-anchor" href="#远程登陆" aria-hidden="true">#</a> 远程登陆</h3><p><strong>服务器维护工作</strong> 都是在 远程 通过 SSH 客户端 来完成的， 并没有图形界面， 所有的维护工作都需要通过命令来完成，Linux 服务器需要安装 SSH 相关服务</p><p>首先执行 sudo apt-get install openssh-server 指令，接下来用 xshell 连接</p><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/远程连接Linux.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>先用普通用户登录，然后转成 root</p><hr><h2 id="用户管理" tabindex="-1"><a class="header-anchor" href="#用户管理" aria-hidden="true">#</a> 用户管理</h2><p>Linux 系统是一个多用户、多任务的操作系统。多用户是指在 Linux 操作系统中可以创建多个用户，而这些多用户又可以同时执行各自不同的任务，而互不影响</p><p>在 Linux 系统中，会存在着以下几个概念：</p><ul><li>用户名：用户的名称</li><li>用户所属的组：当前用户所属的组</li><li>用户的家目录：当前账号登录成功之后的目录，就叫做该用户的家目录</li></ul><h3 id="用户管理-1" tabindex="-1"><a class="header-anchor" href="#用户管理-1" aria-hidden="true">#</a> 用户管理</h3><h4 id="当前用户" tabindex="-1"><a class="header-anchor" href="#当前用户" aria-hidden="true">#</a> 当前用户</h4><p>logname：用于显示目前用户的名称</p><ul><li><p>--help：在线帮助</p></li><li><p>--vesion：显示版本信息</p></li></ul><h4 id="切换用户" tabindex="-1"><a class="header-anchor" href="#切换用户" aria-hidden="true">#</a> 切换用户</h4><p>su UserName：切换用户</p><p>su -c comman root：切换用户为 root 并在执行 comman 指令后退出返回原使用者</p><p>su：切换到 root 用户</p><h4 id="用户添加" tabindex="-1"><a class="header-anchor" href="#用户添加" aria-hidden="true">#</a> 用户添加</h4><p>命令：useradd [options] 用户名</p><p>参数说明：</p><ul><li>-c comment 指定一段注释性描述</li><li>-d 指定用户主目录，如果此目录不存在，则同时使用 -m 选项，可以创建主目录</li><li>-m 创建用户的主目录</li><li>-g 用户组，指定用户所属的用户组</li><li>-G 用户组，用户组 指定用户所属的附加组</li><li>-s Shell 文件 指定用户的登录 Shell</li><li>-u 用户号，指定用户的用户号，如果同时有 -o 选项，则可以重复使用其他用户的标识号。</li></ul><p>如何知道添加用户成功呢？ 通过指令 cat /etc/passwd 查看</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>seazean:x:  1000:1000:Seazean:/home/seazean:/bin/bash
用户名 密码  用户ID 组ID   注释    家目录        shell程序
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>useradd -m Username 新建用户成功之后，会建立 home 目录，但是此时有问题没有指定 shell 的版本，不是我们熟知的 bash，功能上有很多限制，进行 <strong>sudo useradd -m -s /bin/bash Username</strong></p><h4 id="用户密码" tabindex="-1"><a class="header-anchor" href="#用户密码" aria-hidden="true">#</a> 用户密码</h4><p>系统安装好默认的 root 用户是没有密码的，需要给 root 设置一个密码 <strong>sudo passwd root</strong>.</p><ul><li><p>普通用户：<strong>sudo passwd UserName</strong></p></li><li><p>管理员用户：passwd [options] UserName</p><ul><li>-l：锁定密码，即禁用账号</li><li>-u：密码解锁</li><li>-d：使账号无密码</li><li>-f：强迫用户下次登录时修改密码</li></ul></li></ul><h4 id="用户权限" tabindex="-1"><a class="header-anchor" href="#用户权限" aria-hidden="true">#</a> 用户权限</h4><p>usermod 命令通过修改系统帐户文件来修改用户账户信息</p><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录 Shell 等</p><ul><li><p>普通用户：sudo usermod [options] Username</p></li><li><p>管理员用户：usermod [options] Username</p><ul><li>usermod <strong>-l</strong> newName Username</li><li>-l 新的登录名称</li></ul></li></ul><h4 id="用户删除" tabindex="-1"><a class="header-anchor" href="#用户删除" aria-hidden="true">#</a> 用户删除</h4><p>删除用户账号就是要将 /etc/passwd 等系统文件中的该用户记录删除，必要时还删除用户的主目录</p><ul><li><p>普通用户：sudo userdel [options] Username</p></li><li><p>管理员用户：userdel [options] Username</p><ul><li>-f：强制删除用户，即使用户当前已登录</li><li>-r：删除用户的同时，删除与用户相关的所有文件</li></ul></li></ul><hr><h3 id="用户组管理" tabindex="-1"><a class="header-anchor" href="#用户组管理" aria-hidden="true">#</a> 用户组管理</h3><h4 id="组管理" tabindex="-1"><a class="header-anchor" href="#组管理" aria-hidden="true">#</a> 组管理</h4><p>添加组：<strong>groupadd 组名</strong></p><p>创建用户的时加入组：useradd -m -g 组名 用户名<br> ​</p><h4 id="添加用户组" tabindex="-1"><a class="header-anchor" href="#添加用户组" aria-hidden="true">#</a> 添加用户组</h4><p>新增一个用户组（组名可见名知意，符合规范即可），然后将用户添加到组中，需要使用管理员权限</p><p>命令：groupadd [options] Groupname</p><ul><li>-g GID 指定新用户组的组标识号（GID）</li><li>-o 一般与 -g 选项同时使用，表示新用户组的 GID 可以与系统已有用户组的 GID 相同</li></ul><p>新增用户组 Seazean：groupadd Seazean</p><h4 id="修改用户组" tabindex="-1"><a class="header-anchor" href="#修改用户组" aria-hidden="true">#</a> 修改用户组</h4><p>需要使用管理员权限</p><p>命令：groupmod [options] Groupname</p><ul><li>-g GID 为用户组指定新的组标识号。</li><li>-o 与 -g 选项同时使用，用户组的新 GID 可以与系统已有用户组的 GID 相同</li><li>-n 新用户组 将用户组的名字改为新名字</li></ul><p>修改 Seazean 组名为 zhy：groupmod -n zhy Seazean</p><h4 id="删除用户组" tabindex="-1"><a class="header-anchor" href="#删除用户组" aria-hidden="true">#</a> 删除用户组</h4><ul><li><p>普通用户：sudo groupdel Groupname</p></li><li><p>管理员用户：groupdel Groupname</p><ul><li>-f 用户的主组也继续删除</li><li>-h 显示帮助信息</li></ul></li></ul><h4 id="用户所属组" tabindex="-1"><a class="header-anchor" href="#用户所属组" aria-hidden="true">#</a> 用户所属组</h4><p>查询用户所属组：groups Username</p><p>查看用户及组信息：id Username</p><p>创建用户的时加入组：useradd -m -g Groupname Username</p><p>修改用户所属组：usermod -g Groupname Username</p><p>usermod常用选项：</p><ul><li>-d 用户的新主目录</li><li>-l 新的登录名称</li></ul><h4 id="gpasswd" tabindex="-1"><a class="header-anchor" href="#gpasswd" aria-hidden="true">#</a> gpasswd</h4><p>gpasswd 是 Linux 工作组文件 /etc/group 和 /etc/gshadow 管理工具，用于将一个用户添加到组或从组中删除</p><p>命令：gpasswd 选项 Username Groupname</p><ul><li>-a 向组 GROUP 中添加用户 USER</li><li>-d 从组 GROUP 中添加或删除用户</li></ul><p><strong>查看用户组下所有用户（所有用户）</strong>：grep &#39;Groupname&#39; /etc/group</p><hr><h2 id="系统管理" tabindex="-1"><a class="header-anchor" href="#系统管理" aria-hidden="true">#</a> 系统管理</h2><h3 id="man" tabindex="-1"><a class="header-anchor" href="#man" aria-hidden="true">#</a> man</h3><p>在控制台输入：命令名 -h/ -help/ --h /空</p><p>可以看到命令的帮助文档</p><p><strong>man</strong> [指令名称]：查看帮助文档，比如 man ls，退出方式 q</p><hr><h3 id="date" tabindex="-1"><a class="header-anchor" href="#date" aria-hidden="true">#</a> date</h3><p>date 可以用来显示或设定系统的日期与时间</p><p>命令：date [options]</p><ul><li><p>-d&lt;字符串&gt;：显示字符串所指的日期与时间，字符串前后必须加上双引号；</p></li><li><p>-s&lt;字符串&gt;：根据字符串来设置日期与时间，字符串前后必须加上双引号</p></li><li><p>-u：显示 GMT</p></li><li><p>--version：显示版本信息</p></li></ul><p>查看时间：date → 2020年 11月 30日 星期一 17:10:54 CST</p><p>查看指定格式时间：date &quot;+%Y-%m-%d %H:%M:%S&quot; → 2020-11-30 17:11:44</p><p>设置日期指令：date -s “2019-12-23 19:21:00”</p><hr><h3 id="id" tabindex="-1"><a class="header-anchor" href="#id" aria-hidden="true">#</a> id</h3><p>id 会显示用户以及所属群组的实际与有效 ID，若两个 ID 相同则仅显示实际 ID；若仅指定用户名称，则显示目前用户的 ID</p><p>命令：id [-gGnru] [--help] [--version] [用户名称] //参数的顺序</p><ul><li>-g 或--group：显示用户所属群组的 ID</li><li>-G 或--groups：显示用户所属附加群组的 ID</li><li>-n 或--name：显示用户，所属群组或附加群组的名称。</li><li>-r 或--real：显示实际 ID</li><li>-u 或--user：显示用户 ID</li></ul><blockquote><p>id 命令参数虽然很多，但是常用的是不带参数的 id 命令，主要看 uid 和组信息</p></blockquote><hr><h3 id="sudo" tabindex="-1"><a class="header-anchor" href="#sudo" aria-hidden="true">#</a> sudo</h3><p>sudo：控制用户对系统命令的使用权限，通过 sudo 可以提高普通用户的操作权限</p><ul><li>-V 显示版本编号</li><li>-h 会显示版本编号及指令的使用方式说明</li><li>-l 显示出自己（执行 sudo 的使用者）的权限</li><li>-command 要以系统管理者身份（或以 -u 更改为其他人）执行的指令</li></ul><p><strong>sudo -u root command -l</strong>：指定 root 用户执行指令 command</p><hr><h3 id="top" tabindex="-1"><a class="header-anchor" href="#top" aria-hidden="true">#</a> top</h3><p>top：用于实时显示 process 的动态</p><ul><li><p>-c：command 属性进行了命令补全</p></li><li><p>-p 进程号：显示指定 pid 的进程信息</p></li><li><p>-d 秒数：表示进程界面更新时间（每几秒刷新一次）</p></li><li><p>-H 表示线程模式</p></li></ul><p><code>top -Hp 进程 id</code>：分析该进程内各线程的 CPU 使用情况</p><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/top命令.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>各进程（任务）的状态监控属性解释说明：</strong></p><ul><li>PID — 进程 id</li><li>TID — 线程 id</li><li>USER — 进程所有者</li><li>PR — 进程优先级</li><li>NI — nice 值，负值表示高优先级，正值表示低优先级</li><li>VIRT — 进程使用的虚拟内存总量，单位 kb，VIRT=SWAP+RES</li><li>RES — 进程使用的、未被换出的物理内存大小，单位 kb，RES=CODE+DATA</li><li>SHR — 共享内存大小，单位 kb</li><li>S — 进程状态，D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</li><li>%CPU — 上次更新到现在的 CPU 时间占用百分比</li><li>%MEM — 进程使用的物理内存百分比</li><li>TIME+ — 进程使用的 CPU 时间总计，单位 1/100 秒</li><li>COMMAND — 进程名称（命令名/命令行）</li></ul><hr><h3 id="ps" tabindex="-1"><a class="header-anchor" href="#ps" aria-hidden="true">#</a> ps</h3><p>Linux 系统中查看进程使用情况的命令是 ps 指令</p><p>命令：ps</p><ul><li>-e: 显示所有进程</li><li>-f: 全格式</li><li>a: 显示终端上的所有进程</li><li>u: 以用户的格式来显示进程信息</li><li>x: 显示后台运行的进程</li><li>-T：开启线程查看</li><li>-p：指定线程号</li></ul><p>一般常用格式为 ps -ef 或者 ps aux 两种。显示的信息大体一致，略有区别：</p><ul><li>如果想查看进程的 CPU 占用率和内存占用率，可以使用 aux</li><li>如果想查看进程的父进程 ID 和完整的 COMMAND 命令，可以使用 ef</li></ul><p><code>ps -T -p &lt;pid&gt;</code>：显示某个进程的线程</p><p><strong>ps 和 top 区别：</strong></p><ul><li><p>ps 命令：可以查看进程的瞬间信息，是系统在过去执行的进程的静态快照</p></li><li><p>top 命令：可以持续的监视进程的动态信息</p></li></ul><hr><h3 id="kill" tabindex="-1"><a class="header-anchor" href="#kill" aria-hidden="true">#</a> kill</h3><p>Linux kill 命令用于删除执行中的程序或工作，并不是让进程直接停止，而是给进程发一个信号，可以进入终止逻辑</p><p>命令：kill [-s &lt;信息名称或编号&gt;] [程序]　或　kill [-l &lt;信息编号&gt;]</p><ul><li>-l &lt;信息编号&gt;：若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称</li><li>-s &lt;信息名称或编号&gt;：指定要送出的信息</li><li>-KILL：强制杀死进程</li><li><strong>-9：彻底杀死进程（常用）</strong></li><li>[程序] 程序的 PID、PGID、工作编号</li></ul><p><code>kill 15642 </code>. <code>kill -KILL 15642</code>. <code>kill -9 15642</code></p><p>杀死指定用户所有进程：</p><ol><li><p>过滤出 user 用户进程 ：<code>kill -9 $(ps -ef | grep user) </code></p></li><li><p>直接杀死：<code>kill -u user</code></p></li></ol><hr><h3 id="shutdown" tabindex="-1"><a class="header-anchor" href="#shutdown" aria-hidden="true">#</a> shutdown</h3><p>shutdown 命令可以用来进行关闭系统，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机</p><p>普通用户：sudo shutdown [-t seconds] [-rkhncfF] time [message]</p><p>管理员用户：shutdown [-t seconds] [-rkhncfF] time [message]</p><ul><li>-t seconds：设定在几秒钟之后进行关机程序</li><li>-k：并不会真的关机，只是将警告讯息传送给所有使用者</li><li>-r：关机后重新开机</li><li>-h：关机后停机</li><li>-n：不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机</li><li>-c：取消目前已经进行中的关机动作</li><li>-f：关机时，不做 fcsk 动作（检查 Linux 档系统）</li><li>-F：关机时，强迫进行 fsck 动作</li><li>time：设定关机的时间</li><li>message：传送给所有使用者的警告讯息</li></ul><p>立即关机：<code>shutdown -h now</code> 或者 <code>shudown now</code></p><p>指定 1 分钟后关机并显示警告信息：<code>shutdown +1 &quot;System will shutdown after 1 minutes&quot; </code></p><p>指定 1 分钟后重启并发出警告信息：<code>shutdown –r +1 &quot;1分钟后关机重启&quot;</code></p><hr><h3 id="reboot" tabindex="-1"><a class="header-anchor" href="#reboot" aria-hidden="true">#</a> reboot</h3><p>reboot 命令用于用来重新启动计算机</p><p>命令：reboot [-n] [-w] [-d] [-f] [-i]</p><ul><li>-n：在重开机前不做将记忆体资料写回硬盘的动作</li><li>-w：并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里</li><li>-d：不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）</li><li>-f：强迫重开机，不呼叫 shutdown 这个指令</li><li>-i：在重开机之前先把所有网络相关的装置先停止</li></ul><hr><h3 id="who" tabindex="-1"><a class="header-anchor" href="#who" aria-hidden="true">#</a> who</h3><p>who 命令用于显示系统中有哪些使用者正在上面，显示的资料包含了使用者 ID、使用的终端机、上线时间、CPU 使用量、动作等等</p><p>命令：who - [husfV] [user]</p><ul><li>-H 或 --heading：显示各栏位的标题信息列（常用 <code>who -H</code>）</li><li>-i 或 -u 或 --idle：显示闲置时间，若该用户在前一分钟之内有进行任何动作，将标示成 <code>.</code> 号，如果该用户已超过 24 小时没有任何动作，则标示出 <code>old</code> 字符串</li><li>-m：此参数的效果和指定 <code>am i</code> 字符串相同</li><li>-q 或--count：只显示登入系统的帐号名称和总人数</li><li>-s：此参数将忽略不予处理，仅负责解决who指令其他版本的兼容性问题</li><li>-w 或-T或--mesg或--message或--writable：显示用户的信息状态栏</li><li>--help：在线帮助</li><li>--version：显示版本信息</li></ul><hr><h3 id="systemctl" tabindex="-1"><a class="header-anchor" href="#systemctl" aria-hidden="true">#</a> systemctl</h3><p>命令：systemctl [command] [unit]</p><ul><li><p>--version 查看版本号</p></li><li><p>start：立刻启动后面接的 unit</p></li><li><p>stop：立刻关闭后面接的 unit</p></li><li><p>restart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思</p></li><li><p>reload：不关闭 unit 的情况下，重新载入配置文件，让设置生效</p></li><li><p>status：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息</p></li><li><p>enable：设置下次开机时，后面接的 unit 会被启动</p></li><li><p>disable：设置下次开机时，后面接的 unit 不会被启动</p></li><li><p>is-active：目前有没有正在运行中</p></li><li><p>is-enable：开机时有没有默认要启用这个 unit</p></li><li><p>kill ：不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号</p></li><li><p>show：列出 unit 的配置</p></li><li><p>mask：注销 unit，注销后你就无法启动这个 unit 了</p></li><li><p>unmask：取消对 unit 的注销</p></li></ul><hr><h3 id="timedatectl" tabindex="-1"><a class="header-anchor" href="#timedatectl" aria-hidden="true">#</a> timedatectl</h3><p>timedatectl用于控制系统时间和日期。可以查询和更改系统时钟于设定，同时可以设定和修改时区信息。在实际开发过程中，系统时间的显示会和实际出现不同步；我们为了校正服务器时间、时区会使用timedatectl命令</p><p>timedatectl：显示系统的时间信息</p><p>timedatectl status：显示系统的当前时间和日期</p><p>timedatectl | grep Time：查看当前时区</p><p>timedatectl list-timezones：查看所有可用的时区</p><p>timedatectl set-timezone &quot;Asia/Shanghai&quot;：设置本地时区为上海</p><p>timedatectl set-ntp true/false：启用/禁用时间同步</p><p>timedatectl set-time &quot;2020-12-20 20:45:00&quot;：时间同步关闭后可以设定时间</p><p>NTP 即 Network Time Protocol（网络时间协议），是一个互联网协议，用于同步计算机之间的系统时钟，timedatectl 实用程序可以自动同步你的Linux系统时钟到使用NTP的远程服务器</p><hr><h3 id="clear" tabindex="-1"><a class="header-anchor" href="#clear" aria-hidden="true">#</a> clear</h3><p>clear 命令用于清除屏幕</p><p>通过执行 clear 命令，就可以把缓冲区的命令全部清理干净</p><hr><h3 id="exit" tabindex="-1"><a class="header-anchor" href="#exit" aria-hidden="true">#</a> exit</h3><p>exit 命令用于退出目前的 shell</p><p>执行 exit 可使 shell 以指定的状态值退出。若不设置状态值参数，则 shell 以预设值退出。状态值 0 代表执行成功，其他值代表执行失败；exit 也可用在 script，离开正在执行的 script，回到 shell</p><p>命令：exit [状态值]</p><ul><li><p>0 表示成功（Zero - Success）</p></li><li><p>非 0 表示失败（Non-Zero - Failure）</p></li><li><p>2 表示用法不当（Incorrect Usage）</p></li><li><p>127 表示命令没有找到（Command Not Found）</p></li><li><p>126 表示不是可执行的（Not an executable）</p></li><li><p>大于等于 128 信号产生</p></li></ul><hr><h2 id="文件管理" tabindex="-1"><a class="header-anchor" href="#文件管理" aria-hidden="true">#</a> 文件管理</h2><h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令" aria-hidden="true">#</a> 常用命令</h3><h4 id="ls" tabindex="-1"><a class="header-anchor" href="#ls" aria-hidden="true">#</a> ls</h4><p>ls命令相当于我们在Windows系统中打开磁盘、或者打开文件夹看到的目录以及文件的明细。</p><p>命令：ls [options] 目录名称</p><ul><li>-a ：全部的文件，连同隐藏档( 开头为 . 的文件) 一起列出来(常用)</li><li>-d ：仅列出目录本身，而不是列出目录内的文件数据(常用)</li><li>-l ：显示不隐藏的文件与文件夹的详细信息；(常用)</li><li><strong>ls -al = ll 命令</strong>：显示所有文件与文件夹的详细信息</li></ul><h4 id="pwd" tabindex="-1"><a class="header-anchor" href="#pwd" aria-hidden="true">#</a> pwd</h4><p>pwd 是 Print Working Directory 的缩写，也就是显示目前所在当前目录的命令</p><p>命令：pwd 选项</p><ul><li>-L 打印 $PWD 变量的值，如果它包含了当前的工作目录</li><li>-P 打印当前的物理路径，不带有任何的符号链接</li></ul><h4 id="cd" tabindex="-1"><a class="header-anchor" href="#cd" aria-hidden="true">#</a> cd</h4><p>cd 是 Change Directory 的缩写，这是用来变换工作目录的命令</p><p>命令：cd [相对路径或绝对路径]</p><ul><li>cd ~ ：表示回到根目录</li><li>cd .. ：返回上级目录</li></ul><ul><li><strong>相对路径</strong> 在输入路径时, 最前面不是以 <code>/</code> 开始的 , 表示相对<strong>当前目录</strong>所在的目录位置 <ul><li>例如： /usr/share/doc</li></ul></li><li><strong>绝对路径</strong> 在输入路径时, 最前面是以 <code>/</code> 开始的, 表示从<strong>根目录</strong>开始的具体目录位置 <ul><li>由 /usr/share/doc 到 /usr/share/man 时，可以写成： cd ../man</li><li>优点：定位准确, 不会因为 工作目录变化 而变化</li></ul></li></ul><h4 id="mkdir" tabindex="-1"><a class="header-anchor" href="#mkdir" aria-hidden="true">#</a> mkdir</h4><p>mkdir命令用于建立名称为 dirName 之子目录</p><p>命令：mkdir [-p] dirName</p><ul><li>-p 确保目录名称存在，不存在的就建一个，用来创建多级目录。</li></ul><p><code>mkdir -p aaa/bbb</code>：在 aaa 目录下，创建一个 bbb 的子目录。 若 aaa 目录原本不存在，则建立一个</p><h4 id="rmdir" tabindex="-1"><a class="header-anchor" href="#rmdir" aria-hidden="true">#</a> rmdir</h4><p>rmdir命令删除空的目录</p><p>命令：rmdir [-p] dirName</p><ul><li>-p 是当子目录被删除后使它也成为空目录的话，则顺便一并删除</li></ul><p><code>rmdir -p aaa/bbb</code>：在 aaa 目录中，删除名为 bbb 的子目录。若 bbb 删除后，aaa 目录成为空目录，则 aaa 同时也会被删除</p><h4 id="cp" tabindex="-1"><a class="header-anchor" href="#cp" aria-hidden="true">#</a> cp</h4><p>cp 命令主要用于复制文件或目录</p><p>命令：cp [options] source... directory</p><ul><li>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合</li><li>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式</li><li>-f：覆盖已经存在的目标文件而不给出提示</li><li>-i：与 -f 选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答 y 时目标文件将被覆盖</li><li>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中</li><li>-r/R：若给出的源文件是一个目录文件，此时将复制该目录下所有的<strong>子目录</strong>和文件</li><li>-l：不复制文件，只是生成链接文件</li></ul><p><code>cp –r aaa/* ccc</code>：复制 aaa 下的所有文件到 ccc，不加参数 -r 或者 -R，只复制文件，而略过目录</p><h4 id="rm" tabindex="-1"><a class="header-anchor" href="#rm" aria-hidden="true">#</a> rm</h4><p>rm命令用于删除一个文件或者目录。</p><p>命令：rm [options] name...</p><ul><li>-i 删除前逐一询问确认。</li><li>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认</li><li>-r 将目录及以下之档案亦逐一删除，递归删除</li></ul><p>注：文件一旦通过 rm 命令删除，则无法恢复，所以必须格外小心地使用该命令</p><h4 id="mv" tabindex="-1"><a class="header-anchor" href="#mv" aria-hidden="true">#</a> mv</h4><p>mv 命令用来为文件或目录改名、或将文件或目录移入其它位置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mv</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token builtin class-name">source</span> dest
<span class="token function">mv</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> source<span class="token punctuation">..</span>. directory
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>-i：若指定目录已有同名文件，则先询问是否覆盖旧文件</p></li><li><p>-f：在 mv 操作要覆盖某已有的目标文件时不给任何指示</p><table><thead><tr><th>命令格式</th><th>运行结果</th></tr></thead><tbody><tr><td>mv 文件名 文件名</td><td>将源文件名改为目标文件名</td></tr><tr><td>mv 文件名 目录名</td><td>将文件移动到目标目录</td></tr><tr><td>mv 目录名 目录名</td><td>目标目录已存在，将源目录移动到目标目录。目标目录不存在则改名</td></tr><tr><td>mv 目录名 文件名</td><td>出错</td></tr></tbody></table></li></ul><hr><h3 id="文件属性" tabindex="-1"><a class="header-anchor" href="#文件属性" aria-hidden="true">#</a> 文件属性</h3><h4 id="基本属性" tabindex="-1"><a class="header-anchor" href="#基本属性" aria-hidden="true">#</a> 基本属性</h4><p>Linux 系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定</p><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/用户目录下的文件.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在Linux中第一个字符代表这个文件是目录、文件或链接文件等等。</p><ul><li>当为 d 则是目录</li><li>当为 - 则是文件</li><li>若是 l 则表示为链接文档 link file</li><li>若是 b 则表示为装置文件里面的可供储存的接口设备(可随机存取装置)</li><li>若是 c 则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)</li></ul><p>接下来的字符，以三个为一组，均为[rwx] 的三个参数组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现[ - ]。</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/文件权限.png" style="zoom:50%;"><p>从左至右用 0-9 这些数字来表示：</p><ul><li>第 0 位确定文件类型</li><li>第 1-3 位确定属主拥有该文件的权限</li><li>第 4-6 位确定属组拥有该文件的权限</li><li>第 7-9 位确定其他用户拥有该文件的权限</li></ul><hr><h4 id="文件信息" tabindex="-1"><a class="header-anchor" href="#文件信息" aria-hidden="true">#</a> 文件信息</h4><p>对于一个文件，都有一个特定的所有者，也就是对该文件具有所有权的用户（属主）；还有这个文件是属于哪个组的（属组）</p><ul><li>文件的【属主】有一套【读写执行权限rwx】</li><li>文件的【属组】有一套【读写执行权限rwx】</li></ul><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/列出目录文件.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>ls -l</code> 可以查看文件夹下文件的详细信息, 从左到右 依次是:</p><ul><li>权限（A 区域）： 第一个字符如果是 <code>d</code> 表示目录</li><li>硬链接数（B 区域）：通俗的讲就是有多少种方式, 可以访问当前目录和文件</li><li>属主（C 区域）：文件是所有者、或是叫做属主</li><li>属组（D 区域）： 文件属于哪个组</li><li>大小（E 区域）：文件大小</li><li>时间（F 区域）：最后一次访问时间</li><li>名称（G 区域）：文件的名称</li></ul><hr><h4 id="更改权限" tabindex="-1"><a class="header-anchor" href="#更改权限" aria-hidden="true">#</a> 更改权限</h4><h5 id="权限概述" tabindex="-1"><a class="header-anchor" href="#权限概述" aria-hidden="true">#</a> 权限概述</h5><p>Linux 文件属性有两种设置方法，一种是数字，一种是符号</p><p>Linux 的文件调用权限分为三级 : 文件属主、属组、其他，利用 chmod 可以控制文件如何被他人所调用。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">chmod</span> <span class="token punctuation">[</span>-cfvR<span class="token punctuation">]</span> <span class="token punctuation">[</span>--help<span class="token punctuation">]</span> <span class="token punctuation">[</span>--version<span class="token punctuation">]</span> mode file<span class="token punctuation">..</span>.
mode <span class="token builtin class-name">:</span> 权限设定字串,格式: <span class="token punctuation">[</span>ugoa<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">[</span>+-<span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">[</span>rwxX<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">[</span>,<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>u 表示档案的拥有者，g 表示与该档案拥有者属于同一个 group 者，o 表示其他的人，a 表示这三者皆是</p></li><li><p>+表示增加权限、- 表示取消权限、= 表示唯一设定权限</p></li><li><p>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有该档案是个子目录或者该档案已经被设定过为可执行</p></li></ul><h5 id="数字权限" tabindex="-1"><a class="header-anchor" href="#数字权限" aria-hidden="true">#</a> 数字权限</h5><p>命令：chmod [-R] xyz 文件或目录</p><ul><li>xyz : 就是刚刚提到的数字类型的权限属性，为 rwx 属性数值的相加</li><li>-R : 进行递归（recursive）的持续变更，亦即连同次目录下的所有文件都会变更</li></ul><p>文件的权限字符为：[-rwxrwxrwx]， 这九个权限是三三一组的，我们使用数字来代表各个权限</p><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/权限数字表.png" style="zoom:67%;"><p>各权限的数字对照表：[r]:4、[w]:2、[x]:1、[-]:0</p><p>每种身份（owner/group/others）的三个权限（r/w/x）分数是需要累加的，例如权限为：[-rwxrwx---] 分数是</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= --- = 0+0+0 = 0</li></ul><p>表示为：<code>chmod -R 770 文件名</code></p><h5 id="符号权限" tabindex="-1"><a class="header-anchor" href="#符号权限" aria-hidden="true">#</a> 符号权限</h5><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/权限符号表.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>user 属主权限</li><li>group 属组权限</li><li>others 其他权限</li><li>all 全部的身份</li></ul><p>我们就可以使用 <strong>u g o a</strong> 来代表身份的权限，读写的权限可以写成 <strong>r w x</strong></p><p><code>chmod u=rwx,g=rx,o=r a.txt</code>：将as.txt的权限设置为 <strong>-rwxr-xr--</strong></p><p><code> chmod a-r a.txt</code>：将文件的所有权限去除 <strong>r</strong></p><hr><h4 id="更改属组" tabindex="-1"><a class="header-anchor" href="#更改属组" aria-hidden="true">#</a> 更改属组</h4><p>chgrp 命令用于变更文件或目录的所属群组</p><p>文件或目录权限的的拥有者由所属群组来管理，可以使用 chgrp 指令去变更文件与目录的所属群组</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">chgrp</span> <span class="token punctuation">[</span>-cfhRv<span class="token punctuation">]</span><span class="token punctuation">[</span>--help<span class="token punctuation">]</span><span class="token punctuation">[</span>--version<span class="token punctuation">]</span><span class="token punctuation">[</span>所属群组<span class="token punctuation">]</span><span class="token punctuation">[</span>文件或目录<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token function">chgrp</span> <span class="token punctuation">[</span>-cfhRv<span class="token punctuation">]</span><span class="token punctuation">[</span>--help<span class="token punctuation">]</span><span class="token punctuation">[</span>--reference<span class="token operator">=</span><span class="token operator">&lt;</span>参考文件或目录<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>--version<span class="token punctuation">]</span><span class="token punctuation">[</span>文件或目录<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>chgrp -v root aaa：将文件 aaa 的属组更改成 root（其他也可以）</p><hr><h4 id="更改属主" tabindex="-1"><a class="header-anchor" href="#更改属主" aria-hidden="true">#</a> 更改属主</h4><p>利用 chown 可以将档案的拥有者加以改变。</p><p>使用权限 : 管理员账户</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">chown</span> <span class="token punctuation">[</span>–R<span class="token punctuation">]</span> 属主名 文件名
<span class="token function">chown</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> 属主名:属组名 文件名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>chown root aaa：将文件aaa的属主更改成root</p><p>chown seazean:seazean aaa：将文件aaa的属主和属组更改为seazean</p><hr><h3 id="文件操作" tabindex="-1"><a class="header-anchor" href="#文件操作" aria-hidden="true">#</a> 文件操作</h3><h4 id="touch" tabindex="-1"><a class="header-anchor" href="#touch" aria-hidden="true">#</a> touch</h4><p>touch 命令用于创建文件、修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">touch</span> <span class="token punctuation">[</span>-acfm<span class="token punctuation">]</span><span class="token punctuation">[</span>-d<span class="token operator">&lt;</span>日期时间<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-r<span class="token operator">&lt;</span>参考文件或目录<span class="token operator">&gt;</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>-t<span class="token operator">&lt;</span>日期时间<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>--help<span class="token punctuation">]</span><span class="token punctuation">[</span>--version<span class="token punctuation">]</span><span class="token punctuation">[</span>文件或目录…<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-a 改变档案的读取时间记录</li><li>-m 改变档案的修改时间记录</li><li>-c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样</li><li>-f 不使用，是为了与其他 unix 系统的相容性而保留</li><li>-r 使用参考档的时间记录，与 --file 的效果一样</li><li>-d 设定时间与日期，可以使用各种不同的格式</li><li>-t 设定档案的时间记录，格式与 date 指令相同</li><li>--no-create 不会建立新档案</li><li>--help 列出指令格式</li><li>--version 列出版本讯息</li></ul><p><code>touch t.txt</code>：创建 t.txt 文件</p><p><code>touch t{1..10}.txt</code>：创建10 个名为 t1.txt 到 t10.txt 的空文件</p><p><code>touch t.txt</code>：更改 t.txt 的访问时间为现在</p><h4 id="stat" tabindex="-1"><a class="header-anchor" href="#stat" aria-hidden="true">#</a> stat</h4><p>stat 命令用于显示 inode 内容</p><p>命令：stat [文件或目录]</p><h4 id="cat" tabindex="-1"><a class="header-anchor" href="#cat" aria-hidden="true">#</a> cat</h4><p>cat 是一个文本文件查看和连接工具，<strong>用于小文件</strong></p><p>命令：cat [-AbeEnstTuv] [--help] [--version] Filename</p><ul><li>-n 显示文件加上行号</li><li>-b 和 -n 相似，只不过对于空白行不编号</li></ul><h4 id="less" tabindex="-1"><a class="header-anchor" href="#less" aria-hidden="true">#</a> less</h4><p>less 用于查看文件，但是 less 在查看之前不会加载整个文件，<strong>用于大文件</strong></p><p>命令：less [options] Filename</p><ul><li>-N 显示每行行号</li></ul><h4 id="tail" tabindex="-1"><a class="header-anchor" href="#tail" aria-hidden="true">#</a> tail</h4><p>tail 命令可用于查看文件的内容，有一个常用的参数 <strong>-f</strong> 常用于查阅正在改变的日志文件</p><p>命令：tail [options] Filename</p><ul><li>-f 循环读取,动态显示文档的最后内容</li><li>-n 显示文件的尾部 n 行内容</li><li>-c 显示字节数</li><li>-nf 查看最后几行日志信息</li></ul><p><code>tail -f filename</code>：动态显示最尾部的内容</p><p><code>tail -n +2 txtfile.txt</code>：显示文件 txtfile.txt 的内容，从第 2 行至文件末尾</p><p><code>tail -n 2 txtfile.txt</code>：显示文件 txtfile.txt 的内容，最后 2 行</p><h4 id="head" tabindex="-1"><a class="header-anchor" href="#head" aria-hidden="true">#</a> head</h4><p>head 命令可用于查看文件的开头部分的内容，有一个常用的参数 <strong>-n</strong> 用于显示行数，默认为 10</p><ul><li>-q 隐藏文件名</li><li>-v 显示文件名</li><li>-c 显示的字节数</li><li>-n 显示的行数</li></ul><p><code>head -n Filename</code>：查看文件的前一部分</p><p><code>head -n 20 Filename</code>：查看文件的前 20 行</p><h4 id="grep" tabindex="-1"><a class="header-anchor" href="#grep" aria-hidden="true">#</a> grep</h4><p>grep 指令用于查找内容包含指定的范本样式的文件，若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">grep</span> <span class="token punctuation">[</span>-abcEFGhHilLnqrsvVwxy<span class="token punctuation">]</span><span class="token punctuation">[</span>-A<span class="token operator">&lt;</span>显示列数<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-B<span class="token operator">&lt;</span>显示列数<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-C<span class="token operator">&lt;</span>显示列数<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-d<span class="token operator">&lt;</span>进行动作<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-e<span class="token operator">&lt;</span>范本样式<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-f<span class="token operator">&lt;</span>范本文件<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>--help<span class="token punctuation">]</span><span class="token punctuation">[</span>范本样式<span class="token punctuation">]</span><span class="token punctuation">[</span>文件或目录<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-c 只输出匹配行的计数</li><li>-i 不区分大小写</li><li>-h 查询多文件时不显示文件名</li><li>-l 查询多文件时只输出包含匹配字符的文件名</li><li>-n 显示匹配行及行号</li><li>-s 不显示不存在或无匹配文本的错误信息</li><li>-v 显示不包含匹配文本的所有行</li><li>--color=auto 可以将找到的关键词部分加上颜色的显示</li></ul><p><strong>管道符 |</strong>：表示将前一个命令处理的结果传递给后面的命令处理</p><ul><li><code>grep aaaa Filename </code>：显示存在关键字 aaaa 的行</li><li><code>grep -n aaaa Filename</code>：显示存在关键字 aaaa 的行，且显示行号</li><li><code>grep -i aaaa Filename</code>：忽略大小写，显示存在关键字 aaaa 的行</li><li><code>grep -v aaaa Filename</code>：显示存在关键字 aaaa 的所有行</li><li><code>ps -ef | grep sshd</code>：查找包含 sshd 进程的进程信息</li><li><code> ps -ef | grep -c sshd</code>：查找 sshd 相关的进程个数</li></ul><h4 id="echo" tabindex="-1"><a class="header-anchor" href="#echo" aria-hidden="true">#</a> echo</h4><p>将字符串输出到控制台 , 通常和重定向联合使用</p><p>命令：echo string，如果字符串有空格, 为了避免歧义 请增加 双引号 或者 单引号</p><ul><li>通过 <code>命令 &gt; 文件</code> 将命令的成功结果覆盖指定文件内容</li><li>通过 <code>命令 &gt;&gt; 文件</code> 将命令的成功结果追加指定文件的后面</li><li>通过 <code>命令 &amp;&gt;&gt; 文件</code> 将 命令的失败结果追加指定文件的后面</li></ul><p><code>echo &quot;程序员&quot; &gt;&gt; a.txt</code>：将程序员追加到 a.txt 后面</p><p><code>cat 不存在的目录 &amp;&gt;&gt; error.log</code>：将错误信息追加到 error.log 文件</p><h4 id="awk" tabindex="-1"><a class="header-anchor" href="#awk" aria-hidden="true">#</a> awk</h4><p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">awk</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token string">&#39;script&#39;</span> <span class="token assign-left variable">var</span><span class="token operator">=</span>value file<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token function">awk</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token parameter variable">-f</span> scriptfile <span class="token assign-left variable">var</span><span class="token operator">=</span>value file<span class="token punctuation">(</span>s<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>-F fs：指定输入文件折分隔符，fs 是一个字符串或者是一个正则表达式</p></li><li><p>-v：var=value 赋值一个用户定义变量</p></li><li><p>-f：从脚本文件中读取 awk 命令</p></li><li><p>$n：获取<strong>第几段</strong>内容</p></li><li><p>$0：获取<strong>当前行</strong> 内容</p></li><li><p>NF：表示当前行共有多少个字段</p></li><li><p>$NF：代表最后一个字段</p></li><li><p>$(NF-1)：代表倒数第二个字段</p></li><li><p>NR：代表处理的是第几行</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>命令：awk <span class="token string">&#39;BEGIN{初始化操作}{每行都执行} END{结束时操作}&#39;</span>   
文件名BEGIN<span class="token punctuation">{</span> 这里面放的是执行前的语句 <span class="token punctuation">}</span><span class="token punctuation">{</span>这里面放的是处理每一行时要执行的语句<span class="token punctuation">}</span>
END <span class="token punctuation">{</span>这里面放的是处理完所有的行后要执行的语句 <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><div class="language-a.txt line-numbers-mode" data-ext="a.txt"><pre class="language-a.txt"><code>//准备数据
zhangsan 68 99 26
lisi 98 66 96
wangwu 38 33 86
zhaoliu 78 44 36
maq 88 22 66
zhouba 98 44 46
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>cat a.txt | awk &#39;/zhang|li/&#39;</code>：搜索含有 zhang 和 li 的学生成绩</p></li><li><p><code>awk &quot;/zhang|li/&quot; a.txt </code>：同上一个命令，效果一样</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>zhangsan 68 99 26
lisi 98 66 96
zhaoliu 78 44 36
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>cat a.txt | awk -F &#39; &#39; &#39;{print $1,$2,$3}&#39;</code>：按照空格分割，打印 一二三列内容</p></li><li><p><code>awk -F &#39; &#39; &#39;{OFS=&quot;\\t&quot;}{print $1,$2,$3}&#39;</code>：按照制表符 tab 进行分割，打印一二三列<br> \\b：退格 \\f：换页 \\n：换行 \\r：回车 \\t：制表符</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>zhangsan	68	99
lisi	98	66
wangwu	38	33
zhaoliu	78	44
maq	88	22
zhouba	98	44
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><code>awk -F &#39;,&#39; &#39;{print toupper($1)}&#39; a.txt</code>：根据逗号分割，打印内容，第一段大写</p><table><thead><tr><th>函数名</th><th>含义</th><th>作用</th></tr></thead><tbody><tr><td>toupper()</td><td>upper</td><td>字符 转成 大写</td></tr><tr><td>tolower()</td><td>lower</td><td>字符 转成小写</td></tr><tr><td>length()</td><td>length</td><td>返回 字符长度</td></tr></tbody></table></li><li><p><code>awk -F &#39; &#39; &#39;BEGIN{}{total=total+$4} END{print total}&#39; a.txt</code>：计算的是第4列的总分</p></li><li><p><code>awk -F &#39; &#39; &#39;BEGIN{}{total=total+$4} END{print total, NR}&#39; a.txt</code> ：查看总分, 总人数</p></li><li><p><code>awk -F &#39; &#39; &#39;BEGIN{}{total=total+$4} END{print total, NR, (total/NR)}&#39; a.txt</code>：查看总分, 总人数，平均数</p></li><li><p><code>cat a.txt | awk -F &#39; &#39; &#39;BEGIN{}{total=total+$4} END{print total}&#39; </code>：可以这样写</p></li></ul><h4 id="find" tabindex="-1"><a class="header-anchor" href="#find" aria-hidden="true">#</a> find</h4><p>find 命令用来在指定目录下查找文件，如果使用该命令不设置任何参数，将在当前目录下查找子目录与文件，并且将查找到的子目录和文件全部进行显示</p><p>命令：find &lt;指定目录&gt; &lt;指定条件&gt; &lt;指定内容&gt;</p><ul><li><code>find . -name &quot;*.gz&quot;</code>：将目前目录及其子目录下所有延伸档名是 gz 的文件查询出来</li><li><code>find . -ctime -1</code>：将目前目录及其子目录下所有最近 1 天内更新过的文件查询出来</li><li><code> find / -name &#39;seazean&#39;</code>：全局搜索 seazean</li></ul><h4 id="read" tabindex="-1"><a class="header-anchor" href="#read" aria-hidden="true">#</a> read</h4><p>read 命令用于从标准输入读取数值</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">read</span> <span class="token punctuation">[</span>-ers<span class="token punctuation">]</span> <span class="token punctuation">[</span>-a aname<span class="token punctuation">]</span> <span class="token punctuation">[</span>-d delim<span class="token punctuation">]</span> <span class="token punctuation">[</span>-i text<span class="token punctuation">]</span> <span class="token punctuation">[</span>-n nchars<span class="token punctuation">]</span> <span class="token punctuation">[</span>-N nchars<span class="token punctuation">]</span> <span class="token punctuation">[</span>-p prompt<span class="token punctuation">]</span> <span class="token punctuation">[</span>-t timeout<span class="token punctuation">]</span> <span class="token punctuation">[</span>-u fd<span class="token punctuation">]</span> <span class="token punctuation">[</span>name <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="sort" tabindex="-1"><a class="header-anchor" href="#sort" aria-hidden="true">#</a> sort</h4><p>Linux sort 命令用于将文本文件内容加以排序</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sort</span> <span class="token punctuation">[</span>-bcdfimMnr<span class="token punctuation">]</span><span class="token punctuation">[</span>文件<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-n 依照数值的大小排序</li><li>-r 以相反的顺序来排序（sort 默认的排序方式是<strong>升序</strong>，改成降序，加 -r）</li><li>-u 去掉重复</li></ul><p>面试题：一列数字，输出最大的 4 个不重复的数</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sort</span> <span class="token parameter variable">-ur</span> a.txt <span class="token operator">|</span> <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">4</span>
<span class="token function">sort</span> <span class="token parameter variable">-r</span> a.txt <span class="token operator">|</span> <span class="token function">uniq</span> <span class="token operator">|</span>  <span class="token function">head</span> <span class="token parameter variable">-n</span> <span class="token number">4</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="uniq" tabindex="-1"><a class="header-anchor" href="#uniq" aria-hidden="true">#</a> uniq</h4><p>uniq 用于重复数据处理，使用前先 sort 排序</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">uniq</span> <span class="token punctuation">[</span>OPTION<span class="token punctuation">]</span><span class="token punctuation">..</span>. <span class="token punctuation">[</span>INPUT <span class="token punctuation">[</span>OUTPUT<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-c 在数据行前出现的次数</li><li>-d 只打印重复的行，重复的行只显示一次</li><li>-D 只打印重复的行，重复的行出现多少次就显示多少次</li><li>-f 忽略行首的几个字段</li><li>-i 忽略大小写</li><li>-s 忽略行首的几个字母</li><li>-u 只打印唯一的行</li><li>-w 比较不超过 n 个字母</li></ul><hr><h3 id="文件压缩" tabindex="-1"><a class="header-anchor" href="#文件压缩" aria-hidden="true">#</a> 文件压缩</h3><h4 id="tar" tabindex="-1"><a class="header-anchor" href="#tar" aria-hidden="true">#</a> tar</h4><p>tar 的主要功能是打包、压缩和解压文件，tar 本身不具有压缩功能，是调用压缩功能实现的。</p><p>命令：tar [必要参数] [选择参数] [文件]</p><ul><li>-c 产生 .tar 文件</li><li>-v 显示详细信息</li><li>-z 打包同时压缩</li><li>-f 指定压缩后的文件名</li><li>-x 解压 .tar 文件</li><li>-t 列出 tar 文件中包含的文件的信息</li><li>-r 附加新的文件到tar文件中</li></ul><p><code>tar -cvf txt.tar txtfile.txt </code>：将 txtfile.txt 文件打包（仅打包，不压缩）</p><p><code>tar -zcvf combine.tar.gz 1.txt 2.txt 3.txt</code>：将 123.txt 文件打包压缩（gzip）</p><p><code>tar -ztvf txt.tar.gz</code>：查看 tar 中有哪些文件</p><p><code>tar -zxvf Filename -C 目标路径</code>：解压</p><h4 id="gzip" tabindex="-1"><a class="header-anchor" href="#gzip" aria-hidden="true">#</a> gzip</h4><p>gzip命令用于压缩文件。</p><p>gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出&quot;.gz&quot;的扩展名</p><ul><li>gzip * ：压缩目录下的所有文件，删除源文件。不支持直接压缩目录</li><li>gzip -rv 目录名：递归压缩目录</li><li>gzip -dv *：解压文件并列出详细信息</li></ul><h4 id="gunzip" tabindex="-1"><a class="header-anchor" href="#gunzip" aria-hidden="true">#</a> gunzip</h4><p>gunzip命令用于解压文件。用于解开被gzip压缩过的文件</p><p>命令：gunzip [options] [文件或者目录]</p><p>gunzip 001.gz ：解压001.gz文件</p><h4 id="zip" tabindex="-1"><a class="header-anchor" href="#zip" aria-hidden="true">#</a> zip</h4><p>zip 命令用于压缩文件。</p><p>zip 是个使用广泛的压缩程序，文件经它压缩后会另外产生具有 <code>.zip</code> 扩展名的压缩文件</p><p>命令：zip [必要参数] [选择参数] [文件]</p><ul><li>-q 不显示指令执行过程</li><li>-r 递归处理，将指定目录下的所有文件和子目录一并处理</li></ul><p><code>zip -q -r z.zip *</code>：将该目录的文件全部压缩</p><h4 id="unzip" tabindex="-1"><a class="header-anchor" href="#unzip" aria-hidden="true">#</a> unzip</h4><p>unzip 命令用于解压缩 zip 文件，unzip 为 <code>.zip</code> 压缩文件的解压缩程序</p><p>命令：unzip [必要参数] [选择参数] [文件]</p><ul><li><p>-l 查看压缩文件内所包含的文件</p></li><li><p>-d&lt;目录&gt; 指定文件解压缩后所要存储的目录。</p></li></ul><p><code>unzip -l z.zip</code> ：查看压缩文件中包含的文件</p><p><code>unzip -d ./unFiles z.zip</code>：把文件解压到指定的目录下</p><h4 id="bzip2" tabindex="-1"><a class="header-anchor" href="#bzip2" aria-hidden="true">#</a> bzip2</h4><p>bzip2 命令是 <code>.bz2</code> 文件的压缩程序。</p><p>bzip2 采用新的压缩演算法，压缩效果比传统的 LZ77/LZ78 压缩演算法好，若不加任何参数，bzip2 压缩完文件后会产生 .bz2 的压缩文件，并删除原始的文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">bzip2</span> <span class="token punctuation">[</span>-cdfhkLstvVz<span class="token punctuation">]</span><span class="token punctuation">[</span>--repetitive-best<span class="token punctuation">]</span><span class="token punctuation">[</span>--repetitive-fast<span class="token punctuation">]</span><span class="token punctuation">[</span>- 压缩等级<span class="token punctuation">]</span><span class="token punctuation">[</span>要压缩的文件<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>压缩：bzip2 a.txt</p><h4 id="bunzip2" tabindex="-1"><a class="header-anchor" href="#bunzip2" aria-hidden="true">#</a> bunzip2</h4><p>bunzip2 命令是 <code>.bz2</code> 文件的解压缩程序。</p><p>命令：bunzip2 [-fkLsvV] [.bz2压缩文件]</p><ul><li>-v　解压缩文件时，显示详细的信息。</li></ul><p>解压：bunzip2 -v a.bz2</p><hr><h3 id="文件编辑" tabindex="-1"><a class="header-anchor" href="#文件编辑" aria-hidden="true">#</a> 文件编辑</h3><h4 id="vim" tabindex="-1"><a class="header-anchor" href="#vim" aria-hidden="true">#</a> Vim</h4><p>vim：是从 vi 发展出来的一个文本编辑器</p><ul><li>命令模式：在 Linux 终端中输入<code>vim 文件名</code> 就进入了命令模式，但不能输入文字</li><li>编辑模式：在命令模式下按 <code>i</code> 就会进入编辑模式，此时可以写入程式，按 Esc 可回到命令模式</li><li>末行模式：在命令模式下按 <code>:</code> 进入末行模式，左下角会有一个冒号，可以敲入命令并执行</li></ul><h4 id="打开文件" tabindex="-1"><a class="header-anchor" href="#打开文件" aria-hidden="true">#</a> 打开文件</h4><p>Ubuntu 默认没有安装 vim，需要先安装 vim，安装命令：<strong>sudo apt-get install vim</strong></p><p>Vim 有三种模式：命令模式（Command mode）、插入模式（Insert mode）、末行模式（Last Line mode）</p><table><thead><tr><th style="text-align:center;">Vim 使用的选项</th><th style="text-align:center;">说明</th><th style="text-align:center;">常用</th></tr></thead><tbody><tr><td style="text-align:center;">vim filename</td><td style="text-align:center;">打开或新建一个文件，将光标置于第一行首部</td><td style="text-align:center;">常用</td></tr><tr><td style="text-align:center;">vim -r filename</td><td style="text-align:center;">恢复上次vim打开时崩溃的文件</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">vim -R filename</td><td style="text-align:center;">把指定的文件以只读的方式放入Vim编辑器</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">vim + filename</td><td style="text-align:center;">打开文件，将光标置于最后一行的首部</td><td style="text-align:center;">常用</td></tr><tr><td style="text-align:center;">vim +n filename</td><td style="text-align:center;">打开文件，将光标置于n行的首部</td><td style="text-align:center;">常用</td></tr><tr><td style="text-align:center;">vim +/pattern filename</td><td style="text-align:center;">打开文件，将光标置于第一个与pattern匹配的位置</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">vim -c command filename</td><td style="text-align:center;">对文件编辑前，先执行指定的命令</td><td style="text-align:center;"></td></tr></tbody></table><hr><h4 id="插入模式" tabindex="-1"><a class="header-anchor" href="#插入模式" aria-hidden="true">#</a> 插入模式</h4><p>在命令模式下，通过按下 i、I、a、A、o、O 这 6 个字母进入插入模式</p><table><thead><tr><th style="text-align:center;">快捷键</th><th style="text-align:center;">功能描述</th></tr></thead><tbody><tr><td style="text-align:center;">i</td><td style="text-align:center;">在光标所在位置插入文本，光标后的文本向右移动</td></tr><tr><td style="text-align:center;">I</td><td style="text-align:center;">在光标所在行的行首插入文本，行首是该行的第一个非空白字符</td></tr><tr><td style="text-align:center;">o</td><td style="text-align:center;">在光标所在行的下面插入新的一行，光标停在空行首</td></tr><tr><td style="text-align:center;">O</td><td style="text-align:center;">在光标所在行的上面插入新的一行，光标停在空行首</td></tr><tr><td style="text-align:center;">a</td><td style="text-align:center;">在光标所在位置之后插入文本</td></tr><tr><td style="text-align:center;">A</td><td style="text-align:center;">在光标所在行的行尾插入文本</td></tr></tbody></table><p>按下 ESC 键，离开插入模式，进入命令模式</p><p>因为我们是一个空文件，所以使用【I】或者【i】都可以</p><p>如果里面的文本很多，要使用【A】进入编辑模式，即在行末添加文本</p><hr><h4 id="命令模式" tabindex="-1"><a class="header-anchor" href="#命令模式" aria-hidden="true">#</a> 命令模式</h4><p>Vim 打开一个文件（文件可以存在，也可以不存在），默认进入命令模式。在该模式下， 输入的字符会被当做指令，而不会被当做要输入的文字</p><h5 id="移动光标" tabindex="-1"><a class="header-anchor" href="#移动光标" aria-hidden="true">#</a> 移动光标</h5><table><thead><tr><th style="text-align:center;">快捷键</th><th style="text-align:center;">功能描述</th></tr></thead><tbody><tr><td style="text-align:center;">w</td><td style="text-align:center;">光标移动至下一个单词的单词首</td></tr><tr><td style="text-align:center;">b</td><td style="text-align:center;">光标移动至上一个单词的单词首</td></tr><tr><td style="text-align:center;">e</td><td style="text-align:center;">光标移动至下一个单词的单词尾</td></tr><tr><td style="text-align:center;">0</td><td style="text-align:center;">光标移动至当前行的行首</td></tr><tr><td style="text-align:center;">^</td><td style="text-align:center;">行首, 第一个不是空白字符的位置</td></tr><tr><td style="text-align:center;">$</td><td style="text-align:center;">光标移动至当前行的行尾</td></tr><tr><td style="text-align:center;">gg</td><td style="text-align:center;">光标移动至文件开头</td></tr><tr><td style="text-align:center;">G</td><td style="text-align:center;">光标移动至文件末尾</td></tr><tr><td style="text-align:center;">ngg</td><td style="text-align:center;">光标移动至第n行</td></tr><tr><td style="text-align:center;">nG</td><td style="text-align:center;">光标移动至第n行</td></tr><tr><td style="text-align:center;">:n</td><td style="text-align:center;">光标移动至第n行</td></tr></tbody></table><hr><h5 id="选中文本" tabindex="-1"><a class="header-anchor" href="#选中文本" aria-hidden="true">#</a> 选中文本</h5><p>在 vi/vim 中要选择文本，需要显示 visual 命令切换到<strong>可视模式</strong></p><p>vi/vim 中提供了三种可视模式，方便程序员的选择<strong>选中文本的方式</strong></p><p>按 ESC 可以放弃选中, 返回到<strong>命令模式</strong></p><table><thead><tr><th>命令</th><th>模式</th><th>功能</th></tr></thead><tbody><tr><td>v</td><td>可视模式</td><td>从光标位置开始按照正常模式选择文本</td></tr><tr><td>V</td><td>可视化模式</td><td>选中光标经过的完整行</td></tr><tr><td>Ctrl + v</td><td>可是块模式</td><td>垂直方向选中文本</td></tr></tbody></table><h5 id="撤销删除" tabindex="-1"><a class="header-anchor" href="#撤销删除" aria-hidden="true">#</a> 撤销删除</h5><p>在学习编辑命令之前,先要知道怎样撤销之前一次错误的编辑操作</p><table><thead><tr><th>命令</th><th>英文</th><th>功能</th></tr></thead><tbody><tr><td>u</td><td>undo</td><td>撤销上次的命令(ctrl + z)</td></tr><tr><td>Ctrl + r</td><td>uredo</td><td>恢复撤销的命令</td></tr></tbody></table><p>删除的内容此时并没有真正的被删除，在剪切板中，按下 p 键，可以将删除的内容粘贴回来</p><table><thead><tr><th style="text-align:center;">快捷键</th><th style="text-align:center;">功能描述</th></tr></thead><tbody><tr><td style="text-align:center;">x</td><td style="text-align:center;">删除光标所在位置的字符</td></tr><tr><td style="text-align:center;">d</td><td style="text-align:center;">删除移动命令对应的内容</td></tr><tr><td style="text-align:center;">dd</td><td style="text-align:center;">删除光标所在行的内容</td></tr><tr><td style="text-align:center;">D</td><td style="text-align:center;">删除光标位置到行尾的内容</td></tr><tr><td style="text-align:center;">:n1,n2</td><td style="text-align:center;">删除从 a1 到 a2 行的文本内容</td></tr></tbody></table><p><strong>删除命令可以和移动命令连用, 以下是常见的组合命令(扩展):</strong></p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>dw</td><td>删除从光标位置到单词末尾</td></tr><tr><td>d}</td><td>删除从光标位置到段落末尾</td></tr><tr><td>dG</td><td>删除光标所行到文件末尾的所有内容</td></tr><tr><td>ndd</td><td>删除当前行（包括此行）到后 n 行内容</td></tr></tbody></table><hr><h5 id="复制粘贴" tabindex="-1"><a class="header-anchor" href="#复制粘贴" aria-hidden="true">#</a> 复制粘贴</h5><p>vim 中提供有一个 被复制文本的缓冲区</p><ul><li>复制命令会将选中的文字保存在缓冲区</li><li>删除命令删除的文字会被保存在缓冲区</li><li>在需要的位置，使用粘贴命令可以将缓冲对的文字插入到光标所在的位置</li><li>vim 中的文本缓冲区只有一个，如果后续做过复制、剪切操作，之前缓冲区中的内容会被替换</li></ul><table><thead><tr><th style="text-align:center;">快捷键</th><th style="text-align:center;">功能描述</th></tr></thead><tbody><tr><td style="text-align:center;">y</td><td style="text-align:center;">复制已选中的文本到剪切板</td></tr><tr><td style="text-align:center;">yy</td><td style="text-align:center;">将光标所在行复制到剪切板</td></tr><tr><td style="text-align:center;">nyy</td><td style="text-align:center;">复制从光标所在行到向下n行</td></tr><tr><td style="text-align:center;">p</td><td style="text-align:center;">将剪切板中的内容粘贴到光标后</td></tr><tr><td style="text-align:center;">P</td><td style="text-align:center;">将剪切板中的内容粘贴到光标前</td></tr></tbody></table><p>注意：<strong>vim 中的文本缓冲区和系统的剪切板不是同一个</strong>，在其他软件中使用 Ctrl + C 复制的内容，不能在 vim 中通过 <code>p</code> 命令粘贴，可以在编辑模式下使用鼠标右键粘贴</p><hr><h5 id="查找替换" tabindex="-1"><a class="header-anchor" href="#查找替换" aria-hidden="true">#</a> 查找替换</h5><p>查找</p><table><thead><tr><th style="text-align:center;">快捷键</th><th style="text-align:center;">功能描述</th></tr></thead><tbody><tr><td style="text-align:center;">/abc</td><td style="text-align:center;">从光标所在位置向后查找字符串 abc</td></tr><tr><td style="text-align:center;">/^abc</td><td style="text-align:center;">查找以 abc 为行首的行</td></tr><tr><td style="text-align:center;">/abc$</td><td style="text-align:center;">查找以 abc 为行尾的行</td></tr><tr><td style="text-align:center;">?abc</td><td style="text-align:center;">从光标所在位置向前查找字符串 abc</td></tr><tr><td style="text-align:center;">*</td><td style="text-align:center;">向后查找当前光标所在单词</td></tr><tr><td style="text-align:center;">#</td><td style="text-align:center;">向前查找当前光标所在单词</td></tr><tr><td style="text-align:center;">n</td><td style="text-align:center;">查找下一个，向同一方向重复上次的查找指令</td></tr><tr><td style="text-align:center;">N</td><td style="text-align:center;">查找上一个，向相反方向重复上次的查找指令</td></tr></tbody></table><p>替换：</p><table><thead><tr><th>命令</th><th>功能</th><th>工作模式</th></tr></thead><tbody><tr><td>r</td><td>替换当前字符</td><td>命令模式</td></tr><tr><td>R</td><td>替换当前行光标后的字符</td><td>替换模式</td></tr></tbody></table><ul><li>光标选中要替换的字符</li><li><code>R</code> 命令可以进入替换模式，替换完成后，按下 ESC 可以回到命令模式</li><li>替换命令的作用就是不用进入编辑模式，对文件进行轻量级的修改</li></ul><hr><h4 id="末行模式" tabindex="-1"><a class="header-anchor" href="#末行模式" aria-hidden="true">#</a> 末行模式</h4><p>在命令模式下，按下 <code>:</code> 键进入末行模式</p><table><thead><tr><th style="text-align:center;">命令</th><th style="text-align:center;">功能描述</th></tr></thead><tbody><tr><td style="text-align:center;">:wq</td><td style="text-align:center;">保存并退出 Vim 编辑器</td></tr><tr><td style="text-align:center;">:wq!</td><td style="text-align:center;">保存并强制退出 Vim 编辑器</td></tr><tr><td style="text-align:center;">:q</td><td style="text-align:center;">不保存且退出 Vim 编辑器</td></tr><tr><td style="text-align:center;">:q!</td><td style="text-align:center;">不保存且强制退出 Vim 编辑器</td></tr><tr><td style="text-align:center;">:w</td><td style="text-align:center;">保存但是不退出 Vim 编辑器</td></tr><tr><td style="text-align:center;">:w!</td><td style="text-align:center;">强制保存但是不退出 Vim 编辑器</td></tr><tr><td style="text-align:center;">:w filename</td><td style="text-align:center;">另存到 filename 文件</td></tr><tr><td style="text-align:center;">x!</td><td style="text-align:center;">保存文本，退出保存但是不退出 Vim 编辑器，更通用的命令</td></tr><tr><td style="text-align:center;">ZZ</td><td style="text-align:center;">直接退出保存但是不退出 Vim 编辑器</td></tr><tr><td style="text-align:center;">:n</td><td style="text-align:center;">光标移动至第 n 行行首</td></tr></tbody></table><h4 id="异常处理" tabindex="-1"><a class="header-anchor" href="#异常处理" aria-hidden="true">#</a> 异常处理</h4><ul><li><p>如果 vim 异常退出, 在磁盘上可能会保存有 交换文件</p></li><li><p>下次再使用 vim 编辑文件时，会看到以下屏幕信息：</p><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/vim异常.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure></li><li><p>ls -a 一下，会看到隐藏的 .swp 文件，删除了此文件即可</p></li></ul><hr><h3 id="链接" tabindex="-1"><a class="header-anchor" href="#链接" aria-hidden="true">#</a> 链接</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ln</span> <span class="token punctuation">[</span>-sf<span class="token punctuation">]</span> source_filename dist_filename
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-s：默认是实体链接，加 -s 为符号链接</li><li>-f：如果目标文件存在时，先删除目标文件</li></ul><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/文件链接.png" style="zoom:80%;"><p><strong>实体链接</strong>：</p><ul><li>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode</li><li>删除任意一个条目，文件还是存在，只要引用数量不为 0</li><li>不能跨越文件系统、不能对目录进行链接</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ln</span> /etc/crontab <span class="token builtin class-name">.</span>
ll
<span class="token number">34474855</span> -rw-r--r--. <span class="token number">2</span> root root <span class="token number">451</span> Jun <span class="token number">10</span> <span class="token number">2014</span> <span class="token function">crontab</span>
<span class="token number">34474855</span> -rw-r--r--. <span class="token number">2</span> root root <span class="token number">451</span> Jun <span class="token number">10</span> <span class="token number">2014</span> /etc/crontab
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>符号链接</strong>：</p><ul><li><p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式</p></li><li><p>当源文件被删除了，链接文件就打不开了</p></li><li><p>记录的是路径，所以可以为目录建立符号链接</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">34474855</span> -rw-r--r--. <span class="token number">2</span> root root <span class="token number">451</span> Jun <span class="token number">10</span> <span class="token number">2014</span> /etc/crontab
<span class="token number">53745909</span> lrwxrwxrwx. <span class="token number">1</span> root root <span class="token number">12</span> Jun <span class="token number">23</span> <span class="token number">22</span>:31 /root/crontab2 -<span class="token operator">&gt;</span> /etc/crontab
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h2 id="进程管理" tabindex="-1"><a class="header-anchor" href="#进程管理" aria-hidden="true">#</a> 进程管理</h2><h3 id="查看进程" tabindex="-1"><a class="header-anchor" href="#查看进程" aria-hidden="true">#</a> 查看进程</h3><p>ps 指令：查看某个时间点的进程信息</p><p>top 指令：实时显示进程信息</p><p>pstree：查看进程树</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>pstree <span class="token parameter variable">-A</span>	<span class="token comment">#查看所有进程树</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><hr><h3 id="进程-id" tabindex="-1"><a class="header-anchor" href="#进程-id" aria-hidden="true">#</a> 进程 ID</h3><p>进程号：</p><ul><li><p>进程号为 0 的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程</p></li><li><p>进程号为 1 是 init 进程，是一个守护进程，在自举过程结束时由内核调用，init 进程绝不会终止，是一个普通的用户进程，但是它以超级用户特权运行</p></li></ul><p>父进程 ID 为 0 的进程通常是内核进程，作为系统<strong>自举过程</strong>的一部分而启动，init 进程是个例外，它的父进程是 0，但它是用户进程</p><ul><li>主存 = RAM + BIOS 部分的 ROM</li><li>DISK：存放 OS 和 Bootloader</li><li>BIOS：基于 I/O 处理系统</li><li>Bootloader：加载 OS，将 OS 放入内存</li></ul><p>自举程序存储在内存中 ROM，<strong>用来加载操作系统</strong>，初始化 CPU、寄存器、内存等。CPU 的程序计数器指自举程序第一条指令，当计算机<strong>通电</strong>，CPU 开始读取并执行自举程序，将操作系统（不是全部，只是启动计算机的那部分程序）装入 RAM 中，这个过程是自举过程。装入完成后程序计数器设置为 RAM 中操作系统的<strong>第一条指令</strong>，接下来 CPU 将开始执行（启动）操作系统的指令</p><p>存储在 ROM 中保留很小的自举装入程序，完整功能的自举程序保存在磁盘的启动块上，启动块位于磁盘的固定位，拥有启动分区的磁盘称为启动磁盘或系统磁盘（C 盘）</p><hr><h3 id="进程状态" tabindex="-1"><a class="header-anchor" href="#进程状态" aria-hidden="true">#</a> 进程状态</h3><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>R</td><td>running or runnable (on run queue) 正在执行或者可执行，此时进程位于执行队列中</td></tr><tr><td>D</td><td>uninterruptible sleep (usually I/O) 不可中断阻塞，通常为 IO 阻塞</td></tr><tr><td>S</td><td>interruptible sleep (waiting for an event to complete) 可中断阻塞，此时进程正在等待某个事件完成</td></tr><tr><td>Z</td><td>zombie (terminated but not reaped by its parent) 僵死，进程已经终止但是尚未被其父进程获取信息</td></tr><tr><td>T</td><td>stopped (either by a job control signal or because it is being traced) 结束，进程既可以被作业控制信号结束，也可能是正在被追踪</td></tr></tbody></table><p>孤儿进程：</p><ul><li>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程</li><li>孤儿进程将被 init 进程所收养，并由 init 进程对它们完成状态收集工作，所以孤儿进程不会对系统造成危害</li></ul><p>僵尸进程：</p><ul><li>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程</li><li>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）</li><li>系统所能使用的进程号是有限的，产生大量僵尸进程，会导致系统没有可用的进程号而不能产生新的进程</li><li>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程</li></ul><p>补充：</p><ul><li>守护进程(daemon)是一类在后台运行的特殊进程，用于执行特定的系统任务。</li><li>守护进程是<strong>脱离于终端</strong>并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断</li><li>很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭；另一些只在需要的时候才启动，完成任务后就自动结束</li></ul><hr><h3 id="状态改变" tabindex="-1"><a class="header-anchor" href="#状态改变" aria-hidden="true">#</a> 状态改变</h3><h4 id="sigchld" tabindex="-1"><a class="header-anchor" href="#sigchld" aria-hidden="true">#</a> SIGCHLD</h4><p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p><ul><li>得到 SIGCHLD 信号</li><li>waitpid() 或者 wait() 调用会返回</li></ul><p>子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等；在子进程退出时进程描述符不会立即释放，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息，释放子进程的 PCB</p><hr><h4 id="wait" tabindex="-1"><a class="header-anchor" href="#wait" aria-hidden="true">#</a> wait</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">pid_t</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>参数：status 用来保存被收集的子进程退出时的状态，如果不关心子进程<strong>如何</strong>销毁，可以设置这个参数为 NULL</p><p>父进程调用 wait() 会阻塞等待，直到收到一个子进程退出的 SIGCHLD 信号，wait() 函数就会销毁子进程并返回</p><ul><li>成功，返回被收集的子进程的进程 ID</li><li>失败，返回 -1，同时 errno 被置为 ECHILD（如果调用进程没有子进程，调用就会失败）</li></ul><hr><h4 id="waitpid" tabindex="-1"><a class="header-anchor" href="#waitpid" aria-hidden="true">#</a> waitpid</h4><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token class-name">pid_t</span> <span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token class-name">pid_t</span> pid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>status<span class="token punctuation">,</span> <span class="token keyword">int</span> options<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>作用和 wait() 完全相同，只是多了两个可控制的参数 pid 和 options</p><ul><li>pid：指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号；如果 pid=-1 时，那么和 wait() 作用相同，都是关注所有子进程退出的 SIGCHLD 信号</li><li>options：主要有 WNOHANG 和 WUNTRACED 两个，WNOHANG 可以使 waitpid() 调用变成非阻塞的，就是会立即返回，父进程可以继续执行其它任务</li></ul><hr><h2 id="网络管理" tabindex="-1"><a class="header-anchor" href="#网络管理" aria-hidden="true">#</a> 网络管理</h2><h3 id="network" tabindex="-1"><a class="header-anchor" href="#network" aria-hidden="true">#</a> network</h3><ul><li><p>启动：service network start</p></li><li><p>停止：service network stop</p></li><li><p>重启：service network restart</p></li></ul><hr><h3 id="ifconfig" tabindex="-1"><a class="header-anchor" href="#ifconfig" aria-hidden="true">#</a> ifconfig</h3><p>ifconfig 是 Linux 中用于显示或配置网络设备的命令，英文全称是 network interfaces configuring</p><p>ifconfig 命令用于显示或设置网络设备。ifconfig 可设置网络设备的状态，或是显示目前的设置</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ifconfig</span> <span class="token punctuation">[</span>网络设备<span class="token punctuation">]</span><span class="token punctuation">[</span>down up <span class="token parameter variable">-allmulti</span> <span class="token parameter variable">-arp</span> -promisc<span class="token punctuation">]</span><span class="token punctuation">[</span>add<span class="token operator">&lt;</span>地址<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>del<span class="token operator">&lt;</span>地址<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>hw<span class="token operator">&lt;</span>网络设备类型<span class="token operator">&gt;</span><span class="token operator">&lt;</span>硬件地址<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>io_addr<span class="token operator">&lt;</span>I/O地址<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>irq<span class="token operator">&lt;</span>IRQ地址<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>media<span class="token operator">&lt;</span>网络媒介类型<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>mem_start<span class="token operator">&lt;</span>内存地址<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>metric<span class="token operator">&lt;</span>数目<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>mtu<span class="token operator">&lt;</span>字节<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>netmask<span class="token operator">&lt;</span>子网掩码<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>tunnel<span class="token operator">&lt;</span>地址<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-broadcast<span class="token operator">&lt;</span>地址<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-pointopoint<span class="token operator">&lt;</span>地址<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>IP地址<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p><code>ifconfig</code>：显示激活的网卡信息 ens<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/网卡信息.png"></p><p>ens33（或 eth0）表示第一块网卡，IP地址是 192.168.0.137，广播地址 broadcast 192.168.0.255，掩码地址netmask 255.255.255.0 ，inet6 对应的是 ipv6</p><p>lo 是表示主机的<strong>回坏地址</strong>，用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口</p></li><li><p>ifconfig ens33 down：关闭网卡</p></li><li><p>ifconfig ens33 up：启用网卡</p></li></ul><hr><h3 id="ping" tabindex="-1"><a class="header-anchor" href="#ping" aria-hidden="true">#</a> ping</h3><p>ping 命令用于检测主机</p><p>执行 ping 指令会使用 ICMP 传输协议，发出要求回应的信息，若远端主机的网络功能没有问题，就会回应该信息</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">ping</span> <span class="token punctuation">[</span>-dfnqrRv<span class="token punctuation">]</span><span class="token punctuation">[</span>-c<span class="token operator">&lt;</span>完成次数<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-i<span class="token operator">&lt;</span>间隔秒数<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-I<span class="token operator">&lt;</span>网络界面<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-l<span class="token operator">&lt;</span>前置载入<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-p<span class="token operator">&lt;</span>范本样式<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-s<span class="token operator">&lt;</span>数据包大小<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>-t<span class="token operator">&lt;</span>存活数值<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>主机名称或IP地址<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li><p>-c&lt;完成次数&gt;：设置完成要求回应的次数；</p></li><li><p><code>ping -c 2 www.baidu.com</code><br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/ping百度.png" alt="" loading="lazy"></p><p>icmp_seq：ping 序列，从1开始</p><p>ttl：IP 生存时间值</p><p>time：响应时间,数值越小，联通速度越快</p></li></ul><hr><h3 id="netstat" tabindex="-1"><a class="header-anchor" href="#netstat" aria-hidden="true">#</a> netstat</h3><p>netstat 命令用于显示网络状态</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">netstat</span> <span class="token punctuation">[</span>-acCeFghilMnNoprstuvVwx<span class="token punctuation">]</span><span class="token punctuation">[</span>-A<span class="token operator">&lt;</span>网络类型<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">[</span>--ip<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>-a 显示所有连线中的 Socket，显示详细的连接状况</li><li>-i 显示网络界面信息表单，显示网卡列表</li><li>-p 显示正在使用 Socket 的程序识别码和程序名称</li><li>-n 显示使用 IP 地址，而不通过域名服务器</li><li>-t 显示 TCP 传输协议的连线状况。</li><li>-u 显示 UDP 传输协议的连线状况</li><li><strong>-aptn：查看所有 TCP 开启端口</strong></li><li><strong>-apun：查看所有 UDP 开启端口</strong></li></ul><p>补充：</p><ul><li>netstat -apn | grep port：查看指定端口号</li><li>lsof -i:port ：查看指定端口号</li></ul><hr><h2 id="磁盘管理" tabindex="-1"><a class="header-anchor" href="#磁盘管理" aria-hidden="true">#</a> 磁盘管理</h2><h3 id="挂载概念" tabindex="-1"><a class="header-anchor" href="#挂载概念" aria-hidden="true">#</a> 挂载概念</h3><p>在安装 Linux 系统时设立的各个分区，如根分区、/boot 分区等都是自动挂载的，也就是说不需要人为操作，开机就会自动挂载。但是光盘、U 盘等存储设备如果需要使用，就必须人为的进行挂载</p><p>在 Windows 下插入 U 盘也是需要挂载（分配盘符）的，只不过 Windows 下分配盘符是自动的。其实挂载可以理解为 Windows 当中的分配盘符，只不过 Windows 当中是以英文字母 ABCD 等作为盘符，而 Linux 是拿系统目录作为盘符，当然 Linux 当中也不叫盘符，而是称为挂载点，而把为分区或者光盘等存储设备分配一个挂载点的过程称为挂载</p><p>Linux 中的根目录以外的文件要想被访问，需要将其关联到根目录下的某个目录来实现，这种关联操作就是挂载，这个目录就是挂载点，解除次关联关系的过程称之为卸载</p><p>挂载点的目录需要以下几个要求：</p><ul><li>目录要先存在，可以用 mkdir 命令新建目录</li><li>挂载点目录不可被其他进程使用到</li><li>挂载点下原有文件将被隐藏</li></ul><hr><h3 id="lsblk" tabindex="-1"><a class="header-anchor" href="#lsblk" aria-hidden="true">#</a> lsblk</h3><p>lsblk 命令的英文是 list block，即用于列出所有可用块设备的信息，而且还能显示他们之间的依赖关系，但是不会列出 RAM 盘的信息</p><p>命令：lsblk [参数]</p><ul><li><p><code>lsblk</code>：以树状列出所有块设备<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/可用块设备.png" alt="" loading="lazy"></p><p>NAME：这是块设备名</p><p>MAJ：MIN : 本栏显示主要和次要设备号</p><p>RM：本栏显示设备是否可移动设备，在上面设备 sr0 的 RM 值等于 1，这说明他们是可移动设备</p><p>SIZE：本栏列出设备的容量大小信息</p><p>RO：该项表明设备是否为只读，在本案例中，所有设备的 RO 值为 0，表明他们不是只读的</p><p>TYPE：本栏显示块设备是否是磁盘或磁盘上的一个分区。在本例中，sda 和 sdb 是磁盘，而 sr0 是只读存储（rom）。</p><p>MOUNTPOINT：本栏指出设备挂载的挂载点。</p></li><li><p><code>lsblk -f</code>：不会列出所有空设备<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/不包含空设备.png" alt="" loading="lazy"></p><p>NAME表示设备名称</p><p>FSTYPE表示文件类型</p><p>LABEL表示设备标签</p><p>UUID设备编号</p><p>MOUNTPOINT表示设备的挂载点</p></li></ul><hr><h3 id="df" tabindex="-1"><a class="header-anchor" href="#df" aria-hidden="true">#</a> df</h3><p>df 命令用于显示目前在 Linux 系统上的文件系统的磁盘使用情况统计。</p><p>命令：df [options]... [FILE]...</p><ul><li>-h 使用人类可读的格式(预设值是不加这个选项的...)</li><li>--total 计算所有的数据之和</li></ul><figure><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/磁盘管理.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>第一列指定文件系统的名称；第二列指定一个特定的文件系统，1K 是 1024 字节为单位的总容量；已用和可用列分别指定的容量；最后一个已用列指定使用的容量的百分比；最后一栏指定的文件系统的挂载点</p><hr><h3 id="mount" tabindex="-1"><a class="header-anchor" href="#mount" aria-hidden="true">#</a> mount</h3><p>mount 命令是经常会使用到的命令，它用于挂载 Linux 系统外的文件</p><p>使用者权限：所有用户，设置级别的需要管理员</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">mount</span> <span class="token punctuation">[</span>-hV<span class="token punctuation">]</span>
<span class="token function">mount</span> <span class="token parameter variable">-a</span> <span class="token punctuation">[</span>-fFnrsvw<span class="token punctuation">]</span> <span class="token punctuation">[</span>-t vfstype<span class="token punctuation">]</span>
<span class="token function">mount</span> <span class="token punctuation">[</span>-fnrsvw<span class="token punctuation">]</span> <span class="token punctuation">[</span>-o options <span class="token punctuation">[</span>,<span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span> device <span class="token operator">|</span> <span class="token function">dir</span>
<span class="token function">mount</span> <span class="token punctuation">[</span>-fnrsvw<span class="token punctuation">]</span> <span class="token punctuation">[</span>-t vfstype<span class="token punctuation">]</span> <span class="token punctuation">[</span>-o options<span class="token punctuation">]</span> device <span class="token function">dir</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。</li></ul><p>通过挂载的方式查看 Linux CD/DVD 光驱，查看 ubuntu-20.04.1-desktop-amd64.iso 的文件</p><ul><li><p>进入【虚拟机】--【设置】，设置 CD/DVD 的内容，ubuntu-20.04.1-desktop-amd64.iso</p></li><li><p>创建挂载点（注意：一般用户无法挂载 cdrom，只有 root 用户才可以操作）</p><p><code>mkdir -p /mnt/cdrom </code>：切换到 root 下创建一个挂载点（其实就是创建一个目录）</p></li><li><p>开始挂载<br><code>mount -t auto /dev/cdrom /mnt/cdrom</code>：通过挂载点的方式查看上面的【ISO文件内容】<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/挂载成功.png" alt="挂载成功" loading="lazy"></p></li><li><p>查看挂载内容：<code>ls -l -a ./mnt/cdrom/</code></p></li><li><p>卸载 cdrom：<code>umount /mnt/cdrom/</code></p></li></ul><hr><h2 id="防火墙" tabindex="-1"><a class="header-anchor" href="#防火墙" aria-hidden="true">#</a> 防火墙</h2><h3 id="概述" tabindex="-1"><a class="header-anchor" href="#概述" aria-hidden="true">#</a> 概述</h3><p>防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障，以保护用户资料与信息安全性的一种技术。在默认情况下，Linux 系统的防火墙状态是打开的</p><h3 id="状态" tabindex="-1"><a class="header-anchor" href="#状态" aria-hidden="true">#</a> 状态</h3><p>启动语法：service name status</p><ul><li><p>查看防火墙状态：<code>service iptables status</code></p></li><li><p>临时开启：<code>service iptables start</code></p></li><li><p>临时关闭：<code>service iptables stop</code></p></li><li><p>开机启动：<code>chkconfig iptables on</code></p></li><li><p>开机关闭：<code>chkconfig iptables off</code></p></li></ul><h3 id="放行" tabindex="-1"><a class="header-anchor" href="#放行" aria-hidden="true">#</a> 放行</h3><p>设置端口防火墙放行</p><ul><li>修改配置文件：<code>vim /etc/sysconfig/iptables</code></li><li>添加放行端口：<code>-A INPUT -m state --state NEW -m tcp -p tcp --dport 端口号 -j ACCEPT</code></li><li>重新加载防火墙规则：<code>service iptables reload</code></li></ul><p>备注：默认情况下 22 端口号是放行的</p><hr><h2 id="shell" tabindex="-1"><a class="header-anchor" href="#shell" aria-hidden="true">#</a> Shell</h2><h3 id="入门" tabindex="-1"><a class="header-anchor" href="#入门" aria-hidden="true">#</a> 入门</h3><h4 id="概念" tabindex="-1"><a class="header-anchor" href="#概念" aria-hidden="true">#</a> 概念</h4><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序，又称 Shell 命令稿、程序化脚本，是一种计算机程序使用的文本文件，内容由一连串的 shell 命令组成，经由 Unix Shell 直译其内容后运作</p><p>Shell 被当成是一种脚本语言来设计，其运作方式与解释型语言相当，由 Unix shell 扮演命令行解释器的角色，在读取 shell 脚本之后，依序运行其中的 shell 命令，之后输出结果</p><h4 id="环境" tabindex="-1"><a class="header-anchor" href="#环境" aria-hidden="true">#</a> 环境</h4><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p><code>cat /etc/shells</code>：查看解释器<br><img src="https://seazean.oss-cn-beijing.aliyuncs.com/img/Tool/shell环境.png" alt="" loading="lazy"></p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li><p>Bourne Shell（/usr/bin/sh或/bin/sh）</p></li><li><p>Bourne Again Shell（/bin/bash）：Bash 是大多数Linux 系统默认的 Shell</p></li><li><p>C Shell（/usr/bin/csh）</p></li><li><p>K Shell（/usr/bin/ksh）</p></li><li><p>Shell for Root（/sbin/sh）</p></li><li><p>等等……</p></li></ul><h4 id="第一个shell" tabindex="-1"><a class="header-anchor" href="#第一个shell" aria-hidden="true">#</a> 第一个shell</h4>`,565),c={href:"http://s.sh",target:"_blank",rel:"noopener noreferrer"},u={href:"http://s.sh",target:"_blank",rel:"noopener noreferrer"},h={href:"http://s.sh",target:"_blank",rel:"noopener noreferrer"},b={href:"http://s.sh",target:"_blank",rel:"noopener noreferrer"},v=t(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash  --- 指定脚本解释器</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;你好，shell !&quot;</span>   ---向窗口输入文本

:<span class="token operator">&lt;&lt;</span><span class="token operator">!</span>
写shell的习惯 第一行指定解释器
文件是sh为后缀名
括号成对书写
注释的时候尽量不用中文注释。不友好。
<span class="token punctuation">[</span><span class="token punctuation">]</span> 括号两端要要有空格。  <span class="token punctuation">[</span> neirong <span class="token punctuation">]</span>
习惯代码索引，增加阅读性
写语句的时候，尽量写全了，比如if。。。
<span class="token operator">!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1),m=a("li",null,[a("p",null,"查看 s.sh文件：ls -l s.sh文件权限是【-rw-rw-r--】")],-1),k={href:"http://s.sh",target:"_blank",rel:"noopener noreferrer"},g=a("li",null,[a("p",null,"执行文件：./s.sh")],-1),x=a("li",null,[a("p",null,[n("或者直接 "),a("code",null,"bash s.sh")])],-1),f=t(`<p><strong>注意：</strong></p><p><strong>#!</strong> 是一个约定的标记，告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell</p><p>echo 命令用于向窗口输出文本</p><hr><h3 id="注释" tabindex="-1"><a class="header-anchor" href="#注释" aria-hidden="true">#</a> 注释</h3><ul><li><p>单行注释：以 <strong>#</strong> 开头的行就是注释，会被解释器忽略</p></li><li><p>多行注释：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>:<span class="token operator">&lt;&lt;</span><span class="token string">EOF
注释内容...
注释内容...
EOF</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>:<span class="token operator">&lt;&lt;</span><span class="token operator">!</span>      -----这里的符号要和结尾处的一样
注释内容<span class="token punctuation">..</span>.
注释内容<span class="token punctuation">..</span>.
注释内容<span class="token punctuation">..</span>.
<span class="token operator">!</span>        
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><hr><h3 id="变量" tabindex="-1"><a class="header-anchor" href="#变量" aria-hidden="true">#</a> 变量</h3><h4 id="定义变量" tabindex="-1"><a class="header-anchor" href="#定义变量" aria-hidden="true">#</a> 定义变量</h4><p>变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。同时，变量名的命名须遵循如下规则：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><h4 id="使用变量" tabindex="-1"><a class="header-anchor" href="#使用变量" aria-hidden="true">#</a> 使用变量</h4><p>使用一个定义过的变量，只要在变量名前面加美元符号$即可</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;seazean&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$name</span>
<span class="token builtin class-name">echo</span> <span class="token variable">\${name}</span>
<span class="token assign-left variable">name</span><span class="token operator">=</span><span class="token string">&quot;zhy&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>已定义的变量，可以被重新定义变量名</p></li><li><p>外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界。推荐加！！</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>比如：echo <span class="token string">&quot;I am good at <span class="token variable">\${shell-t}</span>Script&quot;</span>
通过上面的脚本我们发现，如果不给shell-t变量加花括号，写成echo <span class="token string">&quot;I am good at <span class="token variable">$shell</span>-tScript&quot;</span>，解释器shell就会把<span class="token variable">$shell</span>-tScript当成一个变量，由于我们前面没有定义shell-t变量，那么解释器执行执行的结果自然就为空了。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="只读变量" tabindex="-1"><a class="header-anchor" href="#只读变量" aria-hidden="true">#</a> 只读变量</h4><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。(类似于final)</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">myUrl</span><span class="token operator">=</span><span class="token string">&quot;https://www.baidu.com&quot;</span>
<span class="token builtin class-name">readonly</span> myUrl
<span class="token assign-left variable">myUrl</span><span class="token operator">=</span><span class="token string">&quot;https://cn.bing.com/&quot;</span>  
<span class="token comment">#报错 myUrl readonly</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="删除变量" tabindex="-1"><a class="header-anchor" href="#删除变量" aria-hidden="true">#</a> 删除变量</h4><p>使用 unset 命令可以删除变量，变量被删除后不能再次使用。</p><p>语法：<code>unset variable_name</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/sh</span>
<span class="token assign-left variable">myUrl</span><span class="token operator">=</span><span class="token string">&quot;https://www.baidu.com&quot;</span>
<span class="token builtin class-name">unset</span> myUrl
<span class="token builtin class-name">echo</span> <span class="token variable">$myUrl</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>定义myUrl变量，通过unset删除变量，然后通过echo进行输出，<strong>结果是为空</strong>，没有任何的结果输出。</p><h4 id="字符变量" tabindex="-1"><a class="header-anchor" href="#字符变量" aria-hidden="true">#</a> 字符变量</h4><blockquote><p>字符串是shell编程中最常用也是最有用的数据类型，字符串可以用单引号，也可以用双引号，也可以不用引号，在Java SE中我们定义一个字符串通过Stirng s=“abc&quot; 双引号的形式进行定义，而在shell中也是可以的。</p></blockquote><h5 id="引号" tabindex="-1"><a class="header-anchor" href="#引号" aria-hidden="true">#</a> 引号</h5><ul><li><p><strong>单引号</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">&#39;this is a string variable&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的<strong>变量是无效的</strong>；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul></li><li><p>双引号</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">your_name</span><span class="token operator">=</span><span class="token string">&#39;frank&#39;</span>
<span class="token assign-left variable">str</span><span class="token operator">=</span><span class="token string">&quot;Hello,<span class="token entity" title="\\&quot;">\\&quot;</span><span class="token variable">$your_name</span><span class="token entity" title="\\&quot;">\\&quot;</span>! <span class="token entity" title="\\n">\\n</span>&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token variable">$str</span>     <span class="token comment">#Hello, &quot;frank&quot;!</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>双引号的优点：</p><ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul></li></ul><h5 id="拼接字符串" tabindex="-1"><a class="header-anchor" href="#拼接字符串" aria-hidden="true">#</a> 拼接字符串</h5><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">your_name</span><span class="token operator">=</span><span class="token string">&quot;frank&quot;</span>
<span class="token comment"># 使用双引号拼接</span>
<span class="token assign-left variable">greeting</span><span class="token operator">=</span><span class="token string">&quot;hello, &quot;</span><span class="token variable">$your_name</span><span class="token string">&quot; !&quot;</span>
<span class="token assign-left variable">greeting_1</span><span class="token operator">=</span><span class="token string">&quot;hello, <span class="token variable">\${your_name}</span> !&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$greeting</span>  <span class="token variable">$greeting_1</span>
<span class="token comment">#hello,frank! hello,frank</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="获取字符串长度" tabindex="-1"><a class="header-anchor" href="#获取字符串长度" aria-hidden="true">#</a> 获取字符串长度</h5><p>命令：<code>\${#variable_name}</code></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">string</span><span class="token operator">=</span><span class="token string">&quot;seazean&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token variable">\${<span class="token operator">#</span>string}</span> <span class="token comment">#7</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="提取字符串" tabindex="-1"><a class="header-anchor" href="#提取字符串" aria-hidden="true">#</a> 提取字符串</h5><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">string</span><span class="token operator">=</span><span class="token string">&quot;abcdefghijklmn&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token variable">\${string<span class="token operator">:</span>1<span class="token operator">:</span>4}</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为【bcde】，通过截取我们发现，它的下标和我们在java中的读取方式是一样的，下标也是从0开始。</p><hr><h3 id="数组" tabindex="-1"><a class="header-anchor" href="#数组" aria-hidden="true">#</a> 数组</h3><p>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</p><h4 id="定义数组" tabindex="-1"><a class="header-anchor" href="#定义数组" aria-hidden="true">#</a> 定义数组</h4><p>在 Shell 中，用括号来表示数组，数组元素用&quot;空格&quot;符号分割开</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>数组名<span class="token operator">=</span><span class="token punctuation">(</span>值1 值2 <span class="token punctuation">..</span>. 值n<span class="token punctuation">)</span>
<span class="token assign-left variable">array_name</span><span class="token operator">=</span><span class="token punctuation">(</span>value0 value1 value2 value3<span class="token punctuation">)</span> 
<span class="token assign-left variable">array_name</span><span class="token operator">=</span><span class="token punctuation">(</span>
value0
value1
value2
value3
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过下标定义数组中的其中一个元素：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>array_name<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>value0
array_name<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">=</span>value1
array_name<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token operator">=</span>valuen
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以不使用连续的下标，而且下标的范围没有限制</p><h4 id="读取数组" tabindex="-1"><a class="header-anchor" href="#读取数组" aria-hidden="true">#</a> 读取数组</h4><p>读取数组元素值的一般格式是：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token variable">\${数组名<span class="token punctuation">[</span>下标<span class="token punctuation">]</span>}</span>

<span class="token assign-left variable">value</span><span class="token operator">=</span><span class="token variable">\${array_name<span class="token punctuation">[</span>n<span class="token punctuation">]</span>}</span>
<span class="token builtin class-name">echo</span> <span class="token variable">\${value}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 <strong>@</strong> 符号可以获取数组中的所有元素，例如：<code>echo \${array_name[@]}</code></p><h4 id="获取长度" tabindex="-1"><a class="header-anchor" href="#获取长度" aria-hidden="true">#</a> 获取长度</h4><p>获取数组长度的方法与获取字符串长度的方法相同，数组前加#</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 取得数组元素的个数</span>
<span class="token assign-left variable">length</span><span class="token operator">=</span><span class="token variable">\${<span class="token operator">#</span>array_name<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>
<span class="token comment"># 或者</span>
<span class="token assign-left variable">length</span><span class="token operator">=</span><span class="token variable">\${<span class="token operator">#</span>array_name<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#! /bin/bash</span>
<span class="token assign-left variable">g</span><span class="token operator">=</span><span class="token punctuation">(</span>a b c d e f<span class="token punctuation">)</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;数组下标为2的数据为:&quot;</span> <span class="token variable">\${g<span class="token punctuation">[</span>2<span class="token punctuation">]</span>}</span>  <span class="token comment">#c</span>
<span class="token builtin class-name">echo</span>  <span class="token string">&quot;数组所有数据为:&quot;</span>  <span class="token variable">\${<span class="token operator">#</span>g<span class="token punctuation">[</span>@<span class="token punctuation">]</span>}</span>   <span class="token comment">#6</span>
<span class="token builtin class-name">echo</span>  <span class="token string">&quot;数组所有数据为:&quot;</span>   <span class="token variable">\${<span class="token operator">#</span>g<span class="token punctuation">[</span>*<span class="token punctuation">]</span>}</span>  <span class="token comment">#6</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="运算符" tabindex="-1"><a class="header-anchor" href="#运算符" aria-hidden="true">#</a> 运算符</h3><p>Shell 和其他编程一样，<strong>支持</strong>包括：算术、关系、布尔、字符串等运算符。原生 bash **不支持 **简单的数学运算，但是可以通过其他命令来实现，例如expr。expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><h4 id="规则" tabindex="-1"><a class="header-anchor" href="#规则" aria-hidden="true">#</a> 规则</h4><ul><li><strong>表达式和运算符之间要有空格</strong>，例如 2+2 是不对的，必须写成 2 + 2</li><li><strong>完整的表达式要被 \`\` 包含，注意不是单引号</strong></li><li><strong>条件表达式要放在方括号之间，并且要有空格</strong>，例如: <code>[$a==$b]</code> 是错误的，必须写成 <code>[ $a == $b ]</code></li><li><strong>(())双括号里可以跟表达式</strong>，例如((i++))，((a+b))</li></ul><h4 id="算术运算符" tabindex="-1"><a class="header-anchor" href="#算术运算符" aria-hidden="true">#</a> 算术运算符</h4><table><thead><tr><th><strong>运算符</strong></th><th><strong>说明</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>+</td><td>加法</td><td><code>expr $a + $b</code> 结果为 30。</td></tr><tr><td>-</td><td>减法</td><td><code>expr $a - $b</code> 结果为 -10。</td></tr><tr><td>*</td><td>乘法</td><td><code>expr $a \\* $b</code> 结果为 200。</td></tr><tr><td>/</td><td>除法</td><td><code>expr $b / $a</code> 结果为 2。</td></tr><tr><td>%</td><td>取余</td><td><code>expr $b % $a</code> 结果为 0。</td></tr><tr><td>=</td><td>赋值</td><td>a=$b 将把变量 b 的值赋给 a。</td></tr><tr><td>==</td><td>相等。用于比较两个数字，相同则返回 true。</td><td><code>[ $a == $b ] </code>返回 false。</td></tr><tr><td>!=</td><td>不相等。用于比较两个数字，不相同则返回 true。</td><td><code>[ $a != $b ] </code>返回 true。</td></tr></tbody></table><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#! /bin/bash</span>
<span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">4</span>
<span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;加法运算&quot;</span>  <span class="token variable"><span class="token variable">\`</span><span class="token function">expr</span> $a + $b<span class="token variable">\`</span></span> 
<span class="token builtin class-name">echo</span> <span class="token string">&quot;乘法运算，注意*号前面需要反斜杠&quot;</span> <span class="token variable"><span class="token variable">\`</span> <span class="token function">expr</span> $a <span class="token punctuation">\\</span>* $b<span class="token variable">\`</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;加法运算&quot;</span>  <span class="token variable"><span class="token variable">\`</span><span class="token function">expr</span>  $b / $a<span class="token variable">\`</span></span>
<span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">++</span><span class="token punctuation">))</span></span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;a = <span class="token variable">$a</span>&quot;</span>
<span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$((</span>a <span class="token operator">+</span> b<span class="token variable">))</span></span> 
<span class="token assign-left variable">d</span><span class="token operator">=</span>$<span class="token punctuation">[</span>a + b<span class="token punctuation">]</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;c = <span class="token variable">$c</span>&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;d = <span class="token variable">$d</span>&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//结果
加法运算 24
减法运算 -16
乘法运算，注意*号前面需要反斜杠 80
加法运算 5
a = 5
c = 25
d = 25
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="字符运算符" tabindex="-1"><a class="header-anchor" href="#字符运算符" aria-hidden="true">#</a> 字符运算符</h4><p>假定变量 a 为 &quot;abc&quot;，变量 b 为 &quot;efg&quot;，true=0，false=1。</p><table><thead><tr><th style="text-align:left;">运算符</th><th style="text-align:left;">说明</th><th style="text-align:left;">举例</th></tr></thead><tbody><tr><td style="text-align:left;">=</td><td style="text-align:left;">检测两个字符串是否相等，相等返回 true。</td><td style="text-align:left;"><code>[ $a = $b ]</code> 返回 false。</td></tr><tr><td style="text-align:left;">!=</td><td style="text-align:left;">检测两个字符串是否相等，不相等返回 true。</td><td style="text-align:left;"><code>[ $a != $b ]</code> 返回 true。</td></tr><tr><td style="text-align:left;">-z</td><td style="text-align:left;">检测字符串长度是否为0，为0返回 true。</td><td style="text-align:left;"><code>[ -z $a ]</code> 返回 false。</td></tr><tr><td style="text-align:left;">-n</td><td style="text-align:left;">检测字符串长度是否为0，不为0返回 true。</td><td style="text-align:left;"><code>[ -n &quot;$a&quot; ]</code> 返回 true。</td></tr><tr><td style="text-align:left;">$</td><td style="text-align:left;">检测字符串是否为空，不为空返回 true。</td><td style="text-align:left;"><code>[ $a ]</code> 返回 true。</td></tr></tbody></table><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token string">&quot;abc&quot;</span>
<span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token string">&quot;efg&quot;</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">=</span> <span class="token variable">$b</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$a</span> = <span class="token variable">$b</span> : a 等于 b&quot;</span>
<span class="token keyword">else</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$a</span> = <span class="token variable">$b</span>: a 不等于 b&quot;</span>
<span class="token keyword">fi</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">!=</span> <span class="token variable">$b</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$a</span> != <span class="token variable">$b</span> : a 不等于 b&quot;</span>
<span class="token keyword">else</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$a</span> != <span class="token variable">$b</span>: a 等于 b&quot;</span>
<span class="token keyword">fi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="关系运算符" tabindex="-1"><a class="header-anchor" href="#关系运算符" aria-hidden="true">#</a> 关系运算符</h4><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th style="text-align:left;">运算符</th><th style="text-align:left;">说明</th><th style="text-align:left;">举例</th></tr></thead><tbody><tr><td style="text-align:left;">-eq</td><td style="text-align:left;">检测两个数是否相等，相等返回 true。</td><td style="text-align:left;"><code>[ $a -eq $b ]</code> 返回 false。</td></tr><tr><td style="text-align:left;">-ne</td><td style="text-align:left;">检测两个数是否不相等，不相等返回 true。</td><td style="text-align:left;"><code>[ $a -ne $b ]</code> 返回 true。</td></tr><tr><td style="text-align:left;">-gt</td><td style="text-align:left;">检测左边的数是否大于右边的，如果是，则返回 true。</td><td style="text-align:left;"><code>[ $a -gt $b ]</code> 返回 false。</td></tr><tr><td style="text-align:left;">-lt</td><td style="text-align:left;">检测左边的数是否小于右边的，如果是，则返回 true。</td><td style="text-align:left;"><code>[ $a -lt $b ]</code> 返回 true。</td></tr><tr><td style="text-align:left;">-ge</td><td style="text-align:left;">检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td style="text-align:left;"><code>[ $a -ge $b ]</code> 返回 false。</td></tr><tr><td style="text-align:left;">-le</td><td style="text-align:left;">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td style="text-align:left;"><code>[ $a -le $b ]</code> 返回 true。</td></tr></tbody></table><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span>

<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-eq</span> <span class="token variable">$b</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$a</span> -eq <span class="token variable">$b</span> : a 等于 b&quot;</span>
<span class="token keyword">else</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;<span class="token variable">$a</span> -eq <span class="token variable">$b</span>: a 不等于 b&quot;</span>
<span class="token keyword">fi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="布尔运算符" tabindex="-1"><a class="header-anchor" href="#布尔运算符" aria-hidden="true">#</a> 布尔运算符</h4><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th style="text-align:left;">运算符</th><th style="text-align:left;">说明</th><th style="text-align:left;">举例</th></tr></thead><tbody><tr><td style="text-align:left;">!</td><td style="text-align:left;">非运算，表达式为 true 则返回 false，否则返回 true。</td><td style="text-align:left;">[ ! false ] 返回 true。</td></tr><tr><td style="text-align:left;">-o</td><td style="text-align:left;">或运算，有一个表达式为 true 则返回 true。</td><td style="text-align:left;"><code>[ $a -lt 20 -o $b -gt 100 ]</code>true</td></tr><tr><td style="text-align:left;">-a</td><td style="text-align:left;">与运算，两个表达式都为 true 才返回 true。</td><td style="text-align:left;"><code>[ $a -lt 20 -a $b -gt 100 ]</code>false</td></tr></tbody></table><h4 id="逻辑运算符" tabindex="-1"><a class="header-anchor" href="#逻辑运算符" aria-hidden="true">#</a> 逻辑运算符</h4><p>假定变量 a 为 10，变量 b 为 20:</p><table><thead><tr><th style="text-align:left;">运算符</th><th style="text-align:left;">说明</th><th style="text-align:left;">举例</th></tr></thead><tbody><tr><td style="text-align:left;">&amp;&amp;</td><td style="text-align:left;">逻辑的 AND</td><td style="text-align:left;"><code>[[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</code> 返回 false</td></tr><tr><td style="text-align:left;">||</td><td style="text-align:left;">逻辑的 OR</td><td style="text-align:left;"><code>[[ $a -lt 100 || $b -gt 100 ]]</code> 返回 true</td></tr></tbody></table><hr><h3 id="流程控制" tabindex="-1"><a class="header-anchor" href="#流程控制" aria-hidden="true">#</a> 流程控制</h3><h4 id="if" tabindex="-1"><a class="header-anchor" href="#if" aria-hidden="true">#</a> if</h4><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">if</span> condition
<span class="token keyword">then</span>
    command1 
    command2
    <span class="token punctuation">..</span>.
    commandN 
<span class="token keyword">fi</span>
<span class="token comment">#末尾的fi就是if倒过来拼写</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">if</span> condition
<span class="token keyword">then</span>
    command1 
    command2
    <span class="token punctuation">..</span>.
    commandN
<span class="token keyword">else</span>
    <span class="token builtin class-name">command</span>
<span class="token keyword">fi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">if</span> condition1
<span class="token keyword">then</span>
    command1
<span class="token keyword">elif</span> condition2 
<span class="token keyword">then</span> 
    command2
<span class="token keyword">else</span>
    commandN
<span class="token keyword">fi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>查找一个进程，如果进程存在就打印true</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-c</span> <span class="token string">&quot;ssh&quot;</span><span class="token variable">)</span></span> <span class="token parameter variable">-gt</span> <span class="token number">1</span> <span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token keyword">then</span> 
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;true&quot;</span>
<span class="token keyword">fi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>判断两个变量是否相等</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token assign-left variable">b</span><span class="token operator">=</span><span class="token number">20</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token operator">==</span> <span class="token variable">$b</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;a 等于 b&quot;</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-gt</span> <span class="token variable">$b</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;a 大于 b&quot;</span>
<span class="token keyword">elif</span> <span class="token punctuation">[</span> <span class="token variable">$a</span> <span class="token parameter variable">-lt</span> <span class="token variable">$b</span> <span class="token punctuation">]</span>
<span class="token keyword">then</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;a 小于 b&quot;</span>
<span class="token keyword">else</span>
   <span class="token builtin class-name">echo</span> <span class="token string">&quot;没有符合的条件&quot;</span>
<span class="token keyword">fi</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h4 id="for" tabindex="-1"><a class="header-anchor" href="#for" aria-hidden="true">#</a> for</h4><p>for循环格式为：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">for</span> <span class="token for-or-select variable">var</span> <span class="token keyword">in</span> item1 item2 <span class="token punctuation">..</span>. itemN
<span class="token keyword">do</span>
    command1
    command2
    <span class="token punctuation">..</span>.
    commandN
<span class="token keyword">done</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>顺序输出当前列表中的字母：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">for</span> <span class="token for-or-select variable">loop</span> <span class="token keyword">in</span> A B C D E F G 
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;顺序输出字母为: <span class="token variable">$loop</span>&quot;</span>
<span class="token keyword">done</span>

顺序输出字母为:A
顺序输出字母为:B
<span class="token punctuation">..</span><span class="token punctuation">..</span>
顺序输出字母为:G
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="while" tabindex="-1"><a class="header-anchor" href="#while" aria-hidden="true">#</a> while</h4><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">while</span> condition
<span class="token keyword">do</span>
    <span class="token builtin class-name">command</span>
<span class="token keyword">done</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>需求：如果int小于等于10，那么条件返回真。int从0开始，每次循环处理时，int加1。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token assign-left variable">a</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable">\${a}</span>&quot;</span> <span class="token parameter variable">-le</span> <span class="token number">10</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">&quot;输出的值为：&quot;</span> <span class="token variable">$a</span>
    <span class="token variable"><span class="token punctuation">((</span>a<span class="token operator">++</span><span class="token punctuation">))</span></span>
<span class="token keyword">done</span>
输出的值为：1
输出的值为：2
<span class="token punctuation">..</span>.
输出的值为：10
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="case-esac" tabindex="-1"><a class="header-anchor" href="#case-esac" aria-hidden="true">#</a> case...esac</h4><p>与 switch ... case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case ... esac 语句，esac（就是 case 反过来）作为结束标记。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token keyword">case</span> 值 <span class="token keyword">in</span>  
模式1<span class="token punctuation">)</span>
    command1
    command2
    command3
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
模式2）
    command1
    command2
    command3
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
*<span class="token punctuation">)</span>
    command1
    command2
    command3
    <span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span>  <span class="token comment">#case反过来</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>case 后为取值，值可以为变量或常数。</p></li><li><p>值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。</p></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">v</span><span class="token operator">=</span><span class="token string">&quot;czbk&quot;</span>

<span class="token keyword">case</span> <span class="token string">&quot;<span class="token variable">$v</span>&quot;</span> <span class="token keyword">in</span>
<span class="token string">&quot;czbk&quot;</span><span class="token punctuation">)</span> 
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;传智播客&quot;</span>
   	<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token string">&quot;baidu&quot;</span><span class="token punctuation">)</span> 
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;baidu 搜索&quot;</span>
	<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token string">&quot;google&quot;</span><span class="token punctuation">)</span> 
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;google 搜索&quot;</span>
   	<span class="token punctuation">;</span><span class="token punctuation">;</span>
<span class="token keyword">esac</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h3 id="函数" tabindex="-1"><a class="header-anchor" href="#函数" aria-hidden="true">#</a> 函数</h3><h4 id="输入" tabindex="-1"><a class="header-anchor" href="#输入" aria-hidden="true">#</a> 输入</h4><p>函数语法如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token punctuation">[</span> <span class="token keyword">function</span> <span class="token punctuation">]</span> funname <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">{</span>
    action<span class="token punctuation">;</span>
    <span class="token punctuation">[</span>return int<span class="token punctuation">;</span><span class="token punctuation">]</span>

<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>1、可以使用function fun() 定义函数，也可以直接fun() 定义,不带任何参数。</li><li>2、函数参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#无参无返回值的方法</span>
<span class="token function-name function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;函数执行了!&quot;</span>
<span class="token punctuation">}</span>

<span class="token comment">#方法的调用</span>
<span class="token comment">#method</span>



<span class="token comment">#有参无返回值的方法</span>
<span class="token function-name function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;接收到的第一个参数<span class="token variable">$1</span>&quot;</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;接收到的第二个参数<span class="token variable">$2</span>&quot;</span>
<span class="token punctuation">}</span>

<span class="token comment">#方法的调用</span>
<span class="token comment">#method2 1 2</span>

<span class="token comment">#有参有返回值方法的定义</span>
<span class="token function-name function">method3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;接收到的第一个参数<span class="token variable">$1</span>&quot;</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;接收到的第二个参数<span class="token variable">$2</span>&quot;</span>
	<span class="token builtin class-name">return</span> <span class="token variable"><span class="token variable">$((</span>$<span class="token number">1</span> <span class="token operator">+</span> $<span class="token number">2</span><span class="token variable">))</span></span>
<span class="token punctuation">}</span>

<span class="token comment">#方法的调用</span>
method3 <span class="token number">10</span> <span class="token number">20</span>
<span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="读取" tabindex="-1"><a class="header-anchor" href="#读取" aria-hidden="true">#</a> 读取</h4><p><code>read 变量名</code> --- 表示把键盘录入的数据复制给这个变量</p><p>需求：在方法中键盘录入两个整数,返回这两个整数的和</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function-name function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;请录入第一个数&quot;</span>
	<span class="token builtin class-name">read</span> number1
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;请录入第二个数&quot;</span>
	<span class="token builtin class-name">read</span> number2
	<span class="token builtin class-name">echo</span> <span class="token string">&quot;两个数字分别为<span class="token variable">\${number1}</span>,<span class="token variable">\${number2}</span>&quot;</span>
	<span class="token builtin class-name">return</span> <span class="token variable"><span class="token variable">$((</span>number1<span class="token operator">+</span>number2<span class="token variable">))</span></span>
<span class="token punctuation">}</span>

method
<span class="token builtin class-name">echo</span> <span class="token variable">$?</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr>`,110);function y(w,q){const s=l("ExternalLinkIcon");return p(),o("div",null,[d,a("ul",null,[a("li",null,[a("p",null,[n("新建 "),a("a",c,[n("s.sh"),e(s)]),n(" 文件：touch "),a("a",u,[n("s.sh"),e(s)])])]),a("li",null,[a("p",null,[n("编辑 "),a("a",h,[n("s.sh"),e(s)]),n(" 文件：vim "),a("a",b,[n("s.sh"),e(s)])]),v]),m,a("li",null,[a("p",null,[n("chmod a+x "),a("a",k,[n("s.sh"),e(s)]),n(" s.sh文件权限是【-rwxrwxr-x】")])]),g,x]),f])}const I=i(r,[["render",y],["__file","Linux.html.vue"]]);export{I as default};
